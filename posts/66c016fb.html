<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no"><title>JVM | 北川的个人博客</title><meta name="keywords" content="JVM调优,JVM内存模型"><meta name="author" content="北川,1656473414@qq.com"><meta name="copyright" content="北川"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#f7f9fe"><meta name="mobile-web-app-capable" content="yes"><meta name="apple-touch-fullscreen" content="yes"><meta name="apple-mobile-web-app-title" content="JVM"><meta name="application-name" content="JVM"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="#f7f9fe"><meta property="og:type" content="article"><meta property="og:title" content="JVM"><meta property="og:url" content="https://gukeyang.github.io/posts/66c016fb.html"><meta property="og:site_name" content="北川的个人博客"><meta property="og:description" content="JVM是什么JVM是Java Virtual Machine（Java虚拟机）的缩写，JVM是一种用于计算设备的规范。引入Java虚拟机后，Java语言在不同平台上运行时不需要重新编译。Java语言编译程序只需生成在Java虚拟机上运行的目标代码（字节码），就可以在多种平台上不加修改地运行。任何平台"><meta property="og:locale" content="zh-CN"><meta property="og:image" content="https://s2.loli.net/2025/10/23/w3ErpsQhncfDed2.jpg?_r_=073fb3c1-1ed6-85dc-4b49-6bade417019f"><meta property="article:author" content="北川"><meta property="article:tag" content="博客,笔记,学习"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://s2.loli.net/2025/10/23/w3ErpsQhncfDed2.jpg?_r_=073fb3c1-1ed6-85dc-4b49-6bade417019f"><meta name="description" content="JVM是什么JVM是Java Virtual Machine（Java虚拟机）的缩写，JVM是一种用于计算设备的规范。引入Java虚拟机后，Java语言在不同平台上运行时不需要重新编译。Java语言编译程序只需生成在Java虚拟机上运行的目标代码（字节码），就可以在多种平台上不加修改地运行。任何平台"><link rel="shortcut icon" href="/favicon.ico"><link rel="canonical" href="https://gukeyang.github.io/posts/66c016fb"><link rel="preconnect" href="//cdn.cbd.int"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><meta name="google-site-verification" content="xxx"/><meta name="baidu-site-verification" content="code-xxx"/><meta name="msvalidate.01" content="xxx"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.cbd.int/node-snackbar@0.1.16/dist/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.cbd.int/@fancyapps/ui@5.0.20/dist/fancybox/fancybox.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://npm.elemecdn.com/anzhiyu-theme-static@1.0.0/swiper/swiper.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  linkPageTop: undefined,
  peoplecanvas: {"enable":true,"img":"https://upload-bbs.miyoushe.com/upload/2023/09/03/125766904/ee23df8517f3c3e3efc4145658269c06_5714860933110284659.png"},
  postHeadAiDescription: undefined,
  diytitle: {"enable":true,"leaveTitle":"w(ﾟДﾟ)w 不要走！再看看嘛！","backTitle":"♪(^∇^*)欢迎肥来！"},
  LA51: undefined,
  greetingBox: {"enable":true,"default":"晚上好👋","list":[{"greeting":"晚安😴","startTime":0,"endTime":5},{"greeting":"早上好鸭👋, 祝你一天好心情！","startTime":6,"endTime":9},{"greeting":"上午好👋, 状态很好，鼓励一下～","startTime":10,"endTime":10},{"greeting":"11点多啦, 在坚持一下就吃饭啦～","startTime":11,"endTime":11},{"greeting":"午安👋, 宝贝","startTime":12,"endTime":14},{"greeting":"🌈充实的一天辛苦啦！","startTime":14,"endTime":18},{"greeting":"19点喽, 奖励一顿丰盛的大餐吧🍔。","startTime":19,"endTime":19},{"greeting":"晚上好👋, 在属于自己的时间好好放松😌~","startTime":20,"endTime":24}]},
  twikooEnvId: '',
  commentBarrageConfig:{"enable":true,"maxBarrage":1,"barrageTime":4000,"accessToken":"","mailMd5":"3932F24FA213E964B6B1B0FD091F88CE"},
  root: '/',
  preloader: {"source":3},
  friends_vue_info: {"apiurl":"https://friends.anheyu.com/"},
  navMusic: true,
  mainTone: {"mode":"both","api":"https://img2color-go.vercel.app/api?img=","cover_change":true},
  authorStatus: {"skills":["🤖️ 数码科技爱好者","🔍 分享与热心帮助","🔨 设计开发一条龙","🏃 脚踏实地行动派"]},
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简","rightMenuMsgToTraditionalChinese":"转为繁体","rightMenuMsgToSimplifiedChinese":"转为简体"},
  noticeOutdate: {"limitDay":365,"position":"top","messagePrev":"It has been","messageNext":"days since the last update, the content of the article may be outdated."},
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":330},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: true,
    simplehomepage: false,
    post: true
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"copy":true,"copyrightEbable":true,"limitCount":50,"languages":{"author":"作者: 北川","link":"链接: ","source":"来源: 北川的个人博客","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。","copySuccess":"复制成功，复制和转载请标注本文地址"}},
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#425AEF","bgDark":"#1f1f1f","position":"top-center"},
  source: {
    justifiedGallery: {
      js: 'https://cdn.cbd.int/flickr-justified-gallery@2.1.2/dist/fjGallery.min.js',
      css: 'https://cdn.cbd.int/flickr-justified-gallery@2.1.2/dist/fjGallery.css'
    }
  },
  isPhotoFigcaption: true,
  islazyload: true,
  isAnchor: false,
  shortcutKey: undefined,
  autoDarkmode: true
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  configTitle: '北川的个人博客',
  title: 'JVM',
  postAI: '',
  pageFillDescription: 'JVM是什么, JVM的内存结构, 程序计数器, Java 虚拟机栈（Java 栈）, 本地方法栈（C 栈）, 堆, 方法区, 直接内存, JVM内存模型里的堆和栈有什么区别, 1. 线程共享性, 2. 存储内容, 3. 生命周期, 4. 大小与调整, 5. 垃圾回收, 6. 异常类型, 堆分为哪几个部分, 大对象一般存储在哪个区域, String s x3D new String（abc）执行过程中分别对应哪些内存区域？, 引用类型有哪些, 强引用, 弱引用, 软引用, 虚引用, 内存泄漏和内存溢出的理解？, 一、内存泄漏（Memory Leak）, 典型场景：, 二、内存溢出（Memory OverflowOOM）, 典型场景：, 栈溢出的情况怎么解决, 堆溢出的情况怎么解决, 类加载和初始化, 什么是类加载, 类加载器有哪些, Java中双亲委派是什么？有啥用？, 类加载的流程是怎么样的, 加载：, 链接（Linking）, 验证（Verification）, 准备（Preparation）, 解析（Resolution）, 初始化（Initialization）, 对象的创建过程, JVM的垃圾回收机制, 什么是垃圾回收（GC）？如何触发垃圾回收？, 1. Minor GC（轻量级回收）, 2. Major GC（老年代回收）, 3. Full GC（全量回收）, 判断垃圾的方法有哪些？, 垃圾回收器, JVM垃圾回收算法, JVM调优, JVM 调优的目的, 如何定位问题, JVM可调参数是什么是虚拟机的缩写是一种用于计算设备的规范引入虚拟机后语言在不同平台上运行时不需要重新编译语言编译程序只需生成在虚拟机上运行的目标代码字节码就可以在多种平台上不加修改地运行任何平台只要装有针对于该平台的虚拟机字节码文件就可以在该平台上运行这就是一次编译多次运行的内存结构虚拟机的内存空间分为个部分程序计数器虚拟机栈本地方法栈堆方法区程序计数器可以看作是当前线程所执行的字节码的行号指示器用于存储当前线程正在执行的方法的指令地址如果线程执行的是方法计数器值为是唯一一个在虚拟机规范中没有规定任何情况的区域生命周期与线程相同程序计数器的特点是一块较小的内存空间线程私有每条线程都有自己的程序计数器生命周期随着线程的创建而创建随着线程的结束而销毁是唯一一个不会出现的内存区域程序计数器的作用字节码解释器通过改变程序计数器来依次读取指令从而实现代码的流程控制在多线程情况下程序计数器记录的是当前线程执行的位置从而当线程切换回来时就知道上次线程执行到哪了虚拟机栈栈每个线程都有自己独立的虚拟机栈生命周期与线程相同每个方法在执行时都会创建一个栈帧用于存储局部变量表操作数栈动态链接方法出口等信息可能会抛出和异常虚拟机栈是描述方法运行过程的内存模型虚拟机栈会为每一个即将运行的方法创建一块叫做栈帧的区域用于存放该方法运行过程中的一些信息如局部变量表操作数栈动态链接方法出口信息本地方法栈栈本地方法栈是为运行方法准备的空间由于很多方法都是用语言实现的所以它通常又叫栈它与虚拟机栈实现的功能类似只不过本地方法栈是描述本地方法运行过程的内存模型堆是中最大的一块内存区域被所有线程共享在虚拟机启动时创建用于存放对象实例从内存回收角度堆被划分为新生代和老年代新生代又分为区和两个区和如果在堆中没有内存完成实例分配并且堆也无法扩展时会抛出异常堆是用来存放对象的内存空间几乎所有的对象都存储在堆中方法区在及以后的版本中方法区被元空间取代使用本地内存用于存储已被虚拟机加载的类信息常量静态变量等数据虽然方法区被描述为堆的逻辑部分但有非堆的别名方法区可以选择不实现垃圾收集内存不足时会抛出异常方法区中存放类信息常量静态变量即时编译器编译后的代码常量就存放在运行时常量池中直接内存不属于运行时数据区的一部分通过类引入是一种堆外内存可以显著提高性能直接内存的使用受到本机总内存的限制若分配不当可能导致异常内存模型里的堆和栈有什么区别线程共享性堆所有线程共享的内存区域堆中的对象实例可以被多个线程访问需考虑线程安全栈每个线程私有不共享每个线程在创建时会分配独立的虚拟机栈线程间的栈内存完全隔离存储内容堆主要存储对象实例和数组例如通过创建的对象定义的数组其实际数据都存储在堆中栈存储栈帧每个方法调用对应一个栈帧栈帧中包含局部变量表存储基本数据类型等以及对象的引用类型操作数栈方法执行时的临时数据操作动态链接指向运行时常量池的方法引用方法出口方法执行结束后返回的位置生命周期堆生命周期与进程一致只要运行堆就存在直到退出时才释放栈生命周期与线程一致线程创建时栈被初始化线程结束时栈被销毁栈中的栈帧则随方法调用入栈和结束出栈动态创建和销毁大小与调整堆是中最大的内存区域大小可通过参数调整默认由自动分配初始堆大小最大堆大小建议与设为相同避免频繁扩容栈每个线程的栈大小较小默认几百可通过参数调整例如栈大小固定或有上限无法动态扩容垃圾回收堆是垃圾回收的核心区域堆中对象实例若不再被引用无可达性会被垃圾收集器如回收释放内存栈无需垃圾回收栈帧随方法结束自动出栈销毁局部变量也随之释放内存回收是确定性的异常类型堆若内存不足无法分配新对象会抛出栈若方法调用层级过深如无限递归栈帧数量超过栈容量抛出若创建线程时无法为栈申请到足够内存如线程过多抛出堆分为哪几个部分堆是虚拟机中内存管理的一个重要区域主要用于存放对象实例和数组随着的发展和不同垃圾收集器的实现堆的具体划分可能会有所不同但通常可以分为以下几个部分新生代新生代分为和在中大多数新创建的对象首先存放在这里区相对较小当区满时会触发一次新生代垃圾回收在中通常分为两个相等大小的区域称为和在每次后存活下来的对象会被移动到其中一个空间以继续它们的生命周期这两个区域轮流充当对象的中转站帮助区分短暂存活的对象和长期存活的对象老年代存放过一次或多次仍存活的对象会被移动到老年代老年代中的对象生命周期较长因此也称为涉及老年代的垃圾回收发生的频率相对较低但其执行时间通常比长老年代的空间通常比新生代大以存储更多的长期存活对象大对象一般存储在哪个区域大对象通常会直接分配到老年代新生代主要用于存放生命周期较短的对象并且其内存空间相对较小如果将大对象分配到新生代可能会很快导致新生代空间不足从而频繁触发而每次都需要进行对象的复制和移动操作这会带来一定的性能开销将大对象直接分配到老年代可以减少新生代的内存压力降低的频率大对象通常需要连续的内存空间如果在新生代中频繁分配和回收大对象容易产生内存碎片导致后续分配大对象时可能因为内存不连续而失败老年代的空间相对较大更适合存储大对象有助于减少内存碎片的产生执行过程中分别对应哪些内存区域首先我们看到这个代码中有一个关键字我们知道指令是创建一个类的实例对象并完成加载初始化的因此这个字符串对象是在运行期才能确定的创建的字符串对象是在堆内存上其次在的构造方法中传递了一个字符串由于这里的是被修饰的属性所以它是一个字符串常量在首次构建这个对象时拿字面量去字符串常量池试图获取其对应对象的引用于是在堆中创建了一个的对象并将其引用保存到字符串常量池中然后返回所以如果这个字符串常量不存在则创建两个对象分别是这个字符串常量以及这个实例对象如果这字符串常量存在则只会创建一个对象引用类型有哪些强引用代码中普遍存在的赋值方式比如对象只要强引用存在被引用的对象绝对不会被垃圾回收器回收即使内存不足也会抛出而不会回收强引用指向的对象弱引用强度弱于强引用用于描述有用但非必需的对象当内存充足时软引用指向的对象不会被回收当内存不足即将发生时垃圾回收器会优先回收软引用指向的对象以释放内存软引用强度弱于软引用用于描述非必需的对象无论内存是否充足只要发生垃圾回收弱引用指向的对象都会被回收一旦触发立即回收场景适用于存储临时关联的对象避免内存泄漏例如的内部实现中的使用弱引用防止线程销毁后无法回收缓存中不常用的临时数据希望时自动清理虚引用强度最弱的引用又称幽灵引用或幻影引用几乎不影响对象的生命周期虚引用指向的对象随时可能被回收且无法通过方法获取对象调用始终返回唯一作用是当对象被回收时虚引用会被加入到关联的引用队列中用于跟踪对象的回收状态内存泄漏和内存溢出的理解内存泄漏和内存溢出是内存管理中两个密切相关但本质不同的概念前者是内存浪费的渐进过程后者是内存耗尽的最终结果具体区别和联系如下一内存泄漏定义程序中已动态分配的内存通常是堆内存中的对象由于逻辑错误或设计缺陷导致其不再被使用时仍被错误地持有引用无法被垃圾回收器回收从而长期占用内存的现象简单说该回收的内存没被回收变成了无效垃圾占用空间典型场景静态集合未清理静态集合如持有对象引用若只添加不删除对象会一直被强引用即使不再使用也无法回收监听器回调未移除注册的监听器如组件的事件监听器网络连接的回调若未在对象销毁前注销会导致监听器关联的对象被长期引用使用不当的中是弱引用但是强引用若线程长期存活如线程池核心线程且未调用会被永久持有导致内存泄漏资源未关闭数据库连接文件流网络等资源若未显式关闭其底层对象如可能被持有引用无法回收缓存未设置过期策略缓存如实现的本地缓存若无限存储数据且没有淘汰机制如会导致旧数据长期占用内存二内存溢出定义程序在申请内存时无法为其分配足够的内存空间如堆栈元空间等区域的剩余内存不足导致抛出的现象简单说需要的内存超过了可用内存申请不到内存了典型场景堆内存溢出短时间内创建大量对象如无限循环或内存泄漏累积到一定程度堆内存被耗尽元空间溢出动态生成大量类如代理脚本编译且类加载器未被回收元空间存储类元数据内存不足栈溢出方法调用层级过深如无限递归栈帧数量超过栈容量抛出本质是栈内存的溢出直接内存溢出的分配过多超过系统总内存或限制栈溢出的情况怎么解决从触发原因来看最常见的场景是无限递归调用因为方法调用时会在栈中创建栈帧存储局部变量操作数栈方法返回地址等每递归一次就会新增一个栈帧如果递归没有正确的终止条件栈帧会不断累积最终超过虚拟机栈的最大容量导致栈溢出另一种情况就是说单个方法的栈帧过大如果一个方法定义了大量局部变量或者局部变量占用内存过大比如大数组单个栈帧就会占用较多栈空间可能在调用层级不深时就耗尽栈内存解决思路首先排查递归逻辑查看是否存在无限递归调用或者递归层级过深的问题添加正确的终止条件或者减少递归深度调整栈内存的大小通过参数增大栈内存容量但是这种方式要谨慎占内存过大会导致线程可创建数量减少优化方法栈帧减少方法内局部变量的数量避免在方法中创建过大的对象和数组讲过大对象放到堆里面降低单个栈帧的内存占用堆溢出的情况怎么解决堆溢出通常发生在程序持续创建对象且无法被垃圾回收器回收的场景下捕获内存快照通过参数让程序在发生时自动生成堆快照文件使用或或者阿里的等工具分析快照重点看哪些对象占用了大量内存是否存在内存泄漏常见的解决思路根据原因不同而不同如果是内存泄漏比如静态集合无意识缓存大量对象长生命周期对象持有短生命周期对象的引用这时候需要梳理对象的引用链找到未释放的根源如果是内存不足即程序确实需要大量内存但当前配置太小可以通过调整参数比如类加载和初始化什么是类加载类加载就是把文件读进来解析成能理解的数据结构并在内存中生成一个对象的过程之后代码通过这个对象创建实例反射方法调用字段访问等都依赖这个类的元信息类加载器有哪些类加载的核心是即类加载器它负责根据类的全限定名如找到并加载对应的文件启动类加载器这是最顶层的类加载器他没有父加载器负责去加载的核心库它使用编写是的一部分启动类加载器无法被程序直接引用扩展类加载器它是语言实现的继承自类负责加载的扩展库扩展类加载器由启动类加载器加载应用类加载器默认加载下的类就是我们写的业务代码所在的加载器由实现自定义开发者可以继承实现方法自定义加载规则比如从网络加载类从数据库或加密文件加载热部署如中双亲委派是什么有啥用双亲委派机制是理解类加载体系的关键之一它直接关系到类的唯一性安全性以及模块隔离当一个类加载器要加载某个类时它不会自己立即动手而是先把这个请求交给父加载器去处理父加载器再往上层委托直到到达最顶层的只有当上层加载器都找不到该类时当前加载器才会自己去尝试加载假设我们调用加载流程如下由应用类加载器接收到加载请求它先把请求交给扩展类加载器扩展类加载器又将请求交给启动类加载器启动类加载器去或模块中查找找到了返回对象找不到抛出交回给子加载器若父加载器都加载失败子加载器才会尝试自己去加载作用保证核心类的安全性防止用户自定义假冒核心类避免类的重复加载要求同一个类同名同包只能被一个类加载器加载一次双亲委派确保了同一类只在最顶层被加载一次类加载的流程是怎么样的在规范中类加载包含以下个大阶段共个具体步骤加载链接验证准备解析初始化加载通过类的全限定名包名类名获取到该类的文件的二进制字节流将二进制字节流所代表的静态存储结构转化为方法区运行时的数据结构在内存中生成一个代表该类的对象作为方法区这个类的各种数据的访问入口链接链接就是把类加载进来后让它变成一个可执行的类验证确保类文件安全合法不会破坏虚拟机验证的个层面文件格式验证检查魔数版本号元数据验证比如类的父类是否存在是否继承类字节码验证指令流是否合法不会越界栈深度正确符号引用验证常量池中的符号引用是否合法这是安全防线防止恶意字节码攻击准备为类的静态变量类变量分配内存并赋默认值不是初始化值解析把常量池中的符号引用替换成直接引用解析阶段把这些字符串符号解析成指针内存地址指向实际的方法或字段有点像从名字查地址的过程解析可在运行时延迟进行称为懒解析初始化真正执行类中的初始化逻辑静态代码初始化的触发条件使用创建类实例调用类的静态方法访问类的静态变量反射调用子类初始化时父类先初始化含有方法的类执行内容执行静态变量的赋值语句执行静态代码块顺序遵循代码出现顺序父类先于子类初始化对象的创建过程类加载完毕后就可以实例化对象以为例做了以下几步检查类是否已经加载如果类未被加载或初始化会先触发上面的类加载流程分配内存在堆中在堆中为新对象分配所需的内存空间大小取决于类中实例变量的数量与类型内存初始化零值分配到的内存先清零确保对象的字段都有默认值数值型布尔型引用型此时对象结构已确定但还未执行任何构造代码设置对象头在对象头中写入一些重要信息类的元数据指针即指向对象标志哈希码锁状态偏向锁轻量级锁等这部分决定了对象能被识别锁定垃圾回收执行构造函数这一步是真正初始化对象逻辑的地方顺序如下调用父类构造函数按声明顺序给实例字段赋初始值执行子类构造函数体生成的字节码会调用方法特殊方法名返回对象引用构造完成后返回堆中对象的引用句柄或直接指针保存在栈帧的局部变量表中的垃圾回收机制什么是垃圾回收如何触发垃圾回收垃圾回收是自动管理程序内存的机制它帮助程序员自动释放那些不再被程序所使用的内存对象从而避免内存泄漏等问题内存不足时当检测到堆内存不足无法为新的对象分配内存时就会触发垃圾回收手动请求虽然垃圾回收是自动的开发者可以通过调用或建议进行垃圾回收参数启动应用时可以通过参数来调整垃圾回收的行为比如最大堆大小初始堆大小对象数量或者内存使用达到阈值垃圾收集器内部实现了一些策略以监控对象的创建和内存使用达到某个阈值时触发采用分代回收机制不同代用不同策略提高效率于是就有了轻量级回收目标清理新生代区的对象大多是短命对象时幸存的对象从若多次仍存活则晋升到老年代成本停顿时间短频率高触发时机区空间不足时自动触发老年代回收目标清理老年代老年代的对象多为长期存活或晋升对象使用标记清除或标记整理算法效率低停顿时间明显长于触发时机老年代空间不足无法存放新晋升对象时触发全量回收目标回收整个堆元空间代价极高应用线程全部暂停通常是无路可退的最后手段判断垃圾的方法有哪些在中判断对象是否为垃圾即不再被使用可以被垃圾回收器回收主要依据两种主流的垃圾回收算法来实现引用计数法和可达性分析算法引用计数法原理为每个对象分配一个引用计数器每当有一个地方引用它时计数器加当引用失效时计数器减当计数器为时表示对象不再被任何变量引用可以被回收缺点不能解决循环引用的问题即两个对象相互引用但不再被其他任何对象引用这时引用计数器不会为导致对象无法被回收可达性分析算法原理从一组称为垃圾收集根的对象出发向下追溯它们引用的对象以及这些对象引用的其他对象以此类推如果一个对象到没有任何引用链相连即从到这个对象不可达那么这个对象就被认为是不可达的可以被回收对象包括虚拟机栈栈帧中的本地变量表中引用的对象方法区中类静态属性引用的对象本地方法栈中引用的对象活跃线程的引用等是什么是垃圾回收中判断对象是否存活的起点在中垃圾回收并不是简单地扫描所有对象而是从一组特定的根对象出发沿着引用链去搜索如果一个对象能被这些根对象直接或间接引用到就认为它是可达的因此不会被回收中能作为的对象主要包括以下几类虚拟机栈栈帧中的局部变量表中的引用对象比如方法中定义的局部变量方法参数临时对象引用当线程执行到某个方法时这个方法栈帧里的变量就是活跃的方法区中类静态属性引用的对象比如修饰的成员变量引用的对象静态变量属于类而非实例因此始终存在于生命周期内方法区中常量引用的对象比如字符串常量池中的对象是在方法区中常量池引用的对象本地方法栈中方法引用的对象即通过方法调用的本地代码中使用到的对象引用全称是正在被同步锁持有的对象比如正在被锁住的对象中的会认为它仍然被使用因此不能被自身持有的系统类加载器等特殊引用比如类加载器线程对象异常对象等这些对象是自身运行所需的不会轻易被垃圾回收器单线程求吞吐追响应智能平衡超低延迟收集器复制算法新生代单线程收集器标记和清理都是单线程优点是简单高效收集器复制算法新生代收并行集器实际上是收集器的多线程版本在多核环境下有着比更好的表现收集器复制算法新生代并行收集器追求高吞吐量高效利用吞吐量用户线程时间用户线程时间线程时间高吞吐量可以高效率的利用时间尽快完成程序的运算任务适合后台应用等对交互相应要求不高的场景收集器标记整理算法老年代单线程收集器收集器的老年代版本收集器标记整理算法老年代并行收集器吞吐量优先收集器的老年代版本收集器标记清除算法老年代并行收集器以获取最短回收停顿时间为目标的收集器具有高并发低停顿的特点追求最短回收停顿时间收集器标记整理算法堆并行收集器收集器是提供的一个新收集器收集器基于标记整理算法实现也就是说不会产生内存碎片此外收集器不同于之前的收集器的一个重要特点是回收的范围是整个堆包括新生代老年代而前六种收集器回收的范围仅限于新生代或老年代垃圾回收算法自动识别不再被引用的对象并安全高效地释放内存它是怎么识别垃圾怎么清理垃圾怎么移动对象的一系列策略算法名称核心思想优点缺点典型应用标记清除分两步先标记所有存活对象再清除未标记的简单无需移动对象产生内存碎片分配新对象效率低老年代复制算法把活对象复制到另一块空闲区域再清空原区域无碎片分配快浪费一半内存空间新生代标记整理标记存活对象后将它们移动到堆的一端再清除其他区域无碎片空间连续需要对象移动成本高老年代阶段分代收集新生代用复制算法老年代用标记整理综合效率高实现复杂几乎所有现代默认策略区域化收集如把堆划分为许多每个独立回收并行可预测停顿时间实现复杂元数据管理成本高调优调优的目的减少停顿时间避免频繁降低对系统吞吐的影响提升吞吐量比如大数据处理高并发接口目标是绝大部分时间都在跑业务逻辑而不是收垃圾防止内存溢出或内存泄漏程序在运行一段时间后稳定且不崩溃如何定位问题常见的性能问题的类型类型典型表现解决方向频繁吞吐量下降系统卡顿优化参数或对象生命周期内存溢出系统崩溃或接口排查内存泄漏响应慢停顿时间长优化算法或堆结构飙高线程占用过多减少对象创建或调整线程并发可用的诊断工具监控次数与时间生成堆转储分析实时监控堆线程类加载阿里开源神器定位卡顿或内存泄漏可调参数参数含义初始堆大小最大堆大小新生代大小与比例默认新生代与老年代比例使用垃圾回收器常用使用垃圾回收器推荐目标最大停顿时间吞吐量目标时间与非时间比输出详细日志日志路径',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2025-10-27 11:55:14',
  postMainColor: '',
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#18171d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#f7f9fe')
        }
      }
      const t = saveToLocal.get('theme')
    
          const isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
          const isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
          const isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
          const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

          if (t === undefined) {
            if (isLightMode) activateLightMode()
            else if (isDarkMode) activateDarkMode()
            else if (isNotSpecified || hasNoSupport) {
              const now = new Date()
              const hour = now.getHours()
              const isNight = hour <= 6 || hour >= 18
              isNight ? activateDarkMode() : activateLightMode()
            }
            window.matchMedia('(prefers-color-scheme: dark)').addListener(e => {
              if (saveToLocal.get('theme') === undefined) {
                e.matches ? activateDarkMode() : activateLightMode()
              }
            })
          } else if (t === 'light') activateLightMode()
          else activateDarkMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.3.0"></head><body data-type="anzhiyu"><div id="web_bg"></div><div id="an_music_bg"></div><div id="loading-box" onclick="document.getElementById(&quot;loading-box&quot;).classList.add(&quot;loaded&quot;)"><div class="loading-bg"><img class="loading-img nolazyload" alt="加载头像" src="https://s2.loli.net/2022/11/07/QVWvrnAsuGxelbS.jpg"/><div class="loading-image-dot"></div></div></div><script>const preloader = {
  endLoading: () => {
    document.getElementById('loading-box').classList.add("loaded");
  },
  initLoading: () => {
    document.getElementById('loading-box').classList.remove("loaded")
  }
}
window.addEventListener('load',()=> { preloader.endLoading() })
setTimeout(function(){preloader.endLoading();},10000)

if (true) {
  document.addEventListener('pjax:send', () => { preloader.initLoading() })
  document.addEventListener('pjax:complete', () => { preloader.endLoading() })
}</script><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.1.10/progress_bar/progress_bar.css"/><script async="async" src="https://cdn.cbd.int/pace-js@1.2.4/pace.min.js" data-pace-options="{ &quot;restartOnRequestAfter&quot;:false,&quot;eventLag&quot;:false}"></script><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><div id="nav-group"><span id="blog_name"><a id="site-name" href="/" accesskey="h"><div class="title">北川的个人博客</div><i class="anzhiyufont anzhiyu-icon-house-chimney"></i></a></span><div class="mask-name-container"><div id="name-container"><a id="page-name" href="javascript:anzhiyu.scrollToDest(0, 500)">PAGE_NAME</a></div></div><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 文章</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/archives/"><i class="anzhiyufont anzhiyu-icon-box-archive faa-tada" style="font-size: 0.9em;"></i><span> 隧道</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/categories/"><i class="anzhiyufont anzhiyu-icon-shapes faa-tada" style="font-size: 0.9em;"></i><span> 分类</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/tags/"><i class="anzhiyufont anzhiyu-icon-tags faa-tada" style="font-size: 0.9em;"></i><span> 标签</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 友链</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/link/"><i class="anzhiyufont anzhiyu-icon-link faa-tada" style="font-size: 0.9em;"></i><span> 友人帐</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/fcircle/"><i class="anzhiyufont anzhiyu-icon-artstation faa-tada" style="font-size: 0.9em;"></i><span> 朋友圈</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/comments/"><i class="anzhiyufont anzhiyu-icon-envelope faa-tada" style="font-size: 0.9em;"></i><span> 留言板</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 我的</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/music/?id=2898229193&amp;server=netease"><i class="anzhiyufont anzhiyu-icon-music faa-tada" style="font-size: 0.9em;"></i><span> 音乐馆</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/album/"><i class="anzhiyufont anzhiyu-icon-images faa-tada" style="font-size: 0.9em;"></i><span> 相册集</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/air-conditioner/"><i class="anzhiyufont anzhiyu-icon-fan faa-tada" style="font-size: 0.9em;"></i><span> 小空调</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 关于</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/about/"><i class="anzhiyufont anzhiyu-icon-paper-plane faa-tada" style="font-size: 0.9em;"></i><span> 关于本人</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/essay/"><i class="anzhiyufont anzhiyu-icon-lightbulb faa-tada" style="font-size: 0.9em;"></i><span> 闲言碎语</span></a></li></ul></div></div></div><div id="nav-right"><div class="nav-button" id="randomPost_button"><a class="site-page" onclick="toRandomPost()" title="随机前往一个文章" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-dice"></i></a></div><input id="center-console" type="checkbox"/><label class="widget" for="center-console" title="中控台" onclick="anzhiyu.switchConsole();"><i class="left"></i><i class="widget center"></i><i class="widget right"></i></label><div id="console"><div class="console-card-group-reward"><ul class="reward-all console-card"><li class="reward-item"><a href="/./img/wechat.jpg" target="_blank"><img class="post-qr-code-img" alt="微信" src="/./img/wechat.jpg"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="/./img/alipay.jpg" target="_blank"><img class="post-qr-code-img" alt="支付宝" src="/./img/alipay.jpg"/></a><div class="post-qr-code-desc">支付宝</div></li></ul></div><div class="console-card-group"><div class="console-card-group-left"><div class="console-card" id="card-newest-comments"><div class="card-content"><div class="author-content-item-tips">互动</div><span class="author-content-item-title"> 最新评论</span></div><div class="aside-list"><span>正在加载中...</span></div></div></div><div class="console-card-group-right"><div class="console-card tags"><div class="card-content"><div class="author-content-item-tips">兴趣点</div><span class="author-content-item-title">寻找你感兴趣的领域</span><div class="card-tags"><div class="item-headline"></div><div class="card-tag-cloud"><a href="/tags/JVM%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/" style="font-size: 1.05rem;">JVM内存模型<sup>1</sup></a><a href="/tags/JVM%E8%B0%83%E4%BC%98/" style="font-size: 1.05rem;">JVM调优<sup>1</sup></a><a href="/tags/java%E6%95%99%E7%A8%8B/" style="font-size: 1.05rem;">java教程<sup>1</sup></a><a href="/tags/mysql/" style="font-size: 1.05rem;">mysql<sup>1</sup></a><a href="/tags/%E5%87%BD%E6%95%B0/" style="font-size: 1.05rem;">函数<sup>1</sup></a><a href="/tags/%E5%8F%8D%E5%B0%84/" style="font-size: 1.05rem;">反射<sup>1</sup></a><a href="/tags/%E5%A4%8D%E4%B9%A0/" style="font-size: 1.05rem;">复习<sup>1</sup></a><a href="/tags/%E5%A4%8D%E4%B9%A0-%E5%8F%98%E9%87%8F/" style="font-size: 1.05rem;">复习 变量<sup>1</sup></a><a href="/tags/%E5%B7%A5%E5%85%B7/" style="font-size: 1.05rem;">工具<sup>1</sup></a><a href="/tags/%E5%B9%B6%E5%8F%91/" style="font-size: 1.05rem;">并发<sup>1</sup></a><a href="/tags/%E6%83%85%E6%84%9F/" style="font-size: 1.05rem;">情感<sup>1</sup></a><a href="/tags/%E6%8A%BD%E8%B1%A1%E7%B1%BB-%E6%8E%A5%E5%8F%A3/" style="font-size: 1.05rem;">抽象类 接口<sup>1</sup></a><a href="/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/" style="font-size: 1.05rem;">数据库<sup>1</sup></a><a href="/tags/%E6%AF%8F%E6%97%A5%E9%9D%A2%E8%AF%95/" style="font-size: 1.05rem;">每日面试<sup>2</sup></a><a href="/tags/%E7%94%B5%E5%95%86-%E8%AE%A2%E5%8D%95/" style="font-size: 1.05rem;">电商,订单<sup>1</sup></a><a href="/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" style="font-size: 1.05rem;">设计模式<sup>1</sup></a><a href="/tags/%E8%B6%85%E5%8D%96-%E5%BA%93%E5%AD%98/" style="font-size: 1.05rem;">超卖 , 库存<sup>1</sup></a><a href="/tags/%E9%9B%86%E5%90%88/" style="font-size: 1.05rem;">集合<sup>1</sup></a></div></div><hr/></div></div><div class="console-card history"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-box-archiv"></i><span>文章</span></div><div class="card-archives"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-archive"></i><span>归档</span></div><ul class="card-archive-list"><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2025/10/"><span class="card-archive-list-date">十月 2025</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">9</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2025/04/"><span class="card-archive-list-date">四月 2025</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">4</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2023/10/"><span class="card-archive-list-date">十月 2023</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">3</span><span>篇</span></div></a></li></ul></div><hr/></div></div></div><div class="button-group"><div class="console-btn-item"><a class="darkmode_switchbutton" title="显示模式切换" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-moon"></i></a></div><div class="console-btn-item" id="consoleHideAside" onclick="anzhiyu.hideAsideBtn()" title="边栏显示控制"><a class="asideSwitch"><i class="anzhiyufont anzhiyu-icon-arrows-left-right"></i></a></div><div class="console-btn-item on" id="consoleCommentBarrage" onclick="anzhiyu.switchCommentBarrage()" title="热评开关"><a class="commentBarrage"><i class="anzhiyufont anzhiyu-icon-message"></i></a></div><div class="console-btn-item" id="consoleMusic" onclick="anzhiyu.musicToggle()" title="音乐开关"><a class="music-switch"><i class="anzhiyufont anzhiyu-icon-music"></i></a></div></div><div class="console-mask" onclick="anzhiyu.hideConsole()" href="javascript:void(0);"></div></div><div class="nav-button" id="nav-totop"><a class="totopbtn" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i><span id="percent" onclick="anzhiyu.scrollToDest(0,500)">0</span></a></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);" title="切换"><i class="anzhiyufont anzhiyu-icon-bars"></i></a></div></div></div></nav><div id="post-info"><div id="post-firstinfo"><div class="meta-firstline"><a class="post-meta-original">原创</a><span class="post-meta-categories"><span class="post-meta-separator"></span><i class="anzhiyufont anzhiyu-icon-inbox post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E9%9D%A2%E8%AF%95%E9%A2%98/" itemprop="url">面试题</a></span><span class="article-meta tags"><a class="article-meta__tags" href="/tags/JVM%E8%B0%83%E4%BC%98/" tabindex="-1" itemprop="url"> <span> <i class="anzhiyufont anzhiyu-icon-hashtag"></i>JVM调优</span></a><a class="article-meta__tags" href="/tags/JVM%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/" tabindex="-1" itemprop="url"> <span> <i class="anzhiyufont anzhiyu-icon-hashtag"></i>JVM内存模型</span></a></span></div></div><h1 class="post-title" itemprop="name headline">JVM</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="anzhiyufont anzhiyu-icon-calendar-days post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" itemprop="dateCreated datePublished" datetime="2025-10-24T15:31:36.000Z" title="发表于 2025-10-24 23:31:36">2025-10-24</time><span class="post-meta-separator"></span><i class="anzhiyufont anzhiyu-icon-history post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" itemprop="dateCreated datePublished" datetime="2025-10-27T03:55:14.485Z" title="更新于 2025-10-27 11:55:14">2025-10-27</time></span></div><div class="meta-secondline"><span class="post-meta-separator"></span><span class="post-meta-pv-cv" id="" data-flag-title="JVM"><i class="anzhiyufont anzhiyu-icon-fw-eye post-meta-icon"></i><span class="post-meta-label" title="阅读量">阅读量:</span><span id="busuanzi_value_page_pv"><i class="anzhiyufont anzhiyu-icon-spinner anzhiyu-spin"></i></span></span><span class="post-meta-separator">       </span><span class="post-meta-position" title="作者IP属地为新乡"><i class="anzhiyufont anzhiyu-icon-location-dot"></i>新乡</span><span class="post-meta-separator"></span><span class="post-meta-commentcount"><i class="anzhiyufont anzhiyu-icon-comments post-meta-icon"></i><span class="post-meta-label">评论数:</span><a href="/posts/66c016fb.html#post-comment" itemprop="discussionUrl"><span class="valine-comment-count" data-xid="/posts/66c016fb.html" itemprop="commentCount"><i class="anzhiyufont anzhiyu-icon-spinner anzhiyu-spin"></i></span></a></span></div></div></div><section class="main-hero-waves-area waves-area"><svg class="waves-svg" xmlns="http://www.w3.org/2000/svg" xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M -160 44 c 30 0 58 -18 88 -18 s 58 18 88 18 s 58 -18 88 -18 s 58 18 88 18 v 44 h -352 Z"></path></defs><g class="parallax"><use href="#gentle-wave" x="48" y="0"></use><use href="#gentle-wave" x="48" y="3"></use><use href="#gentle-wave" x="48" y="5"></use><use href="#gentle-wave" x="48" y="7"></use></g></svg></section><div id="post-top-cover"><img class="nolazyload" id="post-top-bg" src="https://s2.loli.net/2025/10/23/w3ErpsQhncfDed2.jpg?_r_=073fb3c1-1ed6-85dc-4b49-6bade417019f"></div></header><main id="blog-container"><div class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container" itemscope itemtype="https://gukeyang.github.io/posts/66c016fb.html"><header><a class="post-meta-categories" href="/categories/%E9%9D%A2%E8%AF%95%E9%A2%98/" itemprop="url">面试题</a><a href="/tags/JVM%E8%B0%83%E4%BC%98/" tabindex="-1" itemprop="url">JVM调优</a><a href="/tags/JVM%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/" tabindex="-1" itemprop="url">JVM内存模型</a><h1 id="CrawlerTitle" itemprop="name headline">JVM</h1><span itemprop="author" itemscope itemtype="http://schema.org/Person">北川</span><time itemprop="dateCreated datePublished" datetime="2025-10-24T15:31:36.000Z" title="发表于 2025-10-24 23:31:36">2025-10-24</time><time itemprop="dateCreated datePublished" datetime="2025-10-27T03:55:14.485Z" title="更新于 2025-10-27 11:55:14">2025-10-27</time></header><h2 id="JVM是什么"><a href="#JVM是什么" class="headerlink" title="JVM是什么"></a>JVM是什么</h2><p>JVM是<code>Java Virtual Machine</code>（Java虚拟机）的缩写，JVM是一种用于<strong>计算设备的规范</strong>。引入Java虚拟机后，Java语言在不同平台上运行时<strong>不需要重新编译</strong>。Java语言编译程序只需生成在Java虚拟机上运行的<strong>目标代码（字节码）</strong>，就可以在多种平台上不加修改地运行。任何平台只要装有针对于该平台的Java虚拟机，字节码文件（.class）就可以在该平台上运行。这就是“一次编译，多次运行”。</p>
<h2 id="JVM的内存结构"><a href="#JVM的内存结构" class="headerlink" title="JVM的内存结构"></a>JVM的内存结构</h2><p>Java 虚拟机的内存空间分为 5 个部分：</p>
<ul>
<li>程序计数器</li>
<li>Java 虚拟机栈</li>
<li>本地方法栈</li>
<li>堆</li>
<li>方法区</li>
</ul>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn-doocs.oss-cn-shenzhen.aliyuncs.com/gh/doocs/jvm@main/images/jvm-memory-structure.jpg" alt="jvm-memory-structure" style="zoom: 80%;" />

<h3 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h3><p>​	可以看作是当前线程所执行的字节码的行号指示器，用于存储当前线程正在执行的Java方法的JVM指令地址。如果线程执行的是Native方法，计数器值为null。是唯一一个在Java虚拟机规范中没有规定任何OutOfMemoryError情况的区域，生命周期与线程相同。</p>
<p>程序计数器的特点</p>
<ul>
<li>是一块较小的内存空间。</li>
<li>线程私有，每条线程都有自己的程序计数器。</li>
<li>生命周期：随着线程的创建而创建，随着线程的结束而销毁。</li>
<li>是唯一一个不会出现 <code>OutOfMemoryError</code> 的内存区域。</li>
</ul>
<p><strong>程序计数器的作用</strong></p>
<ul>
<li>字节码解释器通过改变程序计数器来依次读取指令，从而实现代码的流程控制。</li>
<li>在多线程情况下，程序计数器记录的是当前线程执行的位置，从而当线程切换回来时，就知道上次线程执行到哪了。</li>
</ul>
<h3 id="Java-虚拟机栈（Java-栈）"><a href="#Java-虚拟机栈（Java-栈）" class="headerlink" title="Java 虚拟机栈（Java 栈）"></a>Java 虚拟机栈（Java 栈）</h3><p>​	每个线程都有自己独立的Java虚拟机栈，生命周期与线程相同。每个方法在执行时都会创建一个栈帧，用于存储局部变量表、操作数栈、动态链接、方法出口等信息。可能会抛出StackOverflowError 和 OutOfMemoryError异常。</p>
<p>Java 虚拟机栈是描述 Java 方法运行过程的内存模型。</p>
<p>Java 虚拟机栈会为每一个即将运行的 Java 方法创建一块叫做“栈帧”的区域，用于存放该方法运行过程中的一些信息，如：</p>
<ul>
<li>局部变量表</li>
<li>操作数栈</li>
<li>动态链接</li>
<li>方法出口信息</li>
<li>……</li>
</ul>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn-doocs.oss-cn-shenzhen.aliyuncs.com/gh/doocs/jvm@main/images/jvm-stack.jpg" alt="jvm-stack" style="zoom:80%;" />

<h3 id="本地方法栈（C-栈）"><a href="#本地方法栈（C-栈）" class="headerlink" title="本地方法栈（C 栈）"></a>本地方法栈（C 栈）</h3><p>本地方法栈是为 JVM 运行 Native 方法准备的空间，由于很多 Native 方法都是用 C 语言实现的，所以它通常又叫 C 栈。它与 Java 虚拟机栈实现的功能类似，只不过本地方法栈是描述本地方法运行过程的内存模型。</p>
<h3 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h3><p>​	是JVM中最大的一块内存区域，被所有线程共享，在虚拟机启动时创建，用于存放对象实例。从内存回收角度，堆被划分为新生代和老年代，新生代又分为Eden区和两个Survivor区（From Survivor和To Survivor）。如果在堆中没有内存完成实例分配，并且堆也无法扩展时会抛出Out Of Memory Error异常。</p>
<p>堆是用来存放对象的内存空间，<code>几乎</code>所有的对象都存储在堆中。</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn-doocs.oss-cn-shenzhen.aliyuncs.com/gh/doocs/jvm@main/images/jvm-memory.png" alt="jvm-memory" style="zoom: 67%;" />

<h3 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h3><p>​	在JDK1.8及以后的版本中，方法区被元空间取代，使用本地内存。用于存储已被虚拟机加载的类信息、常量、静态变量等数据。虽然方法区被描述为堆的逻辑部分，但有“非堆”的别名。方法区可以选择不实现垃圾收集，内存不足时会抛出OutOfMemoryError异常。</p>
<ul>
<li>方法区中存放：类信息、常量、静态变量、即时编译器编译后的代码。常量就存放在运行时常量池中。</li>
</ul>
<h3 id="直接内存"><a href="#直接内存" class="headerlink" title="直接内存"></a>直接内存</h3><p>不属于 JM 运行时数据区的一部分，通过 NIO 类引入，是一种堆外内存，可以显著提高IO 性能。直接内存的使用受到本机总内存的限制，若分配不当，可能导致 OutOfMemoryError 异常。</p>
<h2 id="JVM内存模型里的堆和栈有什么区别"><a href="#JVM内存模型里的堆和栈有什么区别" class="headerlink" title="JVM内存模型里的堆和栈有什么区别"></a>JVM内存模型里的堆和栈有什么区别</h2><h3 id="1-线程共享性"><a href="#1-线程共享性" class="headerlink" title="1. 线程共享性"></a>1. <strong>线程共享性</strong></h3><ul>
<li><strong>堆</strong>：所有线程<strong>共享</strong>的内存区域。堆中的对象实例可以被多个线程访问（需考虑线程安全）。</li>
<li><strong>栈</strong>：每个线程<strong>私有</strong>，不共享。每个线程在创建时会分配独立的虚拟机栈，线程间的栈内存完全隔离。</li>
</ul>
<h3 id="2-存储内容"><a href="#2-存储内容" class="headerlink" title="2. 存储内容"></a>2. <strong>存储内容</strong></h3><ul>
<li><p>堆：主要存储对象实例和数组</p>
<p>。例如，通过new Object()创建的对象、int[] arr &#x3D; new int[10]定义的数组，其实际数据都存储在堆中。</p>
</li>
<li><p>栈：存储栈帧</p>
<p>（每个方法调用对应一个栈帧），栈帧中包含：</p>
<ul>
<li>局部变量表（存储基本数据类型：<code>int</code>、<code>char</code>等，以及对象的引用<code>reference</code>类型）；</li>
<li>操作数栈（方法执行时的临时数据操作）；</li>
<li>动态链接（指向运行时常量池的方法引用）；</li>
<li>方法出口（方法执行结束后返回的位置）。</li>
</ul>
</li>
</ul>
<h3 id="3-生命周期"><a href="#3-生命周期" class="headerlink" title="3. 生命周期"></a>3. <strong>生命周期</strong></h3><ul>
<li><strong>堆</strong>：生命周期与 JVM 进程一致。只要 JVM 运行，堆就存在，直到 JVM 退出时才释放。</li>
<li><strong>栈</strong>：生命周期与线程一致。线程创建时栈被初始化，线程结束时栈被销毁；栈中的栈帧则随方法调用（入栈）和结束（出栈）动态创建和销毁。</li>
</ul>
<h3 id="4-大小与调整"><a href="#4-大小与调整" class="headerlink" title="4. 大小与调整"></a>4. <strong>大小与调整</strong></h3><ul>
<li>堆：是 JVM 中最大的内存区域，大小可通过参数调整（默认由 JVM 自动分配）：<ul>
<li><code>-Xms</code>：初始堆大小；</li>
<li><code>-Xmx</code>：最大堆大小（建议与<code>-Xms</code>设为相同，避免频繁扩容）。</li>
</ul>
</li>
<li><strong>栈</strong>：每个线程的栈大小较小（默认几百 KB），可通过<code>-Xss</code>参数调整（例如<code>-Xss256k</code>）。栈大小固定或有上限，无法动态扩容。</li>
</ul>
<h3 id="5-垃圾回收"><a href="#5-垃圾回收" class="headerlink" title="5. 垃圾回收"></a>5. <strong>垃圾回收</strong></h3><ul>
<li><strong>堆</strong>：是垃圾回收的<strong>核心区域</strong>。堆中对象实例若不再被引用（无可达性），会被垃圾收集器（如 G1、ZGC）回收，释放内存。</li>
<li><strong>栈</strong>：无需垃圾回收。栈帧随方法结束自动出栈销毁，局部变量也随之释放，内存回收是 “确定性” 的。</li>
</ul>
<h3 id="6-异常类型"><a href="#6-异常类型" class="headerlink" title="6. 异常类型"></a>6. <strong>异常类型</strong></h3><ul>
<li><strong>堆</strong>：若内存不足无法分配新对象，会抛出<code>OutOfMemoryError: Java heap space</code>。</li>
<li>栈：<ul>
<li>若方法调用层级过深（如无限递归），栈帧数量超过栈容量，抛出<code>StackOverflowError</code>；</li>
<li>若创建线程时无法为栈申请到足够内存（如线程过多），抛出<code>OutOfMemoryError: unable to create new native thread</code>。</li>
</ul>
</li>
</ul>
<h2 id="堆分为哪几个部分"><a href="#堆分为哪几个部分" class="headerlink" title="堆分为哪几个部分"></a>堆分为哪几个部分</h2><p>Java堆（Heap）是Java虚拟机(JVM）中内存管理的一个重要区域，主要用于存放对象实例和数组。随着JVM的发展和不同垃圾收集器的实现，堆的具体划分可能会有所不同，但通常可以分为以下几个部分：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.xiaolincoding.com//picgo/1719974471041-14f6ed7f-358b-426a-b614-2501ceae0035.png" alt="img"></p>
<p><strong>新生代(YoungGeneration）</strong>:新生代分为Eden Space和Survivor Space。在Eden Space中，大多数新创建的对象首先存放在这里。Eden区相对较小，当Eden区满时，会触发一次MinorGC（新生代垃圾回收）。在Survivor Spaces中，通常分为两个相等大小的区域，称为S0(Survivor 0）和S1(Survivor1)。在每次MinorGC后，存活下来的对象会被移动到其中一个Survivor空间，以继续它们的生命周期。这两<br>个区域轮流充当对象的中转站，帮助区分短暂存活的对象和长期存活的对象。</p>
<p><strong>老年代(OldGeneration&#x2F;TenuredGeneration）</strong>：存放过一次或多次MinorGC仍存活的对象会被移动到老年代。老年代中的对象生命周期较长，因此MajorGC（也称为FullGC，涉及老年代的垃圾回收）发生的频率相对较低，但其执行时间通常比MinorGC长。老年代的空间通常比新生代大，以存储更多的长期存活对象。</p>
<h2 id="大对象一般存储在哪个区域"><a href="#大对象一般存储在哪个区域" class="headerlink" title="大对象一般存储在哪个区域"></a>大对象一般存储在哪个区域</h2><p>大对象通常会直接分配到老年代。<br>    新生代主要用于存放生命周期较短的对象，并且其内存空间相对较小。如果将大对象分配到新生代，可能会很快导致新生代空间不足，从而频繁触发MinorGC。而每次MinorGC都需要进行对象的复制和移动操作，这会带来一定的性能开销。将大对象直接分配到老年代，可以减少新生代的内存压力，降低MinorGC 的频率。<br>    大对象通常需要连续的内存空间，如果在新生代中频繁分配和回收大对象，容易产生内存碎片，导致后续<br>分配大对象时可能因为内存不连续而失败。老年代的空间相对较大，更适合存储大对象，有助于减少内存<br>碎片的产生。</p>
<h2 id="String-s-new-String（“abc”）执行过程中分别对应哪些内存区域？"><a href="#String-s-new-String（“abc”）执行过程中分别对应哪些内存区域？" class="headerlink" title="String s &#x3D; new String（“abc”）执行过程中分别对应哪些内存区域？"></a>String s &#x3D; new String（“abc”）执行过程中分别对应哪些内存区域？</h2><p>​	首先，我们看到这个代码中有一个new关键字，我们知道new指令是创建一个类的实例对象并完成加载初始化的，因此这个字符串对象是在运行期才能确定的，创建的字符串对象是在堆内存上。<br>​	其次，在String的构造方法中传递了一个字符串abc，由于这里的abc是被final修饰的属性，所以它是一个<br>字符串常量。在首次构建这个对象时，JVM拿字面量“abc“去字符串常量池试图获取其对应String对象的引<br>用。于是在堆中创建了一个”abc”的String对象，并将其引用保存到字符串常量池中，然后返回；<br>​	所以，如果abc这个字符串常量不存在，则创建两个对象，分别是abc这个字符串常量，以及newString这<br>个实例对象。如果abc这字符串常量存在，则只会创建一个对象。</p>
<h2 id="引用类型有哪些"><a href="#引用类型有哪些" class="headerlink" title="引用类型有哪些"></a>引用类型有哪些</h2><h3 id="强引用"><a href="#强引用" class="headerlink" title="强引用"></a>强引用</h3><p>代码中普遍存在的赋值方式，比如new对象。只要强引用存在，被引用的对象<strong>绝对不会被垃圾回收器回收</strong>，即使内存不足，JVM 也会抛出<code>OutOfMemoryError</code>，而不会回收强引用指向的对象。</p>
<h3 id="弱引用"><a href="#弱引用" class="headerlink" title="弱引用"></a>弱引用</h3><p>强度弱于强引用，用于描述「有用但非必需」的对象。</p>
<ul>
<li>当内存充足时，软引用指向的对象不会被回收；</li>
<li>当内存不足（即将发生 OOM）时，垃圾回收器会<strong>优先回收软引用指向的对象</strong>，以释放内存。</li>
</ul>
<h3 id="软引用"><a href="#软引用" class="headerlink" title="软引用"></a>软引用</h3><p>强度弱于软引用，用于描述「非必需」的对象。</p>
<p>无论内存是否充足，只要发生垃圾回收（GC），弱引用指向的对象<strong>都会被回收</strong>（一旦 GC 触发，立即回收）。</p>
<p><strong>场景</strong>：适用于存储「临时关联」的对象，避免内存泄漏。例如：</p>
<ul>
<li><code>ThreadLocal</code>的内部实现中，<code>Entry</code>的 key 使用弱引用，防止线程销毁后 key 无法回收；</li>
<li>缓存中不常用的临时数据，希望 GC 时自动清理。</li>
</ul>
<h3 id="虚引用"><a href="#虚引用" class="headerlink" title="虚引用"></a>虚引用</h3><p>强度最弱的引用，又称「幽灵引用」或「幻影引用」，几乎不影响对象的生命周期。</p>
<ul>
<li>虚引用指向的对象<strong>随时可能被回收</strong>，且无法通过<code>get()</code>方法获取对象（调用<code>get()</code>始终返回<code>null</code>）；</li>
<li>唯一作用是：当对象被回收时，虚引用会被加入到关联的「引用队列」中，用于<strong>跟踪对象的回收状态</strong>。</li>
</ul>
<h2 id="内存泄漏和内存溢出的理解？"><a href="#内存泄漏和内存溢出的理解？" class="headerlink" title="内存泄漏和内存溢出的理解？"></a>内存泄漏和内存溢出的理解？</h2><p>内存泄漏（Memory Leak）和内存溢出（Memory Overflow）是 JVM 内存管理中两个密切相关但本质不同的概念，前者是 “内存浪费” 的渐进过程，后者是 “内存耗尽” 的最终结果，具体区别和联系如下：</p>
<h3 id="一、内存泄漏（Memory-Leak）"><a href="#一、内存泄漏（Memory-Leak）" class="headerlink" title="一、内存泄漏（Memory Leak）"></a>一、内存泄漏（Memory Leak）</h3><p><strong>定义</strong>：程序中已动态分配的内存（通常是堆内存中的对象），由于逻辑错误或设计缺陷，导致其不再被使用时，仍被错误地持有引用，无法被垃圾回收器（GC）回收，从而长期占用内存的现象。</p>
<p>简单说：<strong>“该回收的内存没被回收，变成了‘无效垃圾’占用空间”</strong>。</p>
<h4 id="典型场景："><a href="#典型场景：" class="headerlink" title="典型场景："></a>典型场景：</h4><ol>
<li><p><strong>静态集合未清理</strong>：静态集合（如<code>static List&lt;Object&gt; list</code>）持有对象引用，若只添加不删除，对象会一直被强引用，即使不再使用也无法回收。</p>
</li>
<li><p><strong>监听器 &#x2F; 回调未移除</strong>：注册的监听器（如 GUI 组件的事件监听器、网络连接的回调）若未在对象销毁前注销，会导致监听器关联的对象被长期引用。</p>
</li>
<li><p><strong>ThreadLocal 使用不当</strong>：<code>ThreadLocal</code>的<code>Entry</code>中，key 是弱引用，但 value 是强引用。若线程长期存活（如线程池核心线程），且未调用<code>remove()</code>，value 会被永久持有，导致内存泄漏。</p>
</li>
<li><p><strong>资源未关闭</strong>：数据库连接、文件流、网络 Socket 等资源若未显式关闭，其底层对象（如<code>Connection</code>、<code>InputStream</code>）可能被 JVM 持有引用，无法回收。</p>
</li>
<li><p><strong>缓存未设置过期策略</strong>：缓存（如<code>HashMap</code>实现的本地缓存）若无限存储数据，且没有淘汰机制（如 LRU），会导致旧数据长期占用内存。</p>
</li>
</ol>
<h3 id="二、内存溢出（Memory-Overflow，OOM）"><a href="#二、内存溢出（Memory-Overflow，OOM）" class="headerlink" title="二、内存溢出（Memory Overflow，OOM）"></a>二、内存溢出（Memory Overflow，OOM）</h3><p><strong>定义</strong>：程序在申请内存时，JVM 无法为其分配足够的内存空间（如堆、栈、元空间等区域的剩余内存不足），导致 JVM 抛出<code>OutOfMemoryError</code>的现象。</p>
<p>简单说：<strong>“需要的内存超过了可用内存，申请不到内存了”</strong>。</p>
<h4 id="典型场景：-1"><a href="#典型场景：-1" class="headerlink" title="典型场景："></a>典型场景：</h4><ol>
<li><strong>堆内存溢出</strong>：短时间内创建大量对象（如无限循环<code>new Object()</code>），或内存泄漏累积到一定程度，堆内存被耗尽。</li>
<li><strong>元空间溢出</strong>：动态生成大量类（如 CGLib 代理、Groovy 脚本编译），且类加载器未被回收，元空间（存储类元数据）内存不足。</li>
<li><strong>栈溢出</strong>：方法调用层级过深（如无限递归），栈帧数量超过栈容量，抛出<code>StackOverflowError</code>（本质是栈内存的溢出）。</li>
<li><strong>直接内存溢出</strong>：NIO 的<code>DirectByteBuffer</code>分配过多，超过系统总内存或<code>-XX:MaxDirectMemorySize</code>限制。</li>
</ol>
<h2 id="栈溢出的情况怎么解决"><a href="#栈溢出的情况怎么解决" class="headerlink" title="栈溢出的情况怎么解决"></a>栈溢出的情况怎么解决</h2><p>从触发原因来看，最常见的场景是<strong>无限递归调用</strong>。因为Java方法调用时会在栈中创建栈帧（存储局部变量、操作数栈、方法返回地址等），每递归一次就会新增一个栈帧。如果递归没有正确的终止条件，栈帧会不断累积，最终超过虚拟机栈的最大容量，导致栈溢出。</p>
<p>另一种情况就是说单个方法的栈帧过大。如果一个方法定义了大量局部变量，或者局部变量占用内存过大（比如大数组），单个栈帧就会占用较多栈空间，可能在调用层级不深时就耗尽栈内存。</p>
<p>解决思路:</p>
<p>1.首先排查递归逻辑，查看是否存在无限递归调用或者递归层级过深的问题，添加正确的终止条件，或者减少递归深度。</p>
<p>2.调整栈内存的大小：通过JVM参数<code>-Xss</code>增大栈内存容量。但是这种方式要谨慎，占内存过大会导致线程可创建数量减少。</p>
<p>3.优化方法栈帧：减少方法内局部变量的数量，避免在方法中创建过大的对象和数组，讲过大对象放到堆里面，降低单个栈帧的内存占用。</p>
<h2 id="堆溢出的情况怎么解决"><a href="#堆溢出的情况怎么解决" class="headerlink" title="堆溢出的情况怎么解决"></a>堆溢出的情况怎么解决</h2><p>堆溢出通常发生在程序持续创建对象且无法被垃圾回收器回收的场景下。</p>
<p>1.捕获内存快照：通过JVM参数<code>-XX:+HeapDumpOnOutOfMemoryError</code> <code>-XX:HeapDumpPath=./heapdump.hprof</code>，让程序在发生OOM 时自动生成堆快照文件。</p>
<p>2.使用MAT或JProfiler或者阿里的Arthas等工具分析快照，重点看哪些对象占用了大量内存、是否存在内存泄漏。</p>
<p>常见的解决思路根据原因不同而不同：</p>
<p>如果是内存泄漏：比如静态集合无意识缓存大量对象、长生命周期对象持有短生命周期对象的引用。这时候需要梳理对象的引用链，找到未释放的根源。</p>
<p>如果是内存不足：即程序确实需要大量内存，但当前配置太小可以通过JVM调整参数 ，比如<code>-Xms -Xmx</code></p>
<h2 id="类加载和初始化"><a href="#类加载和初始化" class="headerlink" title="类加载和初始化"></a>类加载和初始化</h2><h3 id="什么是类加载"><a href="#什么是类加载" class="headerlink" title="什么是类加载"></a>什么是类加载</h3><p>类加载就是 JVM 把 <code>.class</code> 文件读进来，解析成 JVM 能理解的数据结构，并在内存中生成一个 <code>Class</code> 对象的过程。</p>
<p>之后：</p>
<ul>
<li>代码通过这个 <code>Class</code> 对象创建实例；</li>
<li>反射、方法调用、字段访问等，都依赖这个类的元信息。</li>
</ul>
<h3 id="类加载器有哪些"><a href="#类加载器有哪些" class="headerlink" title="类加载器有哪些"></a>类加载器有哪些</h3><p>类加载的核心是 <strong>ClassLoader</strong>，即类加载器。它负责根据类的全限定名（如 <code>java.lang.String</code>）找到并加载对应的 <code>.class</code> 文件。</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.xiaolincoding.com//picgo/1719491243997-d62ceba6-2073-41a6-8320-dbe47ce9dbe4.png" alt="img" style="zoom: 33%;" />

<ul>
<li><p>Bootstrap ClassLoader（启动类加载器）</p>
<p>​	这是最顶层的类加载器，他没有父加载器，负责去加载java的核心库，它使用c++编写，是jvm的一部分。启动类加载器无法被java程序直接引用。</p>
</li>
<li><p>Extension ClassLoader（扩展类加载器）</p>
<p>它是java语言实现的，继承自ClassLoader类，负责加载java的扩展库，扩展类加载器由启动类加载器加载</p>
</li>
<li><p>Application ClassLoader（应用类加载器）</p>
<p>默认加载 <strong>classpath</strong> 下的类；</p>
<p>就是我们写的业务代码所在的加载器；</p>
<p>由 <code>sun.misc.Launcher$AppClassLoader</code> 实现。</p>
</li>
<li><p>自定义 ClassLoader</p>
<p>开发者可以继承 <code>ClassLoader</code>，实现 <code>findClass()</code> 方法，<br> 自定义加载规则，比如：</p>
<ul>
<li>从网络加载类；</li>
<li>从数据库或加密文件加载；</li>
<li>热部署（如 Tomcat、Spring Boot DevTools）。</li>
</ul>
</li>
</ul>
<h3 id="Java中双亲委派是什么？有啥用？"><a href="#Java中双亲委派是什么？有啥用？" class="headerlink" title="Java中双亲委派是什么？有啥用？"></a>Java中双亲委派是什么？有啥用？</h3><p><strong>双亲委派机制（Parent Delegation Model）</strong> 是理解 Java 类加载体系的关键之一，它直接关系到类的唯一性、安全性，以及模块隔离。</p>
<p>当一个类加载器要加载某个类时，它不会自己立即动手，而是先把这个请求交给<strong>父加载器</strong>去处理；父加载器再往上层委托，直到到达最顶层的 <strong>Bootstrap ClassLoader</strong>；只有当上层加载器都找不到该类时，当前加载器才会自己去尝试加载。</p>
<p>假设我们调用：<code>Class.forName(&quot;java.lang.String&quot;);</code></p>
<p>加载流程如下：</p>
<ol>
<li>由 <strong>应用类加载器（AppClassLoader）</strong> 接收到加载请求；</li>
<li>它先把请求交给 <strong>扩展类加载器（ExtClassLoader）</strong>；</li>
<li>扩展类加载器又将请求交给 <strong>启动类加载器（Bootstrap ClassLoader）</strong>；</li>
<li>启动类加载器去 <code>rt.jar</code>（或模块）中查找 <code>java.lang.String</code>；</li>
<li>找到了 → 返回 <code>Class</code> 对象；<br> 找不到 → 抛出 <code>ClassNotFoundException</code>，交回给子加载器；</li>
<li>若父加载器都加载失败，子加载器才会尝试自己去加载。</li>
</ol>
<p>作用：</p>
<p>​	保证核心类的安全性，防止用户自定义“假冒”核心类。</p>
<p>​	避免类的重复加载，Java要求同一个类（同名、同包）只能被一个类加载器加载一次。双亲委派确保了同一类只在最顶层被加载一次。</p>
<h3 id="类加载的流程是怎么样的"><a href="#类加载的流程是怎么样的" class="headerlink" title="类加载的流程是怎么样的"></a>类加载的流程是怎么样的</h3><p>在 JVM 规范中，<strong>类加载（Class Loading）</strong> 包含以下 3 个大阶段（共 5 个具体步骤）：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">加载（Loading）</span><br><span class="line">→ 链接（Linking）</span><br><span class="line">    → 验证（Verification）</span><br><span class="line">    → 准备（Preparation）</span><br><span class="line">    → 解析（Resolution）</span><br><span class="line">→ 初始化（Initialization）</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="加载："><a href="#加载：" class="headerlink" title="加载："></a><strong>加载</strong>：</h4><p>通过类的全限定名（包名+类名），获取到该类的.class文件的二进制字节流，将二进制字节流所代表的静态存储结构，转化为方法区运行时的数据结构，在内存中生成一个代表该类的Java.lang.Class对象，作为方法区这个类的各种数据的访问入口</p>
<h4 id="链接（Linking）"><a href="#链接（Linking）" class="headerlink" title="链接（Linking）"></a>链接（Linking）</h4><p>链接就是 JVM 把类加载进来后，<strong>让它变成一个可执行的类</strong>。</p>
<h5 id="验证（Verification）"><a href="#验证（Verification）" class="headerlink" title="验证（Verification）"></a>验证（Verification）</h5><p>确保类文件安全合法，不会破坏虚拟机。</p>
<p>验证的 4 个层面：</p>
<ul>
<li><strong>文件格式验证</strong>：检查魔数（0xCAFEBABE）、版本号。</li>
<li><strong>元数据验证</strong>：比如类的父类是否存在、是否继承 final 类。</li>
<li><strong>字节码验证</strong>：指令流是否合法（不会越界、栈深度正确）。</li>
<li><strong>符号引用验证</strong>：常量池中的符号引用是否合法。</li>
</ul>
<p>这是安全防线，防止恶意字节码攻击 JVM。</p>
<h5 id="准备（Preparation）"><a href="#准备（Preparation）" class="headerlink" title="准备（Preparation）"></a>准备（Preparation）</h5><p>为类的<strong>静态变量（类变量）</strong>分配内存，并赋默认值（不是初始化值）。</p>
<h5 id="解析（Resolution）"><a href="#解析（Resolution）" class="headerlink" title="解析（Resolution）"></a>解析（Resolution）</h5><p>把常量池中的“符号引用”替换成“直接引用”。</p>
<p>解析阶段：</p>
<ul>
<li>JVM 把这些字符串（符号）解析成指针（内存地址），指向实际的方法或字段。</li>
<li>有点像“从名字查地址”的过程。</li>
</ul>
<p>解析可在运行时延迟进行（称为懒解析）。</p>
<h4 id="初始化（Initialization）"><a href="#初始化（Initialization）" class="headerlink" title="初始化（Initialization）"></a>初始化（Initialization）</h4><p>真正执行类中的<strong>初始化逻辑</strong>（静态代码）</p>
<p>初始化的触发条件：</p>
<ol>
<li>使用 <code>new</code> 创建类实例；</li>
<li>调用类的静态方法；</li>
<li>访问类的静态变量；</li>
<li>反射调用；</li>
<li>子类初始化时父类先初始化；</li>
<li>含有 <code>main()</code> 方法的类。</li>
</ol>
<p>执行内容：</p>
<ol>
<li>执行静态变量的赋值语句；</li>
<li>执行静态代码块（<code>static &#123;&#125;</code>）；</li>
<li>顺序遵循<strong>代码出现顺序</strong>；</li>
<li>父类先于子类初始化。</li>
</ol>
<h3 id="对象的创建过程"><a href="#对象的创建过程" class="headerlink" title="对象的创建过程"></a>对象的创建过程</h3><p>类加载完毕后，就可以实例化对象。以 <code>Person p = new Person();</code> 为例，JVM 做了以下几步。</p>
<ol>
<li><p>检查类是否已经加载</p>
<p>如果 <code>Person</code> 类未被加载或初始化，会先触发上面的类加载流程。</p>
</li>
<li><p>分配内存（在堆中）</p>
<p>JVM 在 <strong>堆（Heap）</strong> 中为新对象分配所需的内存空间。大小取决于类中实例变量的数量与类型。</p>
</li>
<li><p>内存初始化（零值）</p>
<p>分配到的内存先清零，确保对象的字段都有默认值：</p>
<ul>
<li>数值型：0；</li>
<li>布尔型：false；</li>
<li>引用型：null。</li>
</ul>
<p>此时对象结构已确定，但还未执行任何构造代码。</p>
</li>
<li><p>设置对象头（Object Header）</p>
<p>JVM 在对象头中写入一些重要信息：</p>
<ul>
<li>类的元数据指针（即指向 <code>Class</code> 对象）；</li>
<li>GC 标志、哈希码；</li>
<li>锁状态（偏向锁、轻量级锁等）。</li>
</ul>
<p>这部分决定了对象能被识别、锁定、垃圾回收。</p>
</li>
<li><p>执行 <code>&lt;init&gt;</code> 构造函数</p>
<p>这一步是真正初始化对象逻辑的地方。</p>
<p>顺序如下：</p>
<ol>
<li>调用父类构造函数；</li>
<li>按声明顺序给实例字段赋初始值；</li>
<li>执行子类构造函数体。</li>
</ol>
<p>生成的字节码会调用 <code>&lt;init&gt;</code> 方法（特殊方法名）。</p>
</li>
<li><p>返回对象引用</p>
<p>构造完成后，返回堆中对象的引用（句柄或直接指针），保存在栈帧的局部变量表中。</p>
</li>
</ol>
<h2 id="JVM的垃圾回收机制"><a href="#JVM的垃圾回收机制" class="headerlink" title="JVM的垃圾回收机制"></a>JVM的垃圾回收机制</h2><h3 id="什么是垃圾回收（GC）？如何触发垃圾回收？"><a href="#什么是垃圾回收（GC）？如何触发垃圾回收？" class="headerlink" title="什么是垃圾回收（GC）？如何触发垃圾回收？"></a>什么是垃圾回收（GC）？如何触发垃圾回收？</h3><p>GC（Garbage Collection，垃圾回收）是自动管理程序 内存的机制，它帮助程序员自动释放那些不再被程序所 使用的内存对象，从而避免内存泄漏等问题。</p>
<p><strong>内存不足时</strong>：当JVM检测到堆内存不足，无法为新的对象分配内存时，就会触发垃圾回收</p>
<p><strong>手动请求</strong>:虽然垃圾回收是自动的，开发者可以通过调用<code>system.gc()</code>或<code>Runtime.getRuntime.gd()</code>建议JVM进行垃圾回收</p>
<p><strong>JVM参数</strong>：启动java应用时可以通过JVM参数来调整垃圾回收的行为，比如<code>-Xmx</code>(最大堆大小)、<code>-Xms</code>(初始堆大小)</p>
<p><strong>对象数量或者内存使用达到阈值：</strong>垃圾收集器内部实现了一些策略，以监控对象的创建和内存使用，达到某个阈值时触发</p>
<p>JVM 采用<strong>分代回收机制</strong>：不同代用不同策略，提高效率。于是就有了 Minor GC、Major GC、Full GC。</p>
<h4 id="1-Minor-GC（轻量级回收）"><a href="#1-Minor-GC（轻量级回收）" class="headerlink" title="1. Minor GC（轻量级回收）"></a>1. Minor GC（轻量级回收）</h4><ul>
<li>目标：<strong>清理新生代</strong></li>
<li>Eden 区的对象大多是“短命对象”。</li>
<li>GC 时，幸存的对象从 Eden → Survivor。</li>
<li>若多次 Minor GC 仍存活，则晋升到老年代。</li>
<li>成本：停顿时间短，频率高。</li>
</ul>
<p><strong>触发时机：</strong></p>
<blockquote>
<p>Eden 区空间不足时自动触发。</p>
</blockquote>
<hr>
<h4 id="2-Major-GC（老年代回收）"><a href="#2-Major-GC（老年代回收）" class="headerlink" title="2. Major GC（老年代回收）"></a>2. Major GC（老年代回收）</h4><ul>
<li>目标：<strong>清理老年代</strong></li>
<li>老年代的对象多为“长期存活”或“晋升对象”。</li>
<li>使用“标记-清除”或“标记-整理”算法，效率低。</li>
<li>停顿时间明显长于 Minor GC。</li>
</ul>
<p><strong>触发时机：</strong></p>
<blockquote>
<p>老年代空间不足（无法存放新晋升对象）时触发。</p>
</blockquote>
<hr>
<h4 id="3-Full-GC（全量回收）"><a href="#3-Full-GC（全量回收）" class="headerlink" title="3. Full GC（全量回收）"></a>3. Full GC（全量回收）</h4><ul>
<li>目标：<strong>回收整个堆 + 元空间</strong></li>
<li>代价极高，Stop-The-World，应用线程全部暂停。</li>
<li>通常是“无路可退”的最后手段。</li>
</ul>
<h3 id="判断垃圾的方法有哪些？"><a href="#判断垃圾的方法有哪些？" class="headerlink" title="判断垃圾的方法有哪些？"></a>判断垃圾的方法有哪些？</h3><p>在Java中，判断对象是否为垃圾（即不再被使用，可以被垃圾回收器回收）主要依据两种主流的垃圾回收算法来实现：引用计数法和可达性分析算法。</p>
<p><strong>引用计数法</strong>（Reference Counting）：</p>
<p>原理：为每个对象分配一个引用计数器，每当有一个地方引用它时，计数器加1；当引用失效时，计数器减1。当计数器为0时，表示对象不再被任何变量引用，可以被回收。<br>缺点：不能解决循环引用的问题，即两个对象相互引用，但不再被其他任何对象引用，这时引用计数器不会为0，导致对象无法被回收。</p>
<p><strong>可达性分析算法</strong>（Reachability Analysis）：</p>
<p>原理：从一组称为GCRoOts（垃圾收集根）的对象出发，向下追溯它们引用的对象，以及这些对象引用的其他对象，以此类推。如果一个对象到GCRoots没有任何引用链相连（即从GCRoots到这个对象不可达），那么这个对象就被认为是不可达的，可以被回收。GCRoots对象包括：虚拟机栈（栈帧中的本地变量表）中引用的对象、方法区中类静态属性引用的对象、本地方法栈中JNI（JavaNative<br>Interface）引用的对象、活跃线程的引用等。</p>
<p>GC Root 是什么：</p>
<p> GC Root 是 <strong>Java 垃圾回收（Garbage Collection, GC）中判断对象是否“存活”</strong> 的起点。<br> 在 JVM 中，垃圾回收并不是简单地扫描所有对象，而是从一组特定的“根对象”出发，沿着引用链（Reference Chain）去搜索。<br> 如果一个对象能被这些根对象直接或间接引用到，就认为它<strong>是可达的（reachable）</strong>，因此不会被回收。</p>
<p>VM 中能作为 GC Root 的对象主要包括以下几类：</p>
<ol>
<li><strong>虚拟机栈（栈帧中的局部变量表）中的引用对象</strong><ul>
<li>比如方法中定义的局部变量、方法参数、临时对象引用。</li>
<li>当线程执行到某个方法时，这个方法栈帧里的变量就是活跃的。</li>
</ul>
</li>
<li><strong>方法区中类静态属性引用的对象</strong><ul>
<li>比如 <code>static</code> 修饰的成员变量引用的对象。</li>
<li>静态变量属于类而非实例，因此始终存在于 JVM 生命周期内。</li>
</ul>
</li>
<li><strong>方法区中常量引用的对象</strong><ul>
<li>比如字符串常量池中的对象：<code>String s = &quot;abc&quot;;</code></li>
<li><code>&quot;abc&quot;</code> 是在方法区中常量池引用的对象。</li>
</ul>
</li>
<li><strong>本地方法栈中 JNI（Native 方法）引用的对象</strong><ul>
<li>即通过 native 方法调用的本地代码中使用到的对象引用。</li>
<li>JNI 全称是 Java Native Interface。</li>
</ul>
</li>
<li><strong>正在被同步锁（synchronized）持有的对象</strong><ul>
<li>比如正在被锁住的对象 <code>synchronized(lock)</code> 中的 <code>lock</code>。</li>
<li>JVM 会认为它仍然“被使用”，因此不能被 GC。</li>
</ul>
</li>
<li><strong>JVM 自身持有的系统类加载器等特殊引用</strong><ul>
<li>比如类加载器（ClassLoader）、线程对象（Thread）、异常对象等。</li>
<li>这些对象是 JVM 自身运行所需的，不会轻易被 GC。</li>
</ul>
</li>
</ol>
<h3 id="垃圾回收器"><a href="#垃圾回收器" class="headerlink" title="垃圾回收器"></a>垃圾回收器</h3><p>Serial 单线程；Parallel 求吞吐；CMS 追响应；G1 智能平衡；ZGC、Shenandoah 超低延迟。</p>
<ul>
<li>Serial收集器（复制算法):新生代单线程收集器，标记和清理都是单线程，优点是简单高效；</li>
<li>ParNew收集器（复制算法)：新生代收并行集器，实际上是Serial收集器的多线程版本，在多核CPU环境下有着比Serial更好的表现；</li>
<li>ParallelScavenge收集器（复制算法):新生代并行收集器，追求高吞吐量，高效利用CPU。吞吐量&#x3D;用户线程时间&#x2F;(用户线程时间+GC线程时间），高吞吐量可以高效率的利用CPU时间，尽快完成程序的运算任务，适合后台应用等对交互相应要求不高的场景；</li>
<li>SerialOld收集器（标记-整理算法)：老年代单线程收集器，Serial收集器的老年代版本；</li>
<li>ParallelOld收集器（标记-整理算法)：老年代并行收集器，吞吐量优先，ParallelScavenge收集器的老年代版本；</li>
<li>CMS(ConcurrentMarkSweep)收集器（标记-清除算法）：老年代并行收集器，以获取最短回收停顿时间为目标的收集器，具有高并发、低停顿的特点，追求最短GC回收停顿时间。</li>
<li>G1(GarbageFirst)收集器（标记-整理算法)：Java堆并行收集器，G1收集器是JDK1.7提供的一个新收集器，G1收集器基于“标记-整理”算法实现，也就是说不会产生内存碎片。此外，G1收集器不同于之前的收集器的一个重要特点是：G1回收的范围是整个Java堆（包括新生代，老年代），而前六种收集器回收的范围仅限于新生代或老年代</li>
</ul>
<h2 id="JVM垃圾回收算法"><a href="#JVM垃圾回收算法" class="headerlink" title="JVM垃圾回收算法"></a>JVM垃圾回收算法</h2><p>自动识别不再被引用的对象，并安全高效地释放内存。</p>
<p>它是“怎么识别垃圾、怎么清理垃圾、怎么移动对象”的一系列策略。</p>
<table>
<thead>
<tr>
<th>算法名称</th>
<th>核心思想</th>
<th>优点</th>
<th>缺点</th>
<th>典型应用</th>
</tr>
</thead>
<tbody><tr>
<td><strong>1️⃣ 标记-清除（Mark-Sweep）</strong></td>
<td>分两步：先标记所有存活对象，再清除未标记的</td>
<td>简单、无需移动对象</td>
<td>产生内存碎片，分配新对象效率低</td>
<td>老年代（Serial Old、Parallel Old）</td>
</tr>
<tr>
<td><strong>2️⃣ 复制算法（Copying）</strong></td>
<td>把活对象复制到另一块空闲区域，再清空原区域</td>
<td>无碎片，分配快</td>
<td>浪费一半内存空间</td>
<td>新生代（Minor GC）</td>
</tr>
<tr>
<td><strong>3️⃣ 标记-整理（Mark-Compact）</strong></td>
<td>标记存活对象后，将它们移动到堆的一端，再清除其他区域</td>
<td>无碎片、空间连续</td>
<td>需要对象移动，成本高</td>
<td>老年代（Serial Old、CMS Compact 阶段）</td>
</tr>
<tr>
<td><strong>4️⃣ 分代收集（Generational Collection）</strong></td>
<td>新生代用复制算法、老年代用标记整理</td>
<td>综合效率高</td>
<td>实现复杂</td>
<td>几乎所有现代 JVM（HotSpot 默认策略）</td>
</tr>
<tr>
<td><strong>5️⃣ 区域化收集（Region-based，如 G1&#x2F;ZGC）</strong></td>
<td>把堆划分为许多 Region，每个 Region 独立回收</td>
<td>并行、可预测停顿时间</td>
<td>实现复杂，元数据管理成本高</td>
<td>G1、ZGC、Shenandoah</td>
</tr>
</tbody></table>
<h2 id="JVM调优"><a href="#JVM调优" class="headerlink" title="JVM调优"></a>JVM调优</h2><h3 id="JVM-调优的目的"><a href="#JVM-调优的目的" class="headerlink" title="JVM 调优的目的"></a>JVM 调优的目的</h3><ol>
<li><strong>减少 GC 停顿时间</strong>（Stop The World）<ul>
<li>避免频繁 Full GC，降低对系统吞吐的影响。</li>
</ul>
</li>
<li><strong>提升吞吐量</strong><ul>
<li>比如大数据处理、高并发接口，目标是 CPU 绝大部分时间都在跑业务逻辑，而不是收垃圾。</li>
</ul>
</li>
<li><strong>防止内存溢出（OOM）或内存泄漏</strong><ul>
<li>程序在运行一段时间后稳定且不崩溃。</li>
</ul>
</li>
</ol>
<h3 id="如何定位问题"><a href="#如何定位问题" class="headerlink" title="如何定位问题"></a>如何定位问题</h3><p>常见的性能问题的类型：</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>典型表现</th>
<th>解决方向</th>
</tr>
</thead>
<tbody><tr>
<td>Full GC 频繁</td>
<td>吞吐量下降、系统卡顿</td>
<td>优化 GC 参数或对象生命周期</td>
</tr>
<tr>
<td>内存溢出 (OOM)</td>
<td>系统崩溃或接口 500</td>
<td>排查内存泄漏</td>
</tr>
<tr>
<td>响应慢</td>
<td>停顿时间长</td>
<td>优化 GC 算法或堆结构</td>
</tr>
<tr>
<td>CPU 飙高</td>
<td>GC 线程占用过多</td>
<td>减少对象创建或调整线程并发</td>
</tr>
</tbody></table>
<p>可用的诊断工具：</p>
<ul>
<li><code>jstat</code>：监控 GC 次数与时间。</li>
<li><code>jmap</code> &#x2F; <code>jhat</code>：生成堆转储分析。</li>
<li><code>jconsole</code> &#x2F; <code>VisualVM</code>：实时监控堆、线程、类加载。</li>
<li><code>arthas</code>：阿里开源神器，定位卡顿或内存泄漏。</li>
</ul>
<h3 id="JVM可调参数"><a href="#JVM可调参数" class="headerlink" title="JVM可调参数"></a>JVM可调参数</h3><table>
<thead>
<tr>
<th>参数</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td><code>-Xms</code> &#x2F; <code>-Xmx</code></td>
<td>初始堆大小 &#x2F; 最大堆大小</td>
</tr>
<tr>
<td><code>-Xmn</code></td>
<td>新生代大小</td>
</tr>
<tr>
<td><code>-XX:SurvivorRatio</code></td>
<td>Eden 与 Survivor 比例（默认 8:1:1）</td>
</tr>
<tr>
<td><code>-XX:NewRatio</code></td>
<td>新生代与老年代比例</td>
</tr>
<tr>
<td><code>-XX:+UseConcMarkSweepGC</code></td>
<td>使用 CMS 垃圾回收器（JDK8 常用）</td>
</tr>
<tr>
<td><code>-XX:+UseG1GC</code></td>
<td>使用 G1 垃圾回收器（JDK11 推荐）</td>
</tr>
<tr>
<td><code>-XX:MaxGCPauseMillis</code></td>
<td>目标最大停顿时间</td>
</tr>
<tr>
<td><code>-XX:GCTimeRatio</code></td>
<td>吞吐量目标（GC 时间与非 GC 时间比）</td>
</tr>
<tr>
<td><code>-XX:+PrintGCDetails</code></td>
<td>输出 GC 详细日志</td>
</tr>
<tr>
<td><code>-Xloggc:/path/gc.log</code></td>
<td>GC 日志路径</td>
</tr>
</tbody></table>
</article><div class="post-copyright"><div class="copyright-cc-box"><i class="anzhiyufont anzhiyu-icon-copyright"></i></div><div class="post-copyright__author_box"><a class="post-copyright__author_img" href="/" title="头像"><img class="post-copyright__author_img_back" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://s2.loli.net/2022/11/07/QVWvrnAsuGxelbS.jpg" title="头像" alt="头像"><img class="post-copyright__author_img_front" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://s2.loli.net/2022/11/07/QVWvrnAsuGxelbS.jpg" title="头像" alt="头像"></a><div class="post-copyright__author_name">北川</div><div class="post-copyright__author_desc">Believe in yourself</div></div><div class="post-copyright__post__info"><a class="post-copyright__original" title="该文章为原创文章，注意版权协议" href="https://gukeyang.github.io/posts/66c016fb.html">原创</a><a class="post-copyright-title"><span onclick="rm.copyPageUrl('https://gukeyang.github.io/posts/66c016fb.html')">JVM</span></a></div><div class="post-tools" id="post-tools"><div class="post-tools-left"><div class="rewardLeftButton"><div class="post-reward" onclick="anzhiyu.addRewardMask()"><div class="reward-button button--animated" title="赞赏作者"><i class="anzhiyufont anzhiyu-icon-hand-heart-fill"></i>打赏作者</div><div class="reward-main"><div class="reward-all"><span class="reward-title">感谢你赐予我前进的力量</span><ul class="reward-group"><li class="reward-item"><a href="/./img/wechat.jpg" target="_blank"><img class="post-qr-code-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/./img/wechat.jpg" alt="微信"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="/./img/alipay.jpg" target="_blank"><img class="post-qr-code-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/./img/alipay.jpg" alt="支付宝"/></a><div class="post-qr-code-desc">支付宝</div></li></ul><a class="reward-main-btn" href="/about/#about-reward" target="_blank"><div class="reward-text">赞赏者名单</div><div class="reward-dec">因为你们的支持让我意识到写文章的价值🙏</div></a></div></div></div><div id="quit-box" onclick="anzhiyu.removeRewardMask()" style="display: none"></div><div class="reward-link mode"><a class="reward-link-button" href="/wecaht/"><i class="anzhiyufont anzhiyu-icon-plant-fill"></i>运营模式与责任</a></div></div><div class="shareRight"><div class="share-link mobile"><div class="share-qrcode"><div class="share-button" title="使用手机访问这篇文章"><i class="anzhiyufont anzhiyu-icon-qrcode"></i></div><div class="share-main"><div class="share-main-all"><div id="qrcode" title="https://gukeyang.github.io/posts/66c016fb.html"></div><div class="reward-dec">使用手机访问这篇文章</div></div></div></div></div><div class="share-link weibo"><a class="share-button" target="_blank" href="https://service.weibo.com/share/share.php?title=JVM&amp;url=https://gukeyang.github.io/posts/66c016fb.html&amp;pic=https://s2.loli.net/2025/10/23/w3ErpsQhncfDed2.jpg?_r_=073fb3c1-1ed6-85dc-4b49-6bade417019f" rel="external nofollow noreferrer noopener"><i class="anzhiyufont anzhiyu-icon-weibo"></i></a></div><div class="share-link copyurl"><div class="share-button" id="post-share-url" title="复制链接" onclick="rm.copyPageUrl()"><i class="anzhiyufont anzhiyu-icon-link"></i></div></div></div></div></div><div class="post-copyright__notice"><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://gukeyang.github.io" target="_blank">北川的个人博客</a>！</span></div></div><div class="post-tools-right"><div class="tag_share"><div class="post-meta__box"><div class="post-meta__box__tag-list"><a class="post-meta__box__tags" href="/tags/JVM%E8%B0%83%E4%BC%98/"><span class="tags-punctuation"> <i class="anzhiyufont anzhiyu-icon-tag"></i></span>JVM调优<span class="tagsPageCount">1</span></a><a class="post-meta__box__tags" href="/tags/JVM%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/"><span class="tags-punctuation"> <i class="anzhiyufont anzhiyu-icon-tag"></i></span>JVM内存模型<span class="tagsPageCount">1</span></a></div></div></div><div class="post_share"><div class="social-share" data-image="https://s2.loli.net/2025/10/23/wfbr2eNcL1VvXIn.png?_r_=c8b8c4d9-3b05-f070-2b01-ec5fb5e468d4" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.cbd.int/butterfly-extsrc@1.1.3/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"/><script src="https://cdn.cbd.int/butterfly-extsrc@1.1.3/sharejs/dist/js/social-share.min.js" defer="defer"></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/posts/498cfd8e.html"><img class="prev-cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://s2.loli.net/2025/10/23/w3ErpsQhncfDed2.jpg?_r_=e93610d2-afe5-62c9-ffac-34bc6ede57ce" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">并发编程</div></div></a></div><div class="next-post pull-right"><a href="/posts/c45230cb.html"><img class="next-cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://s2.loli.net/2025/10/23/wfbr2eNcL1VvXIn.png?_r_=c8b8c4d9-3b05-f070-2b01-ec5fb5e468d4" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">mysql面试题</div></div></a></div></nav><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="anzhiyufont anzhiyu-icon-comments"></i><span> 评论</span></div><div class="comment-randomInfo"><a onclick="anzhiyu.addRandomCommentInfo()" href="javascript:void(0)">匿名评论</a><a href="/privacy" style="margin-left: 4px">隐私政策</a></div></div><div class="comment-wrap"><div><div class="vcomment" id="vcomment"></div></div></div></div><div class="comment-barrage"></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="card-content"><div class="author-info__sayhi" id="author-info__sayhi" onclick="anzhiyu.changeSayHelloText()"></div><div class="author-info-avatar"><img class="avatar-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://s2.loli.net/2022/11/07/QVWvrnAsuGxelbS.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/><div class="author-status"><img class="g-status" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/zc998800/cdn/face/gif/m17.gif" ait="status"/></div></div><div class="author-info__description">路慢其修远兮 吾将上下而求索</div><div class="author-info__bottom-group"><a class="author-info__bottom-group-left" href="/"><h1 class="author-info__name">北川</h1><div class="author-info__desc">Believe in yourself</div></a><div class="card-info-social-icons is-center"><a class="social-icon faa-parent animated-hover" href="https://github.com/gukeyang" target="_blank" title="Github"><i class="anzhiyufont anzhiyu-icon-github"></i></a><a class="social-icon faa-parent animated-hover" href="https://space.bilibili.com/1542898061" target="_blank" title="BiliBili"><i class="anzhiyufont anzhiyu-icon-bilibili"></i></a></div></div></div></div><div class="card-widget anzhiyu-right-widget" id="card-wechat" onclick="null"><div id="flip-wrapper"><div id="flip-content"><div class="face" style="background: url(https://bu.dusays.com/2023/01/13/63c02edf44033.png) center center / 100% no-repeat"></div><div class="back face" style="background: url(https://s2.loli.net/2023/10/19/vNio4QGBSX9x5lO.png) center center / 100% no-repeat"></div></div></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-bars"></i><span>文章目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#JVM%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-number">1.</span> <span class="toc-text">JVM是什么</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JVM%E7%9A%84%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84"><span class="toc-number">2.</span> <span class="toc-text">JVM的内存结构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A8%8B%E5%BA%8F%E8%AE%A1%E6%95%B0%E5%99%A8"><span class="toc-number">2.1.</span> <span class="toc-text">程序计数器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Java-%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88%EF%BC%88Java-%E6%A0%88%EF%BC%89"><span class="toc-number">2.2.</span> <span class="toc-text">Java 虚拟机栈（Java 栈）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%AC%E5%9C%B0%E6%96%B9%E6%B3%95%E6%A0%88%EF%BC%88C-%E6%A0%88%EF%BC%89"><span class="toc-number">2.3.</span> <span class="toc-text">本地方法栈（C 栈）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A0%86"><span class="toc-number">2.4.</span> <span class="toc-text">堆</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E5%8C%BA"><span class="toc-number">2.5.</span> <span class="toc-text">方法区</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9B%B4%E6%8E%A5%E5%86%85%E5%AD%98"><span class="toc-number">2.6.</span> <span class="toc-text">直接内存</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JVM%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E9%87%8C%E7%9A%84%E5%A0%86%E5%92%8C%E6%A0%88%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB"><span class="toc-number">3.</span> <span class="toc-text">JVM内存模型里的堆和栈有什么区别</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E7%BA%BF%E7%A8%8B%E5%85%B1%E4%BA%AB%E6%80%A7"><span class="toc-number">3.1.</span> <span class="toc-text">1. 线程共享性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%AD%98%E5%82%A8%E5%86%85%E5%AE%B9"><span class="toc-number">3.2.</span> <span class="toc-text">2. 存储内容</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="toc-number">3.3.</span> <span class="toc-text">3. 生命周期</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E5%A4%A7%E5%B0%8F%E4%B8%8E%E8%B0%83%E6%95%B4"><span class="toc-number">3.4.</span> <span class="toc-text">4. 大小与调整</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6"><span class="toc-number">3.5.</span> <span class="toc-text">5. 垃圾回收</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-%E5%BC%82%E5%B8%B8%E7%B1%BB%E5%9E%8B"><span class="toc-number">3.6.</span> <span class="toc-text">6. 异常类型</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A0%86%E5%88%86%E4%B8%BA%E5%93%AA%E5%87%A0%E4%B8%AA%E9%83%A8%E5%88%86"><span class="toc-number">4.</span> <span class="toc-text">堆分为哪几个部分</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%A7%E5%AF%B9%E8%B1%A1%E4%B8%80%E8%88%AC%E5%AD%98%E5%82%A8%E5%9C%A8%E5%93%AA%E4%B8%AA%E5%8C%BA%E5%9F%9F"><span class="toc-number">5.</span> <span class="toc-text">大对象一般存储在哪个区域</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#String-s-new-String%EF%BC%88%E2%80%9Cabc%E2%80%9D%EF%BC%89%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B%E4%B8%AD%E5%88%86%E5%88%AB%E5%AF%B9%E5%BA%94%E5%93%AA%E4%BA%9B%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F%EF%BC%9F"><span class="toc-number">6.</span> <span class="toc-text">String s &#x3D; new String（“abc”）执行过程中分别对应哪些内存区域？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B%E6%9C%89%E5%93%AA%E4%BA%9B"><span class="toc-number">7.</span> <span class="toc-text">引用类型有哪些</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%BA%E5%BC%95%E7%94%A8"><span class="toc-number">7.1.</span> <span class="toc-text">强引用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%B1%E5%BC%95%E7%94%A8"><span class="toc-number">7.2.</span> <span class="toc-text">弱引用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BD%AF%E5%BC%95%E7%94%A8"><span class="toc-number">7.3.</span> <span class="toc-text">软引用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%99%9A%E5%BC%95%E7%94%A8"><span class="toc-number">7.4.</span> <span class="toc-text">虚引用</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E5%92%8C%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA%E7%9A%84%E7%90%86%E8%A7%A3%EF%BC%9F"><span class="toc-number">8.</span> <span class="toc-text">内存泄漏和内存溢出的理解？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%EF%BC%88Memory-Leak%EF%BC%89"><span class="toc-number">8.1.</span> <span class="toc-text">一、内存泄漏（Memory Leak）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B8%E5%9E%8B%E5%9C%BA%E6%99%AF%EF%BC%9A"><span class="toc-number">8.1.1.</span> <span class="toc-text">典型场景：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E3%80%81%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA%EF%BC%88Memory-Overflow%EF%BC%8COOM%EF%BC%89"><span class="toc-number">8.2.</span> <span class="toc-text">二、内存溢出（Memory Overflow，OOM）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B8%E5%9E%8B%E5%9C%BA%E6%99%AF%EF%BC%9A-1"><span class="toc-number">8.2.1.</span> <span class="toc-text">典型场景：</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%88%E6%BA%A2%E5%87%BA%E7%9A%84%E6%83%85%E5%86%B5%E6%80%8E%E4%B9%88%E8%A7%A3%E5%86%B3"><span class="toc-number">9.</span> <span class="toc-text">栈溢出的情况怎么解决</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A0%86%E6%BA%A2%E5%87%BA%E7%9A%84%E6%83%85%E5%86%B5%E6%80%8E%E4%B9%88%E8%A7%A3%E5%86%B3"><span class="toc-number">10.</span> <span class="toc-text">堆溢出的情况怎么解决</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%92%8C%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-number">11.</span> <span class="toc-text">类加载和初始化</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E7%B1%BB%E5%8A%A0%E8%BD%BD"><span class="toc-number">11.1.</span> <span class="toc-text">什么是类加载</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E6%9C%89%E5%93%AA%E4%BA%9B"><span class="toc-number">11.2.</span> <span class="toc-text">类加载器有哪些</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Java%E4%B8%AD%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%E6%9C%89%E5%95%A5%E7%94%A8%EF%BC%9F"><span class="toc-number">11.3.</span> <span class="toc-text">Java中双亲委派是什么？有啥用？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E5%8A%A0%E8%BD%BD%E7%9A%84%E6%B5%81%E7%A8%8B%E6%98%AF%E6%80%8E%E4%B9%88%E6%A0%B7%E7%9A%84"><span class="toc-number">11.4.</span> <span class="toc-text">类加载的流程是怎么样的</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8A%A0%E8%BD%BD%EF%BC%9A"><span class="toc-number">11.4.1.</span> <span class="toc-text">加载：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%93%BE%E6%8E%A5%EF%BC%88Linking%EF%BC%89"><span class="toc-number">11.4.2.</span> <span class="toc-text">链接（Linking）</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%AA%8C%E8%AF%81%EF%BC%88Verification%EF%BC%89"><span class="toc-number">11.4.2.1.</span> <span class="toc-text">验证（Verification）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%87%86%E5%A4%87%EF%BC%88Preparation%EF%BC%89"><span class="toc-number">11.4.2.2.</span> <span class="toc-text">准备（Preparation）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%A7%A3%E6%9E%90%EF%BC%88Resolution%EF%BC%89"><span class="toc-number">11.4.2.3.</span> <span class="toc-text">解析（Resolution）</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96%EF%BC%88Initialization%EF%BC%89"><span class="toc-number">11.4.3.</span> <span class="toc-text">初始化（Initialization）</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%88%9B%E5%BB%BA%E8%BF%87%E7%A8%8B"><span class="toc-number">11.5.</span> <span class="toc-text">对象的创建过程</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JVM%E7%9A%84%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6"><span class="toc-number">12.</span> <span class="toc-text">JVM的垃圾回收机制</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%EF%BC%88GC%EF%BC%89%EF%BC%9F%E5%A6%82%E4%BD%95%E8%A7%A6%E5%8F%91%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%EF%BC%9F"><span class="toc-number">12.1.</span> <span class="toc-text">什么是垃圾回收（GC）？如何触发垃圾回收？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-Minor-GC%EF%BC%88%E8%BD%BB%E9%87%8F%E7%BA%A7%E5%9B%9E%E6%94%B6%EF%BC%89"><span class="toc-number">12.1.1.</span> <span class="toc-text">1. Minor GC（轻量级回收）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-Major-GC%EF%BC%88%E8%80%81%E5%B9%B4%E4%BB%A3%E5%9B%9E%E6%94%B6%EF%BC%89"><span class="toc-number">12.1.2.</span> <span class="toc-text">2. Major GC（老年代回收）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-Full-GC%EF%BC%88%E5%85%A8%E9%87%8F%E5%9B%9E%E6%94%B6%EF%BC%89"><span class="toc-number">12.1.3.</span> <span class="toc-text">3. Full GC（全量回收）</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%A4%E6%96%AD%E5%9E%83%E5%9C%BE%E7%9A%84%E6%96%B9%E6%B3%95%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="toc-number">12.2.</span> <span class="toc-text">判断垃圾的方法有哪些？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8"><span class="toc-number">12.3.</span> <span class="toc-text">垃圾回收器</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JVM%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95"><span class="toc-number">13.</span> <span class="toc-text">JVM垃圾回收算法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JVM%E8%B0%83%E4%BC%98"><span class="toc-number">14.</span> <span class="toc-text">JVM调优</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#JVM-%E8%B0%83%E4%BC%98%E7%9A%84%E7%9B%AE%E7%9A%84"><span class="toc-number">14.1.</span> <span class="toc-text">JVM 调优的目的</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%AE%9A%E4%BD%8D%E9%97%AE%E9%A2%98"><span class="toc-number">14.2.</span> <span class="toc-text">如何定位问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#JVM%E5%8F%AF%E8%B0%83%E5%8F%82%E6%95%B0"><span class="toc-number">14.3.</span> <span class="toc-text">JVM可调参数</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-history"></i><span>最近发布</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/posts/c45230cb.html" title="mysql面试题"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://s2.loli.net/2025/10/23/wfbr2eNcL1VvXIn.png?_r_=c8b8c4d9-3b05-f070-2b01-ec5fb5e468d4" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="mysql面试题"/></a><div class="content"><a class="title" href="/posts/c45230cb.html" title="mysql面试题">mysql面试题</a><time datetime="2025-10-27T03:31:36.000Z" title="发表于 2025-10-27 11:31:36">2025-10-27</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/66c016fb.html" title="JVM"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://s2.loli.net/2025/10/23/w3ErpsQhncfDed2.jpg?_r_=073fb3c1-1ed6-85dc-4b49-6bade417019f" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="JVM"/></a><div class="content"><a class="title" href="/posts/66c016fb.html" title="JVM">JVM</a><time datetime="2025-10-24T15:31:36.000Z" title="发表于 2025-10-24 23:31:36">2025-10-24</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/498cfd8e.html" title="并发编程"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://s2.loli.net/2025/10/23/w3ErpsQhncfDed2.jpg?_r_=e93610d2-afe5-62c9-ffac-34bc6ede57ce" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="并发编程"/></a><div class="content"><a class="title" href="/posts/498cfd8e.html" title="并发编程">并发编程</a><time datetime="2025-10-23T15:51:36.000Z" title="发表于 2025-10-23 23:51:36">2025-10-23</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/7edb9ee1.html" title="集合框架"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://s2.loli.net/2025/10/23/g4UkwyDri9BWZtE.jpg?_r_=15bc3fef-3044-c8b4-4d1c-cc585f957842" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="集合框架"/></a><div class="content"><a class="title" href="/posts/7edb9ee1.html" title="集合框架">集合框架</a><time datetime="2025-10-23T08:48:49.330Z" title="发表于 2025-10-23 16:48:49">2025-10-23</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/aff6963e.html" title="如何解决高并发下的库存抢购超卖少买问题？"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://s2.loli.net/2025/10/23/YUHOf5MZEItlGd3.jpg?_r_=1d335fd2-520a-5de8-b607-f2b3e5a780fa" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="如何解决高并发下的库存抢购超卖少买问题？"/></a><div class="content"><a class="title" href="/posts/aff6963e.html" title="如何解决高并发下的库存抢购超卖少买问题？">如何解决高并发下的库存抢购超卖少买问题？</a><time datetime="2025-10-23T04:24:36.000Z" title="发表于 2025-10-23 12:24:36">2025-10-23</time></div></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div id="workboard"><img class="workSituationImg boardsign" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://npm.elemecdn.com/anzhiyu-blog@2.0.4/img/badge/安知鱼-上班摸鱼中.svg" alt="距离月入25k也就还差一个大佬带我~" title="距离月入25k也就还差一个大佬带我~"/><div id="runtimeTextTip"></div></div><p id="ghbdages"><a class="github-badge" target="_blank" href="https://hexo.io/" style="margin-inline:5px" data-title="博客框架为Hexo_v5.4.0" title="博客框架为Hexo_v5.4.0"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://npm.elemecdn.com/anzhiyu-blog@2.1.5/img/badge/Frame-Hexo.svg" alt="博客框架为Hexo_v5.4.0"/></a><a class="github-badge" target="_blank" href="https://blog.anheyu.com/" style="margin-inline:5px" data-title="本站使用AnZhiYu主题" title="本站使用AnZhiYu主题"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://npm.elemecdn.com/anzhiyu-theme-static@1.0.9/img/Theme-AnZhiYu-2E67D3.svg" alt="本站使用AnZhiYu主题"/></a><a class="github-badge" target="_blank" href="https://www.dogecloud.com/" style="margin-inline:5px" data-title="本站使用多吉云为静态资源提供CDN加速" title="本站使用多吉云为静态资源提供CDN加速"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://npm.elemecdn.com/anzhiyu-blog@2.2.0/img/badge/CDN-多吉云-3693F3.svg" alt="本站使用多吉云为静态资源提供CDN加速"/></a><a class="github-badge" target="_blank" href="https://github.com/" style="margin-inline:5px" data-title="本站项目由Github托管" title="本站项目由Github托管"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://npm.elemecdn.com/anzhiyu-blog@2.1.5/img/badge/Source-Github.svg" alt="本站项目由Github托管"/></a><a class="github-badge" target="_blank" href="http://creativecommons.org/licenses/by-nc-sa/4.0/" style="margin-inline:5px" data-title="本站采用知识共享署名-非商业性使用-相同方式共享4.0国际许可协议进行许可" title="本站采用知识共享署名-非商业性使用-相同方式共享4.0国际许可协议进行许可"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://npm.elemecdn.com/anzhiyu-blog@2.2.0/img/badge/Copyright-BY-NC-SA.svg" alt="本站采用知识共享署名-非商业性使用-相同方式共享4.0国际许可协议进行许可"/></a></p></div><div id="footer-bar"><div class="footer-bar-links"><div class="footer-bar-left"><div id="footer-bar-tips"><div class="copyright">&copy;2020 - 2025 By <a class="footer-bar-link" href="/" title="北川" target="_blank">北川</a></div></div><div id="footer-type-tips"></div></div><div class="footer-bar-right"><a class="footer-bar-link" target="_blank" rel="noopener" href="https://github.com/anzhiyu-c/hexo-theme-anzhiyu" title="主题">主题</a></div></div></div></footer></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="sidebar-site-data site-data is-center"><a href="/archives/" title="archive"><div class="headline">文章</div><div class="length-num">16</div></a><a href="/tags/" title="tag"><div class="headline">标签</div><div class="length-num">18</div></a><a href="/categories/" title="category"><div class="headline">分类</div><div class="length-num">5</div></a></div><span class="sidebar-menu-item-title">功能</span><div class="sidebar-menu-item"><a class="darkmode_switchbutton menu-child" href="javascript:void(0);" title="显示模式"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i><span>显示模式</span></a></div><div class="back-menu-list-groups"><div class="back-menu-list-group"><div class="back-menu-list-title">网页</div><div class="back-menu-list"><a class="back-menu-item" target="_blank" rel="noopener" href="https://blog.anheyu.com/" title="博客"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/favicon.png" alt="博客"/><span class="back-menu-item-text">博客</span></a></div></div></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 文章</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/archives/"><i class="anzhiyufont anzhiyu-icon-box-archive faa-tada" style="font-size: 0.9em;"></i><span> 隧道</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/categories/"><i class="anzhiyufont anzhiyu-icon-shapes faa-tada" style="font-size: 0.9em;"></i><span> 分类</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/tags/"><i class="anzhiyufont anzhiyu-icon-tags faa-tada" style="font-size: 0.9em;"></i><span> 标签</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 友链</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/link/"><i class="anzhiyufont anzhiyu-icon-link faa-tada" style="font-size: 0.9em;"></i><span> 友人帐</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/fcircle/"><i class="anzhiyufont anzhiyu-icon-artstation faa-tada" style="font-size: 0.9em;"></i><span> 朋友圈</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/comments/"><i class="anzhiyufont anzhiyu-icon-envelope faa-tada" style="font-size: 0.9em;"></i><span> 留言板</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 我的</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/music/?id=2898229193&amp;server=netease"><i class="anzhiyufont anzhiyu-icon-music faa-tada" style="font-size: 0.9em;"></i><span> 音乐馆</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/album/"><i class="anzhiyufont anzhiyu-icon-images faa-tada" style="font-size: 0.9em;"></i><span> 相册集</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/air-conditioner/"><i class="anzhiyufont anzhiyu-icon-fan faa-tada" style="font-size: 0.9em;"></i><span> 小空调</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 关于</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/about/"><i class="anzhiyufont anzhiyu-icon-paper-plane faa-tada" style="font-size: 0.9em;"></i><span> 关于本人</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/essay/"><i class="anzhiyufont anzhiyu-icon-lightbulb faa-tada" style="font-size: 0.9em;"></i><span> 闲言碎语</span></a></li></ul></div></div><span class="sidebar-menu-item-title">标签</span><div class="card-tags"><div class="item-headline"></div><div class="card-tag-cloud"><a href="/tags/JVM%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/" style="font-size: 0.88rem;">JVM内存模型<sup>1</sup></a><a href="/tags/JVM%E8%B0%83%E4%BC%98/" style="font-size: 0.88rem;">JVM调优<sup>1</sup></a><a href="/tags/java%E6%95%99%E7%A8%8B/" style="font-size: 0.88rem;">java教程<sup>1</sup></a><a href="/tags/mysql/" style="font-size: 0.88rem;">mysql<sup>1</sup></a><a href="/tags/%E5%87%BD%E6%95%B0/" style="font-size: 0.88rem;">函数<sup>1</sup></a><a href="/tags/%E5%8F%8D%E5%B0%84/" style="font-size: 0.88rem;">反射<sup>1</sup></a><a href="/tags/%E5%A4%8D%E4%B9%A0/" style="font-size: 0.88rem;">复习<sup>1</sup></a><a href="/tags/%E5%A4%8D%E4%B9%A0-%E5%8F%98%E9%87%8F/" style="font-size: 0.88rem;">复习 变量<sup>1</sup></a><a href="/tags/%E5%B7%A5%E5%85%B7/" style="font-size: 0.88rem;">工具<sup>1</sup></a><a href="/tags/%E5%B9%B6%E5%8F%91/" style="font-size: 0.88rem;">并发<sup>1</sup></a><a href="/tags/%E6%83%85%E6%84%9F/" style="font-size: 0.88rem;">情感<sup>1</sup></a><a href="/tags/%E6%8A%BD%E8%B1%A1%E7%B1%BB-%E6%8E%A5%E5%8F%A3/" style="font-size: 0.88rem;">抽象类 接口<sup>1</sup></a><a href="/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/" style="font-size: 0.88rem;">数据库<sup>1</sup></a><a href="/tags/%E6%AF%8F%E6%97%A5%E9%9D%A2%E8%AF%95/" style="font-size: 0.88rem;">每日面试<sup>2</sup></a><a href="/tags/%E7%94%B5%E5%95%86-%E8%AE%A2%E5%8D%95/" style="font-size: 0.88rem;">电商,订单<sup>1</sup></a><a href="/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" style="font-size: 0.88rem;">设计模式<sup>1</sup></a><a href="/tags/%E8%B6%85%E5%8D%96-%E5%BA%93%E5%AD%98/" style="font-size: 0.88rem;">超卖 , 库存<sup>1</sup></a><a href="/tags/%E9%9B%86%E5%90%88/" style="font-size: 0.88rem;">集合<sup>1</sup></a></div></div><hr/></div></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="anzhiyufont anzhiyu-icon-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">简</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="anzhiyufont anzhiyu-icon-arrows-left-right"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="anzhiyufont anzhiyu-icon-gear"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="anzhiyufont anzhiyu-icon-list-ul"></i></button><button id="chat-btn" type="button" title="聊天"><i class="anzhiyufont anzhiyu-icon-comment-sms"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="anzhiyufont anzhiyu-icon-comments"></i></a><a id="switch-commentBarrage" href="javascript:anzhiyu.switchCommentBarrage();" title="开关弹幕"><i class="anzhiyufont anzhiyu-icon-danmu"></i></a><button id="go-up" type="button" title="回到顶部"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></button></div></div><div id="nav-music"><a id="nav-music-hoverTips" onclick="anzhiyu.musicToggle()" accesskey="m">播放音乐</a><div id="console-music-bg"></div><meting-js id="8152976493" server="netease" type="playlist" mutex="true" preload="none" theme="var(--anzhiyu-main)" data-lrctype="0" order="random"></meting-js></div><div id="rightMenu"><div class="rightMenu-group rightMenu-small"><div class="rightMenu-item" id="menu-backward"><i class="anzhiyufont anzhiyu-icon-arrow-left"></i></div><div class="rightMenu-item" id="menu-forward"><i class="anzhiyufont anzhiyu-icon-arrow-right"></i></div><div class="rightMenu-item" id="menu-refresh"><i class="anzhiyufont anzhiyu-icon-arrow-rotate-right" style="font-size: 1rem;"></i></div><div class="rightMenu-item" id="menu-top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></div></div><div class="rightMenu-group rightMenu-line rightMenuPlugin"><div class="rightMenu-item" id="menu-copytext"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制选中文本</span></div><div class="rightMenu-item" id="menu-pastetext"><i class="anzhiyufont anzhiyu-icon-paste"></i><span>粘贴文本</span></div><a class="rightMenu-item" id="menu-commenttext"><i class="anzhiyufont anzhiyu-icon-comment-medical"></i><span>引用到评论</span></a><div class="rightMenu-item" id="menu-newwindow"><i class="anzhiyufont anzhiyu-icon-window-restore"></i><span>新窗口打开</span></div><div class="rightMenu-item" id="menu-copylink"><i class="anzhiyufont anzhiyu-icon-link"></i><span>复制链接地址</span></div><div class="rightMenu-item" id="menu-copyimg"><i class="anzhiyufont anzhiyu-icon-images"></i><span>复制此图片</span></div><div class="rightMenu-item" id="menu-downloadimg"><i class="anzhiyufont anzhiyu-icon-download"></i><span>下载此图片</span></div><div class="rightMenu-item" id="menu-newwindowimg"><i class="anzhiyufont anzhiyu-icon-window-restore"></i><span>新窗口打开图片</span></div><div class="rightMenu-item" id="menu-search"><i class="anzhiyufont anzhiyu-icon-magnifying-glass"></i><span>站内搜索</span></div><div class="rightMenu-item" id="menu-searchBaidu"><i class="anzhiyufont anzhiyu-icon-magnifying-glass"></i><span>百度搜索</span></div><div class="rightMenu-item" id="menu-music-toggle"><i class="anzhiyufont anzhiyu-icon-play"></i><span>播放音乐</span></div><div class="rightMenu-item" id="menu-music-back"><i class="anzhiyufont anzhiyu-icon-backward"></i><span>切换到上一首</span></div><div class="rightMenu-item" id="menu-music-forward"><i class="anzhiyufont anzhiyu-icon-forward"></i><span>切换到下一首</span></div><div class="rightMenu-item" id="menu-music-playlist" onclick="window.open(&quot;https://y.qq.com/n/ryqq/playlist/8152976493&quot;, &quot;_blank&quot;);" style="display: none;"><i class="anzhiyufont anzhiyu-icon-radio"></i><span>查看所有歌曲</span></div><div class="rightMenu-item" id="menu-music-copyMusicName"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制歌名</span></div></div><div class="rightMenu-group rightMenu-line rightMenuOther"><a class="rightMenu-item menu-link" id="menu-randomPost"><i class="anzhiyufont anzhiyu-icon-shuffle"></i><span>随便逛逛</span></a><a class="rightMenu-item menu-link" href="/categories/"><i class="anzhiyufont anzhiyu-icon-cube"></i><span>博客分类</span></a><a class="rightMenu-item menu-link" href="/tags/"><i class="anzhiyufont anzhiyu-icon-tags"></i><span>文章标签</span></a></div><div class="rightMenu-group rightMenu-line rightMenuOther"><a class="rightMenu-item" id="menu-copy" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制地址</span></a><a class="rightMenu-item" id="menu-commentBarrage" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-message"></i><span class="menu-commentBarrage-text">关闭热评</span></a><a class="rightMenu-item" id="menu-darkmode" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i><span class="menu-darkmode-text">深色模式</span></a><a class="rightMenu-item" id="menu-translate" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-language"></i><span>轉為繁體</span></a></div></div><div id="rightmenu-mask"></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.cbd.int/@fancyapps/ui@5.0.20/dist/fancybox/fancybox.umd.js"></script><script src="https://cdn.cbd.int/instant.page@5.2.0/instantpage.js" type="module"></script><script src="https://cdn.cbd.int/vanilla-lazyload@17.8.4/dist/lazyload.iife.min.js"></script><script src="https://cdn.cbd.int/node-snackbar@0.1.16/dist/snackbar.min.js"></script><canvas id="universe"></canvas><script async src="https://npm.elemecdn.com/anzhiyu-theme-static@1.0.0/dark/dark.js"></script><script>// 消除控制台打印
var HoldLog = console.log;
console.log = function () {};
let now1 = new Date();
queueMicrotask(() => {
  const Log = function () {
    HoldLog.apply(console, arguments);
  }; //在恢复前输出日志
  const grt = new Date("04/01/2023 00:00:00"); //此处修改你的建站时间或者网站上线时间
  now1.setTime(now1.getTime() + 250);
  const days = (now1 - grt) / 1000 / 60 / 60 / 24;
  const dnum = Math.floor(days);
  const ascll = [
    `欢迎使用安知鱼!`,
    `生活明朗, 万物可爱`,
    `
        
       █████╗ ███╗   ██╗███████╗██╗  ██╗██╗██╗   ██╗██╗   ██╗
      ██╔══██╗████╗  ██║╚══███╔╝██║  ██║██║╚██╗ ██╔╝██║   ██║
      ███████║██╔██╗ ██║  ███╔╝ ███████║██║ ╚████╔╝ ██║   ██║
      ██╔══██║██║╚██╗██║ ███╔╝  ██╔══██║██║  ╚██╔╝  ██║   ██║
      ██║  ██║██║ ╚████║███████╗██║  ██║██║   ██║   ╚██████╔╝
      ╚═╝  ╚═╝╚═╝  ╚═══╝╚══════╝╚═╝  ╚═╝╚═╝   ╚═╝    ╚═════╝
        
        `,
    "已上线",
    dnum,
    "天",
    "©2020 By 安知鱼 V1.6.8",
  ];
  const ascll2 = [`NCC2-036`, `调用前置摄像头拍照成功，识别为【小笨蛋】.`, `Photo captured: `, `🤪`];

  setTimeout(
    Log.bind(
      console,
      `\n%c${ascll[0]} %c ${ascll[1]} %c ${ascll[2]} %c${ascll[3]}%c ${ascll[4]}%c ${ascll[5]}\n\n%c ${ascll[6]}\n`,
      "color:#425AEF",
      "",
      "color:#425AEF",
      "color:#425AEF",
      "",
      "color:#425AEF",
      ""
    )
  );
  setTimeout(
    Log.bind(
      console,
      `%c ${ascll2[0]} %c ${ascll2[1]} %c \n${ascll2[2]} %c\n${ascll2[3]}\n`,
      "color:white; background-color:#4fd953",
      "",
      "",
      'background:url("https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/tinggge.gif") no-repeat;font-size:450%'
    )
  );

  setTimeout(Log.bind(console, "%c WELCOME %c 你好，小笨蛋.", "color:white; background-color:#4f90d9", ""));

  setTimeout(
    console.warn.bind(
      console,
      "%c ⚡ Powered by 安知鱼 %c 你正在访问 北川 的博客.",
      "color:white; background-color:#f0ad4e",
      ""
    )
  );

  setTimeout(Log.bind(console, "%c W23-12 %c 你已打开控制台.", "color:white; background-color:#4f90d9", ""));

  setTimeout(
    console.warn.bind(console, "%c S013-782 %c 你现在正处于监控中.", "color:white; background-color:#d9534f", "")
  );
});</script><script async src="/anzhiyu/random.js"></script><script async="async">(function () {
  var grt = new Date("04/01/2023 00:00:00"); //设置网站上线时间
  var now = new Date();
  var dnum;
  var hnum;
  var mnum;
  var snum;
  var nowHour;

  // 计算并更新天数、小时数、分钟数和秒数
  function updateTime() {
    now = new Date(); // 更新 now 的值
    nowHour = now.getHours(); // 更新 nowHour 的值
    var days = (now - grt) / 1000 / 60 / 60 / 24;
    dnum = Math.floor(days);
    var hours = (now - grt) / 1000 / 60 / 60 - 24 * dnum;
    hnum = Math.floor(hours);
    if (String(hnum).length == 1) {
      hnum = "0" + hnum;
    }
    var minutes = (now - grt) / 1000 / 60 - 24 * 60 * dnum - 60 * hnum;
    mnum = Math.floor(minutes);
    if (String(mnum).length == 1) {
      mnum = "0" + mnum;
    }
    var seconds = (now - grt) / 1000 - 24 * 60 * 60 * dnum - 60 * 60 * hnum - 60 * mnum;
    snum = Math.round(seconds);
    if (String(snum).length == 1) {
      snum = "0" + snum;
    }
  }

  // 更新网页中显示的网站运行时间
  function updateHtml() {
    const footer = document.getElementById("footer");
    if (!footer) return
    let currentTimeHtml = "";
    if (nowHour < 18 && nowHour >= 9) {
      // 如果是上班时间，默认就是"安知鱼-上班摸鱼中.svg"图片，不需要更改
      currentTimeHtml = `本站居然运行了 ${dnum} 天<span id='runtime'> ${hnum} 小时 ${mnum} 分 ${snum} 秒 </span><i class='anzhiyufont anzhiyu-icon-heartbeat' style='color:red'></i>`;
    } else {
      // 如果是下班时间，插入"安知鱼-下班啦.svg"图片
      let img = document.querySelector("#workboard .workSituationImg");
      img.src = "";
      img.title = "";
      img.alt = "";

      currentTimeHtml = `本站居然运行了 ${dnum} 天<span id='runtime'> ${hnum} 小时 ${mnum} 分 ${snum} 秒 </span><i class='anzhiyufont anzhiyu-icon-heartbeat' style='color:red'></i>`;
    }

    if (document.getElementById("runtimeTextTip")) {
      document.getElementById("runtimeTextTip").innerHTML = currentTimeHtml;
    }
  }

  setInterval(() => {
    updateTime();
    updateHtml();
  }, 1000);
})();</script><div class="js-pjax"><script>(() => {
  const initValine = () => {
    const valine = new Valine(Object.assign({
      el: '#vcomment',
      appId: '4GK2IcRZ0PX28gP4kGsW08qs-gzGzoHsz',
      appKey: 'TjKeHNK7GJrGTYuKYzGzh8yg',
      avatar: 'mp',
      serverURLs: '',
      emojiMaps: {"tv_doge":"6ea59c827c414b4a2955fe79e0f6fd3dcd515e24.png","tv_亲亲":"a8111ad55953ef5e3be3327ef94eb4a39d535d06.png","tv_偷笑":"bb690d4107620f1c15cff29509db529a73aee261.png","tv_再见":"180129b8ea851044ce71caf55cc8ce44bd4a4fc8.png","tv_冷漠":"b9cbc755c2b3ee43be07ca13de84e5b699a3f101.png","tv_发怒":"34ba3cd204d5b05fec70ce08fa9fa0dd612409ff.png","tv_发财":"34db290afd2963723c6eb3c4560667db7253a21a.png","tv_可爱":"9e55fd9b500ac4b96613539f1ce2f9499e314ed9.png","tv_吐血":"09dd16a7aa59b77baa1155d47484409624470c77.png","tv_呆":"fe1179ebaa191569b0d31cecafe7a2cd1c951c9d.png","tv_呕吐":"9f996894a39e282ccf5e66856af49483f81870f3.png","tv_困":"241ee304e44c0af029adceb294399391e4737ef2.png","tv_坏笑":"1f0b87f731a671079842116e0991c91c2c88645a.png","tv_大佬":"093c1e2c490161aca397afc45573c877cdead616.png","tv_大哭":"23269aeb35f99daee28dda129676f6e9ea87934f.png","tv_委屈":"d04dba7b5465779e9755d2ab6f0a897b9b33bb77.png","tv_害羞":"a37683fb5642fa3ddfc7f4e5525fd13e42a2bdb1.png","tv_尴尬":"7cfa62dafc59798a3d3fb262d421eeeff166cfa4.png","tv_微笑":"70dc5c7b56f93eb61bddba11e28fb1d18fddcd4c.png","tv_思考":"90cf159733e558137ed20aa04d09964436f618a1.png","tv_惊吓":"0d15c7e2ee58e935adc6a7193ee042388adc22af.png"},
      path: window.location.pathname,
      visitor: false
    }, null))
  }

  const loadValine = async () => {
    if (typeof Valine === 'function') initValine()
    else {
      await getScript('https://cdn.cbd.int/valine@1.5.1/dist/Valine.min.js')
      initValine()
    }
  }

  if ('Valine' === 'Valine' || !false) {
    if (false) anzhiyu.loadComment(document.getElementById('vcomment'),loadValine)
    else setTimeout(loadValine, 0)
  } else {
    window.loadOtherComment = loadValine
  }
})()</script><input type="hidden" name="page-type" id="page-type" value="post"></div><script src="https://cdn.cbd.int/blueimp-md5@2.19.0/js/md5.min.js"></script><script>window.addEventListener('load', () => {
  const changeContent = (content) => {
    if (content === '') return content

    content = content.replace(/<img.*?src="(.*?)"?[^\>]+>/ig, '[图片]') // replace image link
    content = content.replace(/<a[^>]+?href=["']?([^"']+)["']?[^>]*>([^<]+)<\/a>/gi, '[链接]') // replace url
    content = content.replace(/<pre><code>.*?<\/pre>/gi, '[代码]') // replace code
    content = content.replace(/<[^>]+>/g,"") // remove html tag

    if (content.length > 150) {
      content = content.substring(0,150) + '...'
    }
    return content
  }

  const getIcon = (icon, mail) => {
    if (icon) return icon
    let defaultIcon = '?d=mp'
    let iconUrl = `https://gravatar.loli.net/avatar/${md5(mail.toLowerCase()) + defaultIcon}`
    return iconUrl
  }

  const generateHtml = array => {
    let result = ''

    if (array.length) {
      for (let i = 0; i < array.length; i++) {
        result += '<div class=\'aside-list-item\'>'

        if (true) {
          const name = 'data-lazy-src'
          result += `<a href='${array[i].url}' class='thumbnail'><img ${name}='${array[i].avatar}' alt='${array[i].nick}'></a>`
        }

        result += `<div class='content'>
        <a class='comment' href='${array[i].url}' title='${array[i].content}'>${array[i].content}</a>
        <div class='name'><span>${array[i].nick} / </span><time datetime="${array[i].date}">${anzhiyu.diffDate(array[i].date, true)}</time></div>
        </div></div>`
      }
    } else {
      result += '没有评论'
    }

    let $dom = document.querySelector('#card-newest-comments .aside-list')
    $dom.innerHTML= result
    window.lazyLoadInstance && window.lazyLoadInstance.update()
    window.pjax && window.pjax.refresh($dom)
  }

  const getComment = () => {
    const serverURL = 'https://4GK2IcRZ.api.lncldglobal.com'

    var settings = {
      "method": "GET",
      "headers": {
        "X-LC-Id": '4GK2IcRZ0PX28gP4kGsW08qs-gzGzoHsz',
        "X-LC-Key": 'TjKeHNK7GJrGTYuKYzGzh8yg',
        "Content-Type": "application/json"
      },
    }

    fetch(`${serverURL}/1.1/classes/Comment?limit=6&order=-createdAt`,settings)
      .then(response => response.json())
      .then(data => {
        const valineArray = data.results.map(function (e) {
          return {
            'avatar': getIcon(e.QQAvatar, e.mail),
            'content': changeContent(e.comment),
            'nick': e.nick,
            'url': e.url + '#' + e.objectId,
            'date': e.updatedAt,
          }
        })
        saveToLocal.set('valine-newest-comments', JSON.stringify(valineArray), 10/(60*24))
        generateHtml(valineArray)
      }).catch(e => {
        const $dom = document.querySelector('#card-newest-comments .aside-list')
        $dom.textContent= "无法获取评论，请确认相关配置是否正确"
      }) 
  }

  const newestCommentInit = () => {
    if (document.querySelector('#card-newest-comments .aside-list')) {
      const data = saveToLocal.get('valine-newest-comments')
      if (data) {
        generateHtml(JSON.parse(data))
      } else {
        getComment()
      }
    }
  }

  newestCommentInit()
  document.addEventListener('pjax:complete', newestCommentInit)
})</script><script>var visitorMail = "visitor@anheyu.com";
</script><script async data-pjax src="https://cdn.cbd.int/anzhiyu-theme-static@1.0.0/waterfall/waterfall.js"></script><script src="https://lf3-cdn-tos.bytecdntp.com/cdn/expire-1-M/qrcodejs/1.0.0/qrcode.min.js"></script><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.1.9/icon/ali_iconfont_css.css"><script src="//code.tidio.co/4nifo6zdbrmyjsngh2yzxwbnlhrvshrf.js" async="async"></script><script>(() => {
  const isChatBtn = true
  const isChatHideShow = true

  if (isChatBtn) {
    let isShow = false
    const close = () => {
      window.tidioChatApi.hide()
      isShow = false
    }
    
    const open = () => {
      window.tidioChatApi.open()
      window.tidioChatApi.show()
      isShow = true
    }

    const onTidioChatApiReady = () => {
      window.tidioChatApi.hide()
      window.tidioChatApi.on("close", close)
    }
    if (window.tidioChatApi) {
      window.tidioChatApi.on("ready", onTidioChatApiReady)
    } else {
      document.addEventListener("tidioChat-ready", onTidioChatApiReady)
    }

    window.chatBtnFn = () => {
      if (!window.tidioChatApi) return
      isShow ? close() : open()
    }
  } else if (isChatHideShow) {
    window.chatBtn = {
      hide: () => {
        window.tidioChatApi && window.tidioChatApi.hide()
      },
      show: () => {
        window.tidioChatApi && window.tidioChatApi.show()
      }
    }
  }
})()</script><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.0.0/aplayer/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.cbd.int/anzhiyu-blog-static@1.0.1/js/APlayer.min.js"></script><script src="https://cdn.cbd.int/hexo-anzhiyu-music@1.0.1/assets/js/Meting2.min.js"></script><script src="https://cdn.cbd.int/pjax@0.2.8/pjax.min.js"></script><script>let pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]
var pjax = new Pjax({
  elements: 'a:not([target="_blank"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {
  // removeEventListener scroll 
  anzhiyu.removeGlobalFnEvent('pjax')
  anzhiyu.removeGlobalFnEvent('themeChange')

  document.getElementById('rightside').classList.remove('rightside-show')
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')
})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()
})

document.addEventListener('pjax:error', e => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script charset="UTF-8" src="https://cdn.cbd.int/anzhiyu-theme-static@1.1.5/accesskey/accesskey.js"></script></div><div id="popup-window"><div class="popup-window-title">通知</div><div class="popup-window-divider"></div><div class="popup-window-content"><div class="popup-tip">你好呀</div><div class="popup-link"><i class="anzhiyufont anzhiyu-icon-arrow-circle-right"></i></div></div></div></body></html>