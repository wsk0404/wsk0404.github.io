<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no"><title>java教程 | Wsk Blog</title><meta name="keywords" content="java教程"><meta name="author" content="Wsk,2047891093@qq.com"><meta name="copyright" content="Wsk"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#f7f9fe"><meta name="mobile-web-app-capable" content="yes"><meta name="apple-touch-fullscreen" content="yes"><meta name="apple-mobile-web-app-title" content="java教程"><meta name="application-name" content="java教程"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="#f7f9fe"><meta property="og:type" content="article"><meta property="og:title" content="java教程"><meta property="og:url" content="https://wsk0404.github.io/posts/8003e2d3.html"><meta property="og:site_name" content="Wsk Blog"><meta property="og:description" content="Java教程Java 简介Java 是由 Sun Microsystems 公司于 1995 年 5 月推出的 Java 面向对象程序设计语言和 Java 平台的总称。由 James Gosling和同事们共同研发，并在 1995 年正式推出。 后来 Sun 公司被 Oracle （甲骨文）公司收购"><meta property="og:locale" content="zh-CN"><meta property="og:image" content="https://s2.loli.net/2025/10/23/wfbr2eNcL1VvXIn.png?_r_=204c01e8-b178-e5d6-c5d9-a8b8857b2e3a"><meta property="article:author" content="Wsk"><meta property="article:tag" content="博客,笔记,学习"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://s2.loli.net/2025/10/23/wfbr2eNcL1VvXIn.png?_r_=204c01e8-b178-e5d6-c5d9-a8b8857b2e3a"><meta name="description" content="Java教程Java 简介Java 是由 Sun Microsystems 公司于 1995 年 5 月推出的 Java 面向对象程序设计语言和 Java 平台的总称。由 James Gosling和同事们共同研发，并在 1995 年正式推出。 后来 Sun 公司被 Oracle （甲骨文）公司收购"><link rel="shortcut icon" href="/favicon.ico"><link rel="canonical" href="https://wsk0404.github.io/posts/8003e2d3"><link rel="preconnect" href="//cdn.cbd.int"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><meta name="google-site-verification" content="xxx"/><meta name="baidu-site-verification" content="code-xxx"/><meta name="msvalidate.01" content="xxx"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.cbd.int/node-snackbar@0.1.16/dist/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.cbd.int/@fancyapps/ui@5.0.20/dist/fancybox/fancybox.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://npm.elemecdn.com/anzhiyu-theme-static@1.0.0/swiper/swiper.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  linkPageTop: undefined,
  peoplecanvas: {"enable":true,"img":"https://upload-bbs.miyoushe.com/upload/2023/09/03/125766904/ee23df8517f3c3e3efc4145658269c06_5714860933110284659.png"},
  postHeadAiDescription: undefined,
  diytitle: {"enable":true,"leaveTitle":"w(ﾟДﾟ)w 不要走！再看看嘛！","backTitle":"♪(^∇^*)欢迎肥来！"},
  LA51: undefined,
  greetingBox: {"enable":true,"default":"晚上好👋","list":[{"greeting":"晚安😴","startTime":0,"endTime":5},{"greeting":"早上好鸭👋, 祝你一天好心情！","startTime":6,"endTime":9},{"greeting":"上午好👋, 状态很好，鼓励一下～","startTime":10,"endTime":10},{"greeting":"11点多啦, 在坚持一下就吃饭啦～","startTime":11,"endTime":11},{"greeting":"午安👋, 宝贝","startTime":12,"endTime":14},{"greeting":"🌈充实的一天辛苦啦！","startTime":14,"endTime":18},{"greeting":"19点喽, 奖励一顿丰盛的大餐吧🍔。","startTime":19,"endTime":19},{"greeting":"晚上好👋, 在属于自己的时间好好放松😌~","startTime":20,"endTime":24}]},
  twikooEnvId: '',
  commentBarrageConfig:{"enable":true,"maxBarrage":1,"barrageTime":4000,"accessToken":"","mailMd5":"3932F24FA213E964B6B1B0FD091F88CE"},
  root: '/',
  preloader: {"source":3},
  friends_vue_info: {"apiurl":"https://friends.anheyu.com/"},
  navMusic: true,
  mainTone: {"mode":"both","api":"https://img2color-go.vercel.app/api?img=","cover_change":true},
  authorStatus: {"skills":["🤖️ 数码科技爱好者","🔍 分享与热心帮助","🔨 设计开发一条龙","🏃 脚踏实地行动派"]},
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简","rightMenuMsgToTraditionalChinese":"转为繁体","rightMenuMsgToSimplifiedChinese":"转为简体"},
  noticeOutdate: {"limitDay":365,"position":"top","messagePrev":"It has been","messageNext":"days since the last update, the content of the article may be outdated."},
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":330},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: true,
    simplehomepage: false,
    post: true
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"copy":true,"copyrightEbable":true,"limitCount":50,"languages":{"author":"作者: Wsk","link":"链接: ","source":"来源: Wsk Blog","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。","copySuccess":"复制成功，复制和转载请标注本文地址"}},
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#425AEF","bgDark":"#1f1f1f","position":"top-center"},
  source: {
    justifiedGallery: {
      js: 'https://cdn.cbd.int/flickr-justified-gallery@2.1.2/dist/fjGallery.min.js',
      css: 'https://cdn.cbd.int/flickr-justified-gallery@2.1.2/dist/fjGallery.css'
    }
  },
  isPhotoFigcaption: true,
  islazyload: true,
  isAnchor: false,
  shortcutKey: undefined,
  autoDarkmode: true
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  configTitle: 'Wsk Blog',
  title: 'java教程',
  postAI: '',
  pageFillDescription: 'Java教程, Java 简介, 主要特性, 发展历史(简略版), Java 开发工具, Java 开发环境配置, window系统安装java, 下载JDK, 配置环境变量, 测试JDK是否安装成功, 流行 Java 开发工具, Java 基础语法, 第一个Java程序, 基本语法, Java 标识符, Java修饰符, Java 变量, Java 数组, Java 枚举, Java 关键字, Java注释, 继承, 接口, Java 对象和类, Java中的对象, Java 中的类, 构造方法, 创建对象, 访问实例变量和方法, 实例, 源文件声明规则, import 语句, 一个简单的例子, Java 基本数据类型, 内置数据类型, 实例, 类型默认值, 引用类型, 自动类型转换, 自动类型转换, 强制类型转换, 隐含强制类型转换, Java 变量类型, Java 参数变量, Java 局部变量, 成员变量（实例变量）, 类变量（静态变量）, 定义方式, 实例, 访问方式, 实例, 生命周期, 初始化时机, 实例, 常量和静态变量的区别, 静态变量的访问修饰符, 静态变量的线程安全性, 静态变量的命名规范, 实例, 静态变量的使用场景, Java 修饰符, 访问控制修饰符, 默认访问修饰符-不使用任何关键字, 私有访问修饰符-private, 公有访问修饰符-public, 受保护的访问修饰符-protected, 访问控制和继承, 非访问修饰符, static 修饰符, final 修饰符, abstract 修饰符, Java 运算符, 算术运算符, 关系运算符, 位运算符, 逻辑运算符, 短路逻辑运算符, 赋值运算符, 条件运算符（?）, instanceof 运算符, Java运算符优先级, Java 循环结构 - for while 及 do…while, while 循环, do…while 循环, for循环, Java 增强 for 循环, 实例, Test.java 文件代码：, break 关键字, continue 关键字, Java 条件语句 - if…else, if…else语句, 语法, if…else if…else 语句, 嵌套的 if…else 语句, 语法, Java switch case 语句, 语法, Java Number amp Math 类, Java Math 类, Number amp Math 类方法, Java Character 类, 转义序列, Character 方法, Java String 类, 创建字符串, String 方法, Java StringBuffer 和 StringBuilder 类, StringBuffer 方法, Java 数组, 声明数组变量, 创建数组, 处理数组, For-Each 循环, 多维数组, 多维数组的动态初始化（以二维数组为例）, Arrays 类, Java 日期时间, 获取当前日期时间, 日期比较, 使用 SimpleDateFormat 格式化日期, 使用printf格式化日期, Java 休眠(sleep), Calendar类, 创建一个代表系统当前日期的Calendar对象, 创建一个指定日期的Calendar对象, Calendar类对象字段类型, Calendar类对象信息的获得, Java 方法, 那么什么是方法呢？, 方法的优点, 方法的命名规则, 方法的定义, 方法的重载, 构造方法, finalize() 方法, Java 流(Stream)、文件(File)和IO, 读取控制台输入, 从控制台读取多字符输入, 从控制台读取字符串, 控制台输出, FileInputStream, FileOutputStream, 文件和Ix2FO, Java中的目录, 创建目录：, 读取目录, 删除目录或文件, Java Scanner 类, 使用 next 方法：, 使用 nextLine 方法：, next() 与 nextLine() 区别, Java 异常处理, Exception 类的层次, 捕获异常, throwsx2Fthrow 关键字, throw 关键字, throws 关键字, finally关键字, try-with-resources, 声明自定义异常, Java 继承, 继承的概念, 生活中的继承：, 类的继承格式, 继承类型, 继承的特性, 继承关键字, extends关键字, 构造器, Java 重写(Override)与重载(Overload), 重写(Override), 方法的重写规则, 重载(Overload), 重写与重载之间的区别, 总结, Java 多态, 多态的优点, 多态存在的三个必要条件, 多态的实现方式, 方式一：重写：, 方式二：接口, 方式三：抽象类和抽象方法, Java 抽象类, 抽象类, 抽象方法, 抽象类总结规定, Java 封装, 封装的优点, Java 接口, 接口与类相似点：, 接口与类的区别：, 接口特性, 抽象类和接口的区别, 标记接口, Java 枚举(enum), values() ordinal() 和 valueOf() 方法, Java 包(package), 包的作用, 创建包, import 关键字, Java 集合框架, 集合接口, Set和List的区别, 如何使用迭代器, 总结, Java ArrayList, Java ArrayList 方法, Java LinkedList, 常用方法, Java HashSet, Java HashMap, Java HashMap 方法, Java Iterator（迭代器）, 获取一个迭代器, Java Object 类, 类的构造函数, 类的方法, Java 泛型, 泛型方法, 泛型类, 实例, 类型通配符, Java 序列化, Java 网络编程, Socket 编程, Socket 类的方法, Socket 客户端实例, Socket 服务端实例, Java 多线程编程, 一个线程的生命周期, 线程的优先级, 创建一个线程, 通过 Callable 和 Future 创建线程, 创建线程的三种方式的对比, 线程的几个主要概念, 多线程的使用, Java 文档注释, javadoc 标签教程简介是由公司于年月推出的面向对象程序设计语言和平台的总称由和同事们共同研发并在年正式推出后来公司被甲骨文公司收购也随之成为公司的产品分为三个体系平台标准版平台企业版平台微型版年月大会召开公司公开此时的各种版本已经更名以取消其中的数字更名为更名为更名为主要特性语言是简单的语言的语法与语言和语言很接近使得大多数程序员很容易学习和使用另一方面丢弃了中很少使用的很难理解的令人迷惑的那些特性如操作符重载多继承自动的强制类型转换特别地语言不使用指针而是引用并提供了自动分配和回收内存空间使得程序员不必为内存管理而担忧语言是面向对象的语言提供类接口和继承等面向对象的特性为了简单起见只支持类之间的单继承但支持接口之间的多继承并支持类与接口之间的实现机制关键字为语言全面支持动态绑定而语言只对虚函数使用动态绑定总之语言是一个纯的面向对象程序设计语言语言是分布式的语言支持应用的开发在基本的应用编程接口中有一个网络应用编程接口它提供了用于网络应用编程的类库包括等的远程方法激活机制也是开发分布式应用的重要手段语言是健壮的的强类型机制异常处理垃圾的自动收集等是程序健壮性的重要保证对指针的丢弃是的明智选择的安全检查机制使得更具健壮性语言是安全的通常被用在网络环境中为此提供了一个安全机制以防恶意代码的攻击除了语言具有的许多安全特性以外对通过网络下载的类具有一个安全防范机制类如分配不同的名字空间以防替代本地的同名类字节代码检查并提供安全管理机制类让应用设置安全哨兵语言是体系结构中立的程序后缀为的文件在平台上被编译为体系结构中立的字节码格式后缀为的文件然后可以在实现这个平台的任何系统中运行这种途径适合于异构的网络环境和软件的分发语言是可移植的这种可移植性来源于体系结构中立性另外还严格规定了各个基本数据类型的长度系统本身也具有很强的可移植性编译器是用实现的的运行环境是用实现的语言是解释型的如前所述程序在平台上被编译为字节码格式然后可以在实现这个平台的任何系统中运行在运行时平台中的解释器对这些字节码进行解释执行执行过程中需要的类在联接阶段被载入到运行环境中是高性能的与那些解释型的高级脚本语言相比的确是高性能的事实上的运行速度随着编译器技术的发展越来越接近于语言是多线程的在语言中线程是一种特殊的对象它必须由类或其子孙类来创建通常有两种方法来创建线程其一使用型构为的构造子类将一个实现了接口的对象包装成一个线程其二从类派生出子类并重写方法使用该子类创建的对象即为线程值得注意的是类已经实现了接口因此任何一个线程均有它的方法而方法中包含了线程所要运行的代码线程的活动由一组方法来控制语言支持多个线程的同时执行并提供多线程之间的同步机制关键字为语言是动态的语言的设计目标之一是适应于动态变化的环境程序需要的类能够动态地被载入到运行环境也可以通过网络来载入所需要的类这也有利于软件的升级另外中的类有一个运行时刻的表示能进行运行时刻的类型检查发展历史简略版年月日语言诞生年月公司发布的三个版本标准版以前是企业版以前是和微型版以前是年月日发布成为语言发展史上的又一里程碑为了表示该版本的重要性更名为年月大会召开公司公开此时的各种版本已经更名以取消其中的数字更名为更名为更名为年月公司发布年月日甲骨文亿美元收购取得的版权年月日甲骨文发布的正式版年月日公司发表年月日公司发表年月日公司发表年月日发布年月日发布开发工具语言尽量保证系统内存在以上其他工具如下所示系统系统系统编辑器或者其他编辑器等开发环境配置系统安装下载首先我们需要下载开发工具包下载地址在下载页面中根据自己的系统选择对应的版本本文以位系统为例下载后的安装根据提示进行还有安装的时候也会安装一并安装就可以了安装安装过程中可以自定义安装目录等信息例如我们选择安装目录为配置环境变量安装完成后右击我的电脑点击属性选择高级系统设置选择高级选项卡点击环境变量然后就会出现如下图所示的画面在系统变量中设置项属性大小写无所谓若已存在则点击编辑不存在则点击新建注意如果使用以上版本的不用设置环境变量也可以正常编译和运行程序变量设置参数如下变量名变量值要根据自己的实际路径配置变量名变量值记得前面有个变量名变量值测试是否安装成功开始运行键入键入命令几个命令出现以下信息说明环境变量配置成功流行开发工具我们在开发语言过程中同样需要一款不错的开发工具目前市场上的很多本文为大家推荐以下下几款开发工具推荐另一个免费开源的下载地址选择的推荐现在很多人开始使用了功能很强大下载地址全称是一款由微软开发且跨平台的免费源代码编辑器安装教程开源免费的下载地址基础语法对象对象是类的一个实例有状态和行为例如一条狗是一个对象它的状态有颜色名字品种行为有摇尾巴叫吃等类类是一个模板它描述一类对象的行为和状态方法方法就是行为一个类可以有很多方法逻辑运算数据修改以及所有动作都是在方法中完成的实例变量每个对象都有独特的实例变量对象的状态由这些实例变量的值决定第一个程序下面看一个简单的程序它将输出字符串第一个程序它将输出字符串输出基本语法编写程序时应注意以下几点大小写敏感是大小写敏感的这就意味着标识符与是不同的类名对于所有的类来说类名的首字母应该大写如果类名由若干单词组成那么每个单词的首字母应该大写例如方法名所有的方法名都应该以小写字母开头如果方法名含有若干单词则后面的每个单词首字母大写源文件名源文件名必须和类名相同当保存文件的时候你应该使用类名作为文件名保存切记是大小写敏感的文件名的后缀为如果文件名和类名不相同则会导致编译错误主方法入口所有的程序由方法开始执行标识符所有的组成部分都需要名字类名变量名以及方法名都被称为标识符关于标识符有以下几点需要注意所有的标识符都应该以字母或者美元符或者下划线开始首字符之后可以是字母或者美元符下划线或数字的任何字符组合关键字不能用作标识符标识符是大小写敏感的合法标识符举例非法标识符举例修饰符像其他语言一样可以使用修饰符来修饰类中方法和属性主要有两类修饰符访问控制修饰符非访问控制修饰符在后面的章节中我们会深入讨论修饰符变量中主要有如下几种类型的变量局部变量类变量静态变量成员变量非静态变量数组数组是储存在堆上的对象可以保存多个同类型变量在后面的章节中我们将会学到如何声明构造以及初始化一个数组枚举引入了枚举枚举限制变量只能是预先设定好的值使用枚举可以减少代码中的例如我们为果汁店设计一个程序它将限制果汁为小杯中杯大杯这就意味着它不允许顾客点除了这三种尺寸外的果汁关键字不需要特殊记忆随着开发程序的进行就会慢慢记住注释这是第一个程序它将输出这是一个多行注释的示例这是单行注释的示例这个也是单行注释的示例继承在中一个类可以由其他类派生如果你要创建一个类而且已经存在一个类具有你所需要的属性或方法那么你可以将新创建的类继承该类利用继承的方法可以重用已存在类的方法和属性而不用重写这些代码被继承的类称为超类派生类称为子类接口在中接口可理解为对象间相互通信的协议接口在继承中扮演着很重要的角色接口只定义派生要用到的方法但是方法的具体实现完全取决于派生类对象和类作为一种面向对象语言支持以下基本概念多态继承封装抽象类对象实例方法重载重点研究对象和类的概念对象对象是类的一个实例对象不是找个女朋友有状态和行为例如一条狗是一个对象它的状态有颜色名字品种行为有摇尾巴叫吃等类类是一个模板它描述一类对象的行为和状态中的对象软件对象也有状态和行为软件对象的状态就是属性行为通过方法体现在软件开发中方法操作对象内部状态的改变对象的相互调用也是通过方法来完成中的类类可以看成是创建对象的模板局部变量在方法构造方法或者语句块中定义的变量被称为局部变量变量声明和初始化都是在方法中方法结束后变量就会自动销毁成员变量成员变量是定义在类中方法体之外的变量这种变量在创建对象的时候实例化成员变量可以被类中方法构造方法和特定类的语句块访问类变量类变量也声明在类中方法体之外但必须声明为类型一个类可以拥有多个方法在上面的例子中和都是类的方法构造方法每个类都有构造方法如果没有显式地为类定义构造方法编译器将会为该类提供一个默认构造方法在创建一个对象的时候至少要调用一个构造方法构造方法的名称必须与类同名一个类可以有多个构造方法下面是一个构造方法示例这个构造器仅有一个参数创建对象对象是根据类创建的在中使用关键字来创建一个新的对象创建对象需要以下三步声明声明一个对象包括对象名称和对象类型实例化使用关键字来创建一个对象初始化使用创建对象时会调用构造方法初始化对象这个构造器仅有一个参数小狗的名字是下面的语句将创建一个对象访问实例变量和方法实例化对象访问类中的变量访问类中的方法实例下面的例子展示如何访问实例变量和调用成员方法这个构造器仅有一个参数小狗的名字是小狗的年龄为创建对象通过方法来设定调用另一个方法获取你也可以像下面这样访问成员变量变量值源文件声明规则一个源文件中只能有一个类一个源文件可以有多个非类源文件的名称应该和类的类名保持一致例如源文件中类的类名是那么源文件应该命名为如果一个类定义在某个包中那么语句应该在源文件的首行如果源文件包含语句那么应该放在语句和类定义之间如果没有语句那么语句应该在源文件中最前面语句和语句对源文件中定义的所有类都有效在同一源文件中不能给不同的类不同的包声明语句在中如果给出一个完整的限定名包括包名类名那么编译器就可以很容易地定位到源代码或者类语句就是用来提供一个合理的路径使得编译器可以找到某个类例如下面的命令行将会命令编译器载入路径下的所有类一个简单的例子在该例子中我们创建两个类和首先打开文本编辑器把下面的代码粘贴进去注意将文件保存为类有四个成员变量和该类显式声明了一个构造方法该方法只有一个参数类的构造器设置的值设置的值设置的值打印信息名字年龄职位薪水程序都是从方法开始执行为了能运行这个程序必须包含方法并且创建一个实例对象下面给出类该类实例化个类的实例并调用方法设置变量的值将下面的代码保存在文件中使用构造器创建两个对象调用这两个对象的成员方法高级程序员菜鸟程序员基本数据类型变量就是申请内存来存储值也就是说当创建变量的时候需要在内存中申请空间内存管理系统根据变量的类型为变量分配存储空间分配的空间只能用来储存该类型数据因此通过定义不同类型的变量可以在内存中储存整数小数或者字符的两大数据类型内置数据类型引用数据类型内置数据类型语言提供了八种基本类型六种数字类型四个整数型两个浮点型一种字符类型还有一种布尔型数据类型是位有符号的以二进制补码表示的整数最小值是最大值是默认值是类型用在大型数组中节约空间主要代替整数因为变量占用的空间只有类型的四分之一例子数据类型是位有符号的以二进制补码表示的整数最小值是最大值是数据类型也可以像那样节省空间一个变量是型变量所占空间的二分之一默认值是例子数据类型是位有符号的以二进制补码表示的整数最小值是最大值是一般地整型变量默认为类型默认值是例子数据类型是位有符号的以二进制补码表示的整数最小值是最大值是这种类型主要使用在需要比较大整数的系统上默认值是例子理论上不分大小写但是若写成容易与数字混淆不容易分辩所以最好大写数据类型是单精度位符合标准的浮点数在储存大型浮点数组的时候可节省内存空间默认值是浮点数不能用来表示精确的值如货币例子数据类型是双精度位符合标准的浮点数浮点数的默认类型为类型类型同样不能表示精确的值如货币默认值是例子是一个字面量而和是字面量数据类型表示一位的信息只有两个取值和这种类型只作为一种标志来记录情况默认值是例子类型是一个单一的位字符最小值是十进制等效值为最大值是即为数据类型可以储存任何字符例子实例基本类型二进制位数包装类最小值最大值基本类型二进制位数包装类最小值最大值类型默认值下表列出了各个类型的默认值引用类型在中引用类型的变量非常类似于的指针引用类型指向一个对象指向对象的变量是引用变量这些变量在声明时被指定为一个特定的类型比如等变量一旦声明后类型就不能被改变了对象数组都是引用数据类型所有引用类型的默认值都是一个引用变量可以用来引用任何与之兼容的类型例子语言支持一些特殊的转义字符序列自动类型转换整型实型常量字符型数据可以混合运算运算中不同类型的数据先转化为同一类型然后进行运算转换从低级到高级低高不能对类型进行类型转换不能把对象类型转换成不相关类的对象在把容量大的类型转换为容量小的类型时必须使用强制类型转换转换过程中可能导致溢出或损失精度例如因为类型是位最大值为所以当强制转换为类型时值时候就会导致溢出浮点数到整数的转换是通过舍弃小数得到而不是四舍五入例如自动类型转换必须满足转换前的数据类型的位数要低于转换后的数据类型例如数据类型的位数为位就可以自动转换位数为的类型同样数据类型的位数为可以自动转换为位的类型示例定义一个类型自动类型转换为自动类型转换为后的值等于定义一个类型类型和类型计算类型和计算后的值等于强制类型转换条件是转换的数据类型必须是兼容的格式是要强制类型转换后的数据类型隐含强制类型转换整数的默认类型是小数默认是类型浮点型在定义类型时必须在数字后面跟上或者变量类型声明变量的格式数据类型变量名如或者多个变量名如示例声明三个型整数声明三个整数并赋予初值声明并初始化声明并初始化字符串声明了双精度浮点型变量声明变量的值是字符语言支持的变量类型有局部变量定义在方法构造方法或语句块中的变量作用域只限于当前方法构造方法或语句块中局部变量必须在使用前声明并且不能被访问修饰符修饰成员变量定义在类中方法之外的变量作用域为整个类可以被类中的任何方法构造方法和语句块访问成员变量可以被访问修饰符修饰静态变量定义在类中方法之外的变量并且使用关键字修饰作用域为整个类可以被类中的任何方法构造方法和语句块访问静态变量的值在程序运行期间只有一个副本静态变量可以被访问修饰符修饰参数变量方法定义时声明的变量作为调用该方法时传递给方法的值参数变量的作用域只限于方法内部示例成员变量静态变量局部变量使用变量成员变量静态变量参数变量局部变量参数变量中的参数变量是指在方法或构造函数中声明的变量用于接收传递给方法或构造函数的值参数变量与局部变量类似但它们只在方法或构造函数被调用时存在并且只能在方法或构造函数内部使用方法的声明语法如下方法体表示参数变量的类型表示参数变量的名称在调用方法时我们必须为参数变量传递值这些值可以是常量变量或表达式方法参数变量的值传递方式有两种值传递和引用传递值传递在方法调用时传递的是实际参数的值的副本当参数变量被赋予新的值时只会修改副本的值不会影响原始值中的基本数据类型都采用值传递方式传递参数变量的值引用传递在方法调用时传递的是实际参数的引用即内存地址当参数变量被赋予新的值时会修改原始值的内容中的对象类型采用引用传递方式传递参数变量的值调用方法输出和的值局部变量局部变量声明在方法构造方法或者语句块中局部变量在方法构造方法或者语句块被执行的时候创建当它们执行完成后变量将会被销毁局部变量必须在使用前声明并且不能被访问修饰符修饰因为它们的作用域已经被限制在了声明它们的方法代码块或构造函数中局部变量只在声明它的方法构造方法或者语句块中可见不能被其他方法或代码块访问局部变量是在栈上分配的局部变量没有默认值所以局部变量被声明后必须经过初始化才可以使用成员变量实例变量成员变量声明在一个类中但在方法构造方法和语句块之外当一个对象被实例化之后每个成员变量的值就跟着确定成员变量在对象创建的时候创建在对象被销毁的时候销毁成员变量的值应该至少被一个方法构造方法或者语句块引用使得外部能够通过这些方式获取实例变量信息成员变量可以声明在使用前或者使用后访问修饰符可以修饰成员变量成员变量对于类中的方法构造方法或者语句块是可见的一般情况下应该把成员变量设为私有通过使用访问修饰符可以使成员变量对子类可见成员变量具有默认值数值型变量的默认值是布尔型变量的默认值是引用类型变量的默认值是变量的值可以在声明时指定也可以在构造方法中指定成员变量可以直接通过变量名访问但在静态方法以及其他类中就应该使用完全限定名与局部变量不同成员变量的值在创建对象时被分配即使未对其初始化它们也会被赋予默认值例如类型的变量默认值为类型的变量默认值为成员变量可以通过对象访问也可以通过类名访问如果它们是静态成员变量如果没有显式初始化成员变量则它们将被赋予默认值可以在构造函数或其他方法中初始化成员变量或者通过对象或类名访问它们并设置它们的值私有成员变量公有成员变量创建对象访问成员变量并设置其值为访问成员变量并设置其值为这个成员变量对子类可见私有变量仅在该类可见在构造器中对赋值设定的值打印信息名字薪水类变量静态变量中的静态变量是指在类中定义的一个变量它与类相关而不是与实例相关即无论创建多少个类实例静态变量在内存中只有一份拷贝被所有实例共享静态变量在类加载时被创建在整个程序运行期间都存在定义方式静态变量的定义方式是在类中使用关键字修饰变量通常也称为类变量以下实例中我们定义一个静态变量其初始值为实例其他成员变量和方法访问方式由于静态变量是与类相关的因此可以通过类名来访问静态变量也可以通过实例名来访问静态变量实例通过类名访问通过实例名访问生命周期静态变量的生命周期与程序的生命周期一样长即它们在类加载时被创建在整个程序运行期间都存在直到程序结束才会被销毁因此静态变量可以用来存储整个程序都需要使用的数据如配置信息全局变量等初始化时机静态变量在类加载时被初始化其初始化顺序与定义顺序有关如果一个静态变量依赖于另一个静态变量那么它必须在后面定义实例其他成员变量和方法上面的例子中要先于初始化否则编译时会报错常量和静态变量的区别常量也是与类相关的但它是用关键字修饰的变量一旦被赋值就不能再修改与静态变量不同的是常量在编译时就已经确定了它的值而静态变量的值可以在运行时改变另外常量通常用于存储一些固定的值如数学常数配置信息等而静态变量通常用于存储可变的数据如计数器全局状态等总之静态变量是与类相关的变量具有唯一性和共享性可以用于存储整个程序都需要使用的数据但需要注意初始化时机和与常量的区别静态变量的访问修饰符静态变量的访问修饰符可以是或者默认的访问修饰符即不写访问修饰符需要注意的是静态变量的访问权限与实例变量不同因为静态变量是与类相关的不依赖于任何实例静态变量的线程安全性中的静态变量是属于类的而不是对象的实例因此当多个线程同时访问一个包含静态变量的类时需要考虑其线程安全性静态变量在内存中只有一份拷贝被所有实例共享因此如果一个线程修改了静态变量的值那么其他线程在访问该静态变量时也会看到修改后的值这可能会导致并发访问的问题因为多个线程可能同时修改静态变量导致不确定的结果或数据一致性问题为了确保静态变量的线程安全性需要采取适当的同步措施如同步机制原子类或关键字以便在多线程环境中正确地读取和修改静态变量的值静态变量的命名规范静态变量的命名规范与实例变量相同一般采用驼峰命名法并且要用关键字明确标识例如实例其他成员变量和方法静态变量的使用场景静态变量通常用于以下场景存储全局状态或配置信息计数器或统计信息缓存数据或共享资源工具类的常量或方法单例模式中的实例变量修饰符语言提供了很多修饰符主要分为以下两类访问修饰符非访问修饰符修饰符用来定义类方法或者变量通常放在语句的最前端我们通过下面的例子来说明方法体访问控制修饰符默认访问修饰符不使用任何关键字如果在类变量方法或构造函数的定义中没有指定任何访问修饰符那么它们就默认具有默认访问修饰符默认访问修饰符的访问级别是包级别即只能被同一包中的其他类访问私有访问修饰符私有访问修饰符是最严格的访问级别所以被声明为的方法变量和构造方法只能被所属类访问并且类和接口不能声明为声明为私有访问类型的变量只能通过类中公共的方法被外部类访问访问修饰符的使用主要用来隐藏类的实现细节和保护类的数据公有访问修饰符被声明为的类方法构造方法和接口能够被任何其他类访问如果几个相互访问的类分布在不同的包中则需要导入相应类所在的包由于类的继承性类所有的公有方法和变量都能被其子类继承受保护的访问修饰符需要从以下两个点来分析说明子类与基类在同一包中被声明为的变量方法和构造器能被同一个包中的任何其他类访问子类与基类不在同一包中那么在子类中子类实例可以访问其从基类继承而来的方法而不能访问基类实例的方法可以修饰数据成员构造方法方法成员不能修饰类内部类除外访问控制和继承请注意以下方法继承的规则父类中声明为的方法在子类中也必须为父类中声明为的方法在子类中要么声明为要么声明为不能声明为父类中声明为的方法不能够被子类继承非访问修饰符为了实现一些其他的功能也提供了许多非访问修饰符修饰符用来修饰类方法和类变量修饰符用来修饰类方法和变量修饰的类不能够被继承修饰的方法不能被继承类重新定义修饰的变量为常量是不可修改的修饰符用来创建抽象类和抽象方法和修饰符主要用于线程的编程修饰符静态变量关键字用来声明独立于对象的静态变量无论一个类实例化多少对象它的静态变量只有一份拷贝静态变量也被称为类变量局部变量不能被声明为变量静态方法关键字用来声明独立于对象的静态方法静态方法不能使用类的非静态变量静态方法从参数列表得到数据然后计算这些数据对类变量和方法的访问可以直接使用和的方式访问修饰符变量表示最后的最终的含义变量一旦赋值后不能被重新赋值被修饰的实例变量必须显式指定初始值修饰符通常和修饰符一起使用来创建类常量方法父类中的方法可以被子类继承但是不能被子类重写声明方法的主要目的是防止该方法的内容被修改类类不能被继承没有类能够继承类的任何特性修饰符抽象类抽象类不能用来实例化对象声明抽象类的唯一目的是为了将来对该类进行扩充一个类不能同时被和修饰如果一个类包含抽象方法那么该类一定要声明为抽象类否则将出现编译错误抽象类可以包含抽象方法和非抽象方法抽象方法抽象方法是一种没有任何实现的方法该方法的具体实现由子类提供抽象方法不能被声明成和任何继承抽象类的子类必须实现父类的所有抽象方法除非该子类也是抽象类如果一个类包含若干个抽象方法那么该类必须声明为抽象类抽象类可以不包含抽象方法抽象方法的声明以分号结尾例如其他修饰运算符计算机的最基本用途之一就是执行数学运算作为一门计算机语言也提供了一套丰富的运算符来操纵变量我们可以把运算符分成以下几组算术运算符关系运算符位运算符逻辑运算符赋值运算符其他运算符算术运算符算术运算符用在数学表达式中它们的作用和在数学中的作用一样下表列出了所有的算术运算符关系运算符下表为支持的关系运算符表格中的实例整数变量的值为变量的值为位运算符定义了位运算符应用于整数类型长整型短整型字符型和字节型等类型逻辑运算符下表列出了逻辑运算符的基本运算假设布尔变量为真变量为假短路逻辑运算符当使用与逻辑运算符时在两个操作数都为时结果才为但是当得到第一个操作为时其结果就必定是这时候就不会再判断第二个操作了定义一个变量使用短路逻辑运算符的结果为的结果为赋值运算符条件运算符条件运算符也被称为三元运算符该运算符有个操作数并且需要判断布尔表达式的值该运算符的主要是决定哪个值应该赋值给变量如果等于成立则设置为否则为如果等于成立则设置为否则为运算符该运算符用于操作对象实例检查该对象是否是一个特定类型类类型或接口类型运算符使用格式如下如果运算符左侧变量所指的对象是操作符右侧类或接口的一个对象那么结果为真下面是一个例子由于是类型所以返回真如果被比较的对象兼容于右侧类型该运算符仍然返回运算符优先级当多个运算符出现在一个表达式中谁先谁后呢这就涉及到运算符的优先级别的问题在一个多运算符的表达式中运算符优先级不同会导致最后得出的结果差别甚大循环结构及顺序结构的程序语句只能被执行一次如果您想要同样的操作执行多次就需要使用循环结构中有三种主要的循环结构循环循环循环在中引入了一种主要用于数组的增强型循环循环是最基本的循环它的结构为布尔表达式循环内容循环对于语句而言如果不满足条件则不能进入循环但有时候我们需要即使不满足条件也至少执行一次循环和循环相似不同的是循环至少会执行一次代码语句布尔表达式循环虽然所有循环结构都可以用或者表示但提供了另一种语句循环使一些循环结构变得更加简单循环执行的次数是在执行前就确定的语法格式如下初始化布尔表达式更新代码语句关于循环有以下几点说明最先执行初始化步骤可以声明一种类型但可初始化一个或多个循环控制变量也可以是空语句然后检测布尔表达式的值如果为循环体被执行如果为循环终止开始执行循环体后面的语句执行一次循环后更新循环控制变量再次检测布尔表达式循环执行上面的过程增强循环引入了一种主要用于数组的增强型循环增强循环语法格式如下声明语句表达式代码句子声明语句声明新的局部变量该变量的类型必须和数组元素的类型匹配其作用域限定在循环语句块其值与此时数组元素的值相等表达式表达式是要访问的数组名或者是返回值为数组的方法实例文件代码以上实例编译运行结果如下关键字主要用在循环语句或者语句中用来跳出整个语句块跳出最里层的循环并且继续执行该循环下面的语句关键字适用于任何循环控制结构中作用是让程序立刻跳转到下一次循环的迭代在循环中语句使程序立即跳转到更新语句在或者循环中程序立即跳转到布尔表达式的判断语句条件语句中的条件语句允许程序根据条件的不同执行不同的代码块一个语句包含一个布尔表达式和一条或多条语句布尔表达式如果布尔表达式为将执行的语句语句语句后面可以跟语句当语句的布尔表达式值为时语句块会被执行语法布尔表达式如果布尔表达式的值为如果布尔表达式的值为语句语句后面可以跟语句这种语句可以检测到多种可能的情况使用语句的时候需要注意下面几点语句至多有个语句语句在所有的语句之后语句可以有若干个语句它们必须在语句之前一旦其中一个语句检测为其他的以及语句都将跳过执行嵌套的语句使用嵌套的语句是合法的也就是说你可以在另一个或者语句中使用或者语句语法嵌套的语法格式如下布尔表达式如果布尔表达式的值为执行代码布尔表达式如果布尔表达式的值为执行代码语句语句判断一个变量与一系列值中某个值是否相等每个值称为一个分支语法语句语法格式如下语句可选语句可选你可以有任意数量的语句可选语句语句有如下规则语句中的变量类型可以是或者从开始支持字符串类型了同时标签必须为字符串常量或字面量语句可以拥有多个语句每个后面跟一个要比较的值和冒号语句中的值的数据类型必须与变量的数据类型相同而且只能是常量或者字面常量当变量的值与语句的值相等时那么语句之后的语句开始执行直到语句出现才会跳出语句当遇到语句时语句终止程序跳转到语句后面的语句执行语句不必须要包含语句如果没有语句出现程序会继续执行下一条语句直到出现语句语句可以包含一个分支该分支一般是语句的最后一个分支可以在任何位置但建议在最后一个在没有语句的值和变量值相等的时候执行分支不需要语句类一般地当需要使用数字的时候我们通常使用内置数据类型如等类的包含了用于执行基本数学运算的属性和方法如初等指数对数平方根和三角函数的方法都被定义为形式通过类可以在主函数中直接调用类方法下面的表中列出的是类常用的一些方法序号方法与描述将对象转换为数据类型的值并返回将对象与参数比较判断对象是否与参数相等返回一个对象指定的内置数据类型以字符串形式返回值将字符串解析为类型返回参数的绝对值返回大于等于给定参数的的最小整数类型为双精度浮点型返回小于等于给定参数的最大整数返回与参数最接近的整数返回类型为它表示四舍五入算法为即将原来的数字加上后再向下取整所以的结果为的结果为返回两个参数中的最小值返回两个参数中的最大值返回自然数底数的参数次方返回参数的自然数底数的对数值返回第一个参数的第二个参数次方求参数的算术平方根求指定类型参数的正弦值求指定类型参数的余弦值求指定类型参数的正切值求指定类型参数的反正弦值求指定类型参数的反余弦值求指定类型参数的反正切值将笛卡尔坐标转换为极坐标并返回极坐标的角度值将参数转化为角度将角度转换为弧度返回一个随机数类类用于对单个字符进行操作类在对象中包装一个基本类型的值转义序列前面有反斜杠的字符代表转义字符它对编译器来说是有特殊含义的下面列表展示了的转义序列转义序列描述在文中该处插入一个键在文中该处插入一个后退键在文中该处换行在文中该处插入回车在文中该处插入换页符在文中该处插入单引号在文中该处插入双引号在文中该处插入反斜杠方法下面是类的方法序号方法与描述是否是一个字母是否是一个数字字符是否是一个空白字符是否是大写字母是否是小写字母指定字母的大写形式指定字母的小写形式返回字符的字符串形式字符串的长度仅为类字符串广泛应用在编程中在中字符串属于对象提供了类来创建和操作字符串创建字符串创建字符串最简单的方式如下在代码中遇到字符串常量时这里的值是编译器会使用该值创建一个对象和其它对象一样可以使用关键字和构造方法来创建对象用构造函数创建字符串创建的字符串存储在公共池中而创建的字符串对象在堆上直接创建直接创建相同引用对象创建对象创建方法下面是类支持的方法更多详细参看文档序号方法描述返回指定索引处的值把这个字符串和另一个对象比较按字典顺序比较两个字符串按字典顺序比较两个字符串不考虑大小写将指定字符串连接到此字符串的结尾当且仅当字符串与指定的有相同顺序的字符时候返回真返回指定数组中表示该字符序列的返回指定数组中表示该字符序列的测试此字符串是否以指定的后缀结束将此字符串与指定的对象比较将此与另一个比较不考虑大小写使用平台的默认字符集将此编码为序列并将结果存储到一个新的数组中使用指定的字符集将此编码为序列并将结果存储到一个新的数组中将字符从此字符串复制到目标字符数组返回此字符串的哈希码返回指定字符在此字符串中第一次出现处的索引返回在此字符串中第一次出现指定字符处的索引从指定的索引开始搜索返回指定子字符串在此字符串中第一次出现处的索引返回指定子字符串在此字符串中第一次出现处的索引从指定的索引开始返回字符串对象的规范化表示形式返回指定字符在此字符串中最后一次出现处的索引返回指定字符在此字符串中最后一次出现处的索引从指定的索引处开始进行反向搜索返回指定子字符串在此字符串中最右边出现处的索引返回指定子字符串在此字符串中最后一次出现处的索引从指定的索引开始反向搜索返回此字符串的长度告知此字符串是否匹配给定的正则表达式测试两个字符串区域是否相等测试两个字符串区域是否相等返回一个新的字符串它是通过用替换此字符串中出现的所有得到的使用给定的替换此字符串所有匹配给定的正则表达式的子字符串使用给定的替换此字符串匹配给定的正则表达式的第一个子字符串根据给定正则表达式的匹配拆分此字符串根据匹配给定的正则表达式来拆分此字符串测试此字符串是否以指定的前缀开始测试此字符串从指定索引开始的子字符串是否以指定前缀开始返回一个新的字符序列它是此序列的一个子序列返回一个新的字符串它是此字符串的一个子字符串返回一个新字符串它是此字符串的一个子字符串将此字符串转换为一个新的字符数组使用默认语言环境的规则将此中的所有字符都转换为小写使用给定的规则将此中的所有字符都转换为小写返回此对象本身它已经是一个字符串使用默认语言环境的规则将此中的所有字符都转换为大写使用给定的规则将此中的所有字符都转换为大写返回字符串的副本忽略前导空白和尾部空白返回给定类型参数的字符串表示形式判断是否包含指定的字符系列判断字符串是否为空和类当对字符串进行修改的时候需要使用和类和类不同的是和类的对象能够被多次的修改并且不产生新的未使用对象在使用类时每次都会对对象本身进行操作而不是生成新的对象所以如果需要对字符串进行修改推荐使用类在中被提出它和之间的最大不同在于的方法不是线程安全的不能同步访问由于相较于有速度优势所以多数情况下建议使用类方法以下是类支持的主要方法序号方法描述将指定的字符串追加到此字符序列将此字符序列用其反转形式取代移除此序列的子字符串中的字符将参数的字符串表示形式插入此序列中将参数的字符串插入此序列中使用给定中的字符替换此序列的子字符串中的字符以下列表列出了类的其他常用方法序号方法描述返回当前容量返回此序列中指定索引处的值确保容量至少等于指定的最小值将字符从此序列复制到目标字符数组返回第一次出现的指定子字符串在该字符串中的索引从指定的索引处开始返回第一次出现的指定子字符串在该字符串中的索引返回最右边出现的指定子字符串在此字符串中的索引返回对象中子字符串最后出现的位置返回长度字符数将给定索引处的字符设置为设置字符序列的长度返回一个新的字符序列该字符序列是此序列的子序列返回一个新的它包含此字符序列当前所包含的字符子序列返回一个新的它包含此序列当前所包含的字符子序列返回此序列中数据的字符串表示形式数组声明数组变量首先必须声明数组变量才能在程序中使用数组下面是声明数组变量的语法首选的方法或效果相同但不是首选方法创建数组语言使用操作符来创建数组语法如下上面的语法语句做了两件事一使用创建了一个数组二把新创建的数组的引用赋值给变量数组变量的声明和创建数组可以用一条语句完成如下所示另外你还可以使用如下的方式创建数组数组的元素是通过索引访问的数组索引从开始所以索引值从到处理数组数组的元素类型和数组的大小都是确定的所以当处理数组元素时候我们通常使用基本循环或者循环打印所有数组元素计算所有元素的总和查找最大元素循环引进了一种新的循环类型被称为循环或者加强型循环它能在不使用下标的情况下遍历数组语法格式如下打印所有数组元素多维数组多维数组可以看成是数组的数组比如二维数组就是一个特殊的一维数组其每一个元素都是一个一维数组例如多维数组的动态初始化以二维数组为例直接为每一维分配空间格式如下可以为基本数据类型和复合数据类型和必须为正整数为行数为列数例如解析二维数组可以看成一个两行三列的数组从最高维开始分别为每一维分配空间例如解析和是为最高维分配引用空间也就是为最高维限制其能保存数据的最长的长度然后再为其每个数组元素单独分配空间等操作类类能方便地操作数组它提供的所有方法都是静态的具有以下功能给数组赋值通过方法对数组排序通过方法按升序比较数组通过方法比较数组中元素值是否相等查找数组元素通过方法能对排序好的数组进行二分查找法操作序号方法和说明用二分查找算法在给定数组中搜索给定值的对象等数组在调用前必须排序好的如果查找值包含在数组中则返回搜索键的索引否则返回插入点如果两个指定的型数组彼此相等则返回如果两个数组包含相同数量的元素并且两个数组中的所有相应元素对都是相等的则认为这两个数组是相等的换句话说如果两个数组以相同顺序包含相同的元素则两个数组是相等的同样的方法适用于所有的其他基本数据类型等将指定的值分配给指定型数组指定范围中的每个元素同样的方法适用于所有的其他基本数据类型等对指定对象数组根据其元素的自然顺序进行升序排列同样的方法适用于所有的其他基本数据类型等日期时间包提供了类来封装当前的日期和时间类提供两个构造函数来实例化对象第一个构造函数使用当前日期和时间来初始化对象第二个构造函数接收一个参数该参数是从年月日起的毫秒数对象创建以后可以调用下面的方法序号方法和描述若当调用此方法的对象在指定日期之后返回否则返回若当调用此方法的对象在指定日期之前返回否则返回返回此对象的副本比较当调用此方法的对象和指定日期两者相等时候返回调用对象在指定日期之前则返回负数调用对象在指定日期之后则返回正数若是类型则操作等同于否则它抛出当调用此方法的对象和指定日期相等时候返回否则返回返回自年月日以来此对象表示的毫秒数返回此对象的哈希码值用自年月日以后毫秒数设置时间和日期把此对象转换为以下形式的其中是一周中的某一天获取当前日期时间中获取当前日期和时间很简单使用对象的方法来打印当前日期和时间如下所示初始化对象使用函数显示日期时间日期比较使用以下三种方法来比较两个日期使用方法获取两个日期自年月日经历的毫秒数值然后比较这两个值使用方法和例如一个月的号比号早则返回使用方法它是由接口定义的类实现了这个接口使用格式化日期是一个以语言环境敏感的方式来格式化和分析日期的类允许你选择任何用户自定义日期时间格式来运行例如当前时间为使用格式化日期方法可以很轻松地格式化时间和日期使用两个字母格式它以开头并且以下面表格中的一个字母结尾输出四位数的年份例如输出两位数的年份例如输出两位数的月份例如输出月份的全名例如输出月份的缩写例如输出星期的全名例如输出星期的缩写例如输出两位数的日期例如输出一位或两位数的日期例如或输出小时制的小时数例如输出小时制的小时数例如输出分钟数例如输出秒数例如输出上午还是下午例如或输出时区例如转换符说明示例包括全部日期和时间信息星期六十月年月日格式月日年格式格式时制下午格式时制格式时制休眠使当前线程进入停滞状态阻塞当前线程让出的使用目的是不让当前线程独自霸占该进程所获的资源以留一定时间给其他线程执行的机会类我们现在已经能够格式化并创建一个日期对象了但是我们如何才能设置和获取日期数据的特定部分呢比如说小时日或者分钟我们又如何在日期的这些部分加上或者减去值呢答案是使用类类的功能要比类强大很多而且在实现方式上也比类要复杂一些类是一个抽象类在实际使用时实现特定的子类的对象创建对象的过程对程序员来说是透明的只需要使用方法创建即可创建一个代表系统当前日期的对象默认是当前日期创建一个指定日期的对象使用类代表特定的时间需要首先创建一个的对象然后再设定该对象中的年月日参数来完成创建一个代表年月日的对象类对象字段类型类中用以下这些常量表示不同的意义内的很多类其实都是采用的这种思想常量描述年份月份日期日期和上面的字段意义完全相同小时制的小时小时制的小时分钟秒星期几类对象信息的获得获得年份获得月份获得日期获得小时获得分钟获得秒获得星期几注意这个与类是不同的代表星期日代表星期代表星期二以此类推初始化日历使用当前时间和日期默认为本地时间和时区显示当前时间和日期的信息测试当前年份是否为闰年当前年份是闰年当前年份不是闰年方法在前面几个章节中我们经常使用到那么它是什么呢是一个方法是系统类是标准输出对象这句话的用法是调用系统类中的标准输出对象中的方法那么什么是方法呢方法是语句的集合它们在一起执行一个功能方法是解决一类问题的步骤的有序组合方法包含于类或对象中方法在程序中被创建在其他地方被引用方法的优点使程序变得更简短而清晰有利于程序维护可以提高程序开发的效率提高了代码的重用性方法的命名规则方法的名字的第一个单词应以小写字母作为开头后面的单词则用大写字母开头写不使用连接符例如下划线可能出现在测试方法名称中用以分隔名称的逻辑组件一个典型的模式是例如方法的定义一般情况下定义一个方法包含以下语法修饰符返回值类型方法名参数类型参数名方法体返回值方法包含一个方法头和一个方法体下面是一个方法的所有部分修饰符修饰符这是可选的告诉编译器如何调用该方法定义了该方法的访问类型返回值类型方法可能会返回值是方法返回值的数据类型有些方法执行所需的操作但没有返回值在这种情况下是关键字方法名是方法的实际名称方法名和参数表共同构成方法签名参数类型参数像是一个占位符当方法被调用时传递值给参数这个值被称为实参或变量参数列表是指方法的参数类型顺序和参数的个数参数是可选的方法可以不包含任何参数方法体方法体包含具体的语句定义该方法的功能方法的重载主方法和比较最大值是返回两个整数变量较大的值上面使用的方法仅仅适用于型数据但如果你想得到两个浮点类型数据的最大值呢解决方法是创建另一个有相同名字但参数不同的方法如下面代码所示如果你调用方法时传递的是型参数则型参数的方法就会被调用如果传递的是型参数则类型的方法体会被调用这叫做方法重载就是说一个类的两个方法拥有相同的名字但是有不同的参数列表编译器根据方法签名判断哪个方法应该被调用方法重载可以让程序更清晰易读执行密切相关任务的方法应该使用相同的名字重载的方法必须拥有不同的参数列表你不能仅仅依据修饰符或者返回类型的不同来重载方法构造方法当一个对象被创建时候构造方法用来初始化该对象构造方法和它所在类的名字相同但构造方法没有返回值通常会使用构造方法给一个类的实例变量赋初值或者执行其它必要的步骤来创建一个完整的对象不管你是否自定义构造方法所有的类都有构造方法因为自动提供了一个默认构造方法默认构造方法的访问修饰符和类的访问修饰符相同类为构造函数也为类改为构造函数也改为一旦你定义了自己的构造方法默认构造方法就会失效方法允许定义这样的方法它在对象被垃圾收集器析构回收之前调用这个方法叫做它用来清除回收对象例如你可以使用来确保一个对象打开的文件被关闭了在方法里你必须指定在对象销毁时候要执行的操作在这里终结代码流文件和包几乎包含了所有操作输入输出需要的类所有这些流类代表了输入源和输出目标包中的流支持很多种格式比如基本类型对象本地化字符集等等一个流可以理解为一个数据的序列输入流表示从一个源读取数据输出流表示向一个目标写数据为提供了强大的而灵活的支持使其更广泛地应用到文件传输和网络编程中但本节讲述最基本的和流与相关的功能我们将通过一个个例子来学习这些功能读取控制台输入的控制台输入由完成为了获得一个绑定到控制台的字符流你可以把包装在一个对象中来创建一个字符流下面是创建的基本语法对象创建后我们便可以使用方法从控制台读取一个字符或者用方法读取一个字符串从控制台读取多字符输入从对象读取一个字符要使用方法它的语法如下每次调用方法它从输入流读取一个字符并把该字符作为整数值返回当流结束的时候返回该方法抛出下面的程序示范了用方法从控制台不断读取字符直到用户输入使用在控制台读取字符使用创建输入字符按下键退出读取字符从控制台读取字符串从标准输入读取一个字符串需要使用的方法它的一般格式是使用在控制台读取字符使用创建控制台输出在此前已经介绍过控制台的输出由和完成这些方法都由类定义是该类对象的一个引用继承了类并且实现了方法这样也可以用来往控制台写操作定义的最简单格式如下所示下面的例子用把字符和紧跟着的换行符输出到屏幕演示该流用于从文件读取数据它的对象可以用关键字来创建有多种构造方法可用来创建对象可以使用字符串类型的文件名来创建一个输入流对象来读取文件也可以使用一个文件对象来创建一个输入流对象来读取文件我们首先得使用方法来创建一个文件对象创建了对象就可以使用下面的方法来读取流或者进行其他的流操作序号方法及描述关闭此文件输入流并释放与此流有关的所有系统资源抛出异常这个方法清除与该文件的连接确保在不再引用文件输入流时调用其方法抛出异常这个方法从对象读取指定字节的数据返回为整数值返回下一字节数据如果已经到结尾则返回这个方法从输入流读取长度的字节返回读取的字节数如果是文件结尾则返回返回下一次对此输入流调用的方法可以不受阻塞地从此输入流读取的字节数返回一个整数值该类用来创建一个文件并向文件中写数据如果该流在打开文件进行输出前目标文件不存在那么该流会创建该文件有两个构造方法可以用来创建对象使用字符串类型的文件名来创建一个输出流对象也可以使用一个文件对象来创建一个输出流来写文件我们首先得使用方法来创建一个文件对象创建对象完成后就可以使用下面的方法来写入流或者进行其他的流操作序号方法及描述关闭此文件输入流并释放与此流有关的所有系统资源抛出异常这个方法清除与该文件的连接确保在不再引用文件输入流时调用其方法抛出异常这个方法把指定的字节写到输出流中把指定数组中长度的字节写到中文件名构建对象文件不存在会自动新建构建对象参数可以指定编码默认为操作系统默认编码上是中文输入写入到缓冲区换行刷新缓存冲写入到文件如果下面已经没有写入的内容了直接也会写入关闭写入流同时会把缓冲区内容写入文件所以上面的注释掉关闭输出流释放系统资源构建对象构建对象编码与写入相同转成加到对象中关闭读取流关闭输入流释放系统资源文件和还有一些关于文件和的类我们也需要知道类类类中的目录创建目录类中有两个方法可以用来创建文件夹方法创建一个文件夹成功则返回失败则返回失败表明对象指定的路径已经存在或者由于整个路径还不存在该文件夹不能被创建方法创建一个文件夹和它的所有父文件夹现在创建目录读取目录一个目录其实就是一个对象它包含其他文件和文件夹如果创建一个对象并且它是一个目录那么调用方法会返回可以通过调用该对象上的方法来提取它包含的文件和文件夹的列表下面展示的例子说明如何使用方法来检查一个文件夹中包含的内容目录是一个目录是一个文件不是一个目录删除目录或文件删除文件可以使用方法以下代码会删除目录需要注意的是当删除某一目录时必须保证该目录下没有其他文件才能正确删除否则将删除失败测试目录结构这里修改为自己的测试目录删除文件及目录类是的新特征我们可以通过类来获取用户的输入下面是创建对象的基本语法使用方法从键盘接收数据方式接收字符串方式接收判断是否还有输入输入的数据为使用方法从键盘接收数据方式接收字符串方式接收判断是否还有输入输入的数据为与区别一定要读取到有效字符后才可以结束输入对输入有效字符之前遇到的空白方法会自动将其去掉只有输入有效字符后才将其后面输入的空白作为分隔符或者结束符不能得到带有空格的字符串以为结束符也就是说方法返回的是输入回车之前的所有字符可以获得空白异常处理异常是程序中的一些错误但并不是所有的错误都是异常并且错误有时候是可以避免的比如说你的代码少了一个分号那么运行出来结果是提示是错误如果你用那么你是因为你用做了除数会抛出的异常异常发生的原因有很多通常包含以下几大类用户输入了非法数据要打开的文件不存在网络通信时连接中断或者内存溢出这些异常有的是因为用户错误引起有的是程序错误引起的还有其它一些是因为物理错误引起的要理解异常处理是如何工作的你需要掌握以下三种类型的异常检查性异常最具代表的检查性异常是用户错误或问题引起的异常这是程序员无法预见的例如要打开一个不存在文件时一个异常就发生了这些异常在编译时不能被简单地忽略运行时异常运行时异常是可能被程序员避免的异常与检查性异常相反运行时异常可以在编译时被忽略错误错误不是异常而是脱离程序员控制的问题错误在代码中通常被忽略例如当栈溢出时一个错误就发生了它们在编译也检查不到的类的层次所有的异常类是从类继承的子类类是类的子类除了类外还有一个子类程序通常不捕获错误错误一般发生在严重故障时它们在程序处理的范畴之外用来指示运行时环境发生的错误例如内存溢出一般地程序不会从错误中恢复异常类有两个主要的子类类和类捕获异常使用和关键字可以捕获异常代码块放在异常可能发生的地方代码块中的代码称为保护代码使用的语法如下程序代码块语句包含要捕获异常类型的声明当保护代码块中发生一个异常时后面的块就会被检查如果发生的异常包含在块中异常会被传递到该块这和传递一个参数到方法是一样关键字在中和关键字是用于处理异常的关键字用于在代码中抛出异常而关键字用于在方法声明中指定可能会抛出的异常类型关键字关键字用于在当前方法中抛出一个异常通常情况下当代码执行到某个条件下无法继续正常执行时可以使用关键字抛出异常以告知调用者当前代码的执行状态例如下面的代码中在方法中判断是否小于如果是则抛出一个异常关键字关键字用于在方法声明中指定该方法可能抛出的异常当方法内部抛出指定类型的异常时该异常会被传递给调用该方法的代码并在该代码中处理异常例如下面的代码中当方法内部发生异常时会将该异常传递给调用该方法的代码在调用该方法的代码中必须捕获或声明处理异常关键字关键字用来创建在代码块后面执行的代码块无论是否发生异常代码块中的代码总会被执行在代码块中可以运行清理类型等收尾善后性质的语句代码块出现在代码块最后语法如下程序代码异常类型异常的变量名程序代码异常类型异常的变量名程序代码程序代码之后新增的语法糖来打开资源并且可以在语句执行完毕后确保每个资源都被自动关闭是一种异常处理机制它可以简化资源管理代码的编写之前所有被打开的系统资源比如流文件或者连接等都需要被开发者手动关闭否则将会造成资源泄露使用的资源异常块以上的语法中用于声明和实例化资源用于处理关闭资源时可能引发的所有异常声明自定义异常在中你可以自定义异常编写自己的异常类时需要记住下面的几点所有异常都必须是的子类如果希望写一个检查性异常类则需要继承类如果你想写一个运行时异常类那么需要继承类可以像下面这样定义自己的异常类只继承类来创建的异常类是检查性异常类下面的类是用户定义的异常类它继承自一个异常类和其它任何类一样包含有变量和方法继承继承的概念继承是面向对象编程技术的一块基石因为它允许创建分等级层次的类继承就是子类继承父类的特征和行为使得子类对象实例具有父类的实例域和方法或子类从父类继承方法使得子类具有父类相同的行为生活中的继承兔子和羊属于食草动物类狮子和豹属于食肉动物类食草动物和食肉动物又是属于动物类所以继承需要符合的关系是父类更通用子类更具体虽然食草动物和食肉动物都是属于动物但是两者的属性和行为上有差别所以子类会具有父类的一般特性也会具有自身的特性类的继承格式在中通过关键字可以申明一个类是从另外一个类继承而来的一般形式如下父类子类父类继承类型需要注意的是不支持多继承但支持多重继承继承的特性子类拥有父类非的属性方法子类可以拥有自己的属性和方法即子类可以对父类进行扩展子类可以用自己的方式实现父类的方法的继承是单继承但是可以多重继承单继承就是一个子类只能继承一个父类多重继承就是例如类继承类类继承类所以按照关系就是类是类的父类类是类的父类这是继承区别于继承的一个特性提高了类之间的耦合性继承的缺点耦合度高就会造成代码之间的联系越紧密代码独立性越差继承关键字继承可以使用和这两个关键字来实现继承而且所有的类都是继承于当一个类没有继承的两个关键字则默认继承这个类在包中所以不需要祖先类关键字在中类的继承是单一继承也就是说一个子类只能拥有一个父类所以只能继承一个类构造器子类是不继承父类的构造器构造方法或者构造函数的它只是调用隐式或显式如果父类的构造器带有参数则必须在子类的构造器中显式地通过关键字调用父类的构造器并配以适当的参数列表如果父类构造器没有参数则在子类的构造器中不需要使用关键字调用父类构造器系统会自动调用父类的无参构造器类继承自动调用父类的无参数构造器调用父类中带有参数的构造器类继承调用父类中带有参数的构造器自动调用父类的无参数构造器类继承类继承重写与重载重写重写是子类对父类的允许访问的方法的实现过程进行重新编写返回值和形参都不能改变即外壳不变核心重写重写的好处在于子类可以根据需要定义特定于自己的行为也就是说子类能够根据需要实现父类的方法重写方法不能抛出新的检查异常或者比被重写方法申明更加宽泛的异常例如父类的一个方法申明了一个检查异常但是在重写这个方法的时候不能抛出异常因为是的父类抛出异常或者的子类异常在面向对象原则里重写意味着可以重写任何现有方法实例如下动物可以移动狗可以跑和走对象对象执行类的方法执行类的方法方法的重写规则参数列表与被重写方法的参数列表必须完全相同返回类型与被重写方法的返回类型可以不相同但是必须是父类返回值的派生类及更早版本返回类型要一样及更高版本可以不同访问权限不能比父类中被重写的方法的访问权限更低例如如果父类的一个方法被声明为那么在子类中重写该方法就不能声明为父类的成员方法只能被它的子类重写声明为的方法不能被重写声明为的方法不能被重写但是能够被再次声明子类和父类在同一个包中那么子类可以重写父类所有方法除了声明为和的方法子类和父类不在同一个包中那么子类只能够重写父类的声明为和的非方法重写的方法能够抛出任何非强制异常无论被重写的方法是否抛出异常但是重写的方法不能抛出新的强制性异常或者比被重写方法声明的更广泛的强制性异常反之则可以构造方法不能被重写如果不能继承一个类则不能重写该类的方法重载重载是在一个类里面方法名字相同而参数不同返回类型可以相同也可以不同每个重载的方法或者构造函数都必须有一个独一无二的参数类型列表最常用的地方就是构造器的重载重载规则被重载的方法必须改变参数列表参数个数或类型不一样被重载的方法可以改变返回类型被重载的方法可以改变访问修饰符被重载的方法可以声明新的或更广的检查异常方法能够在同一个类中或者在一个子类中被重载无法以返回值类型作为重载函数的区分标准重写与重载之间的区别区别点重载方法重写方法参数列表必须修改一定不能修改返回类型可以修改一定不能修改异常可以修改可以减少或删除一定不能抛出新的或者更广的异常访问可以修改一定不能做更严格的限制可以降低限制总结方法的重写和重载是多态性的不同表现重写是父类与子类之间多态性的一种表现重载可以理解成多态的具体表现形式方法重载是一个类中定义了多个方法名相同而他们的参数的数量不同或数量相同而类型和次序不同则称为方法的重载方法重写是在子类存在方法与父类的方法的名字相同而且参数的个数与类型一样返回值也一样的方法就称为重写方法重载是一个类的多态性表现而方法重写是子类与父类的一种多态性表现多态多态是同一个行为具有多个不同表现形式或形态的能力多态就是同一个接口使用不同的实例而执行不同操作如图所示多态的优点消除类型之间的耦合关系可替换性可扩充性接口性灵活性简化性多态存在的三个必要条件继承重写父类引用指向子类对象多态的实现方式方式一重写这个内容已经在上一章节详细讲过就不再阐述详细可访问重写与重载方式二接口生活中的接口最具代表性的就是插座例如一个三接头的插头都能接在三孔插座中因为这个是每个国家都有各自规定的接口规则有可能到国外就不行那是因为国外自己定义的接口类型中的接口类似于生活中的接口就是一些方法特征的集合但没有方法的实现具体可以看接口这一章节的内容方式三抽象类和抽象方法抽象类在面向对象的概念中所有的对象都是通过类来描绘的但是反过来并不是所有的类都是用来描绘对象的如果一个类中没有包含足够的信息来描绘一个具体的对象这样的类就是抽象类抽象类除了不能实例化对象之外类的其它功能依然存在成员变量成员方法和构造方法的访问方式和普通类一样由于抽象类不能实例化对象所以抽象类必须被继承才能被使用也是因为这个原因通常在设计阶段决定要不要设计抽象类父类包含了子类集合的常见的方法但是由于父类本身是抽象的所以不能使用这些方法在中抽象类表示的是一种继承关系一个类只能继承一个抽象类而一个类却可以实现多个接口抽象类在语言中使用来定义抽象类如下实例文件名抽象方法如果你想设计这样一个类该类包含一个特别的成员方法该方法的具体实现由它的子类确定那么你可以在父类中声明该方法为抽象方法关键字同样可以用来声明抽象方法抽象方法只包含一个方法名而没有方法体抽象方法没有定义方法名后面直接跟一个分号而不是花括号声明抽象方法会造成以下两个结果如果一个类包含抽象方法那么该类必须是抽象类任何子类必须重写父类的抽象方法或者声明自身为抽象类继承抽象方法的子类必须重写该方法否则该子类也必须声明为抽象类最终必须有子类实现该抽象方法否则从最初的父类到最终的子类都不能用来实例化对象抽象类总结规定抽象类不能被实例化初学者很容易犯的错如果被实例化就会报错编译无法通过只有抽象类的非抽象子类可以创建对象抽象类中不一定包含抽象方法但是有抽象方法的类必定是抽象类抽象类中的抽象方法只是声明不包含方法体就是不给出方法的具体实现也就是方法的具体功能构造方法类方法用修饰的方法不能声明为抽象方法抽象类的子类必须给出抽象类中的抽象方法的具体实现除非该子类也是抽象类封装在面向对象程式设计方法中封装英语是指一种将抽象性函式接口的实现细节部分包装隐藏起来的方法封装可以被认为是一个保护屏障防止该类的代码和数据被外部类定义的代码随机访问要访问该类的代码和数据必须通过严格的接口控制封装最主要的功能在于我们能修改自己的实现代码而不用修改那些调用我们代码的程序片段适当的封装可以让程式码更容易理解与维护也加强了程式码的安全性封装的优点良好的封装能够减少耦合类内部的结构可以自由修改可以对成员变量进行更精确的控制隐藏信息实现细节接口接口英文在编程语言中是一个抽象类型是抽象方法的集合接口通常以来声明一个类通过继承接口的方式从而来继承接口的抽象方法接口并不是类编写接口的方式和类很相似但是它们属于不同的概念类描述对象的属性和方法接口则包含类要实现的方法除非实现接口的类是抽象类否则该类要定义接口中的所有方法接口无法被实例化但是可以被实现一个实现接口的类必须实现接口内所描述的所有方法否则就必须声明为抽象类另外在中接口类型可用来声明一个变量他们可以成为一个空指针或是被绑定在一个以此接口实现的对象接口与类相似点一个接口可以有多个方法接口文件保存在结尾的文件中文件名使用接口名接口的字节码文件保存在结尾的文件中接口相应的字节码文件必须在与包名称相匹配的目录结构中接口与类的区别接口不能用于实例化对象接口没有构造方法接口中所有的方法必须是抽象方法之后接口中可以使用关键字修饰的非抽象方法接口不能包含成员变量除了和变量接口不是被类继承了而是要被类实现接口支持多继承接口特性接口中每一个方法也是隐式抽象的接口中的方法会被隐式的指定为只能是其他修饰符都会报错接口中可以含有变量但是接口中的变量会被隐式的指定为变量并且只能是用修饰会报编译错误接口中的方法是不能在接口中实现的只能由实现接口的类来实现接口中的方法抽象类和接口的区别抽象类中的方法可以有方法体就是能实现方法的具体功能但是接口中的方法不行抽象类中的成员变量可以是各种类型的而接口中的成员变量只能是类型的接口中不能含有静态代码块以及静态方法用修饰的方法而抽象类是可以有静态代码块和静态方法一个类只能继承一个抽象类而一个类却可以实现多个接口注以后接口里可以有静态方法和方法体了注以后接口允许包含具体实现的方法该方法称为默认方法默认方法使用关键字修饰更多内容可参考默认方法注以后允许将方法定义为使得某些复用的代码不会把方法暴露出去更多内容可参考私有接口方法接口有以下特性接口是隐式抽象的当声明一个接口的时候不必使用关键字接口中每一个方法也是隐式抽象的声明时同样不需要关键字接口中的方法都是公有的重写接口中声明的方法时需要注意以下规则类在实现接口的方法时不能抛出强制性异常只能在接口中或者继承接口的抽象类中抛出该强制性异常类在重写方法时要保持一致的方法名并且应该保持相同或者相兼容的返回值类型如果实现接口的类是抽象类那么就没必要实现该接口的方法在实现接口的时候也要注意一些规则一个类可以同时实现多个接口一个类只能继承一个类但是能实现多个接口一个接口能继承另一个接口这和类之间的继承比较相似标记接口最常用的继承接口是没有包含任何方法的接口标记接口是没有任何方法和属性的接口它仅仅表明它的类属于一个特定的类型供其他代码来测试允许做一些事情标记接口作用简单形象的说就是给某个对象打个标盖个戳使对象拥有某个或某些特权例如包中的接口继承的接口定义如下没有任何方法的接口被称为标记接口标记接口主要用于以下两种目的建立一个公共的父接口正如接口这是由几十个其他接口扩展的你可以使用一个标记接口来建立一组接口的父接口例如当一个接口继承了接口虚拟机就知道该接口将要被用于一个事件的代理方案向一个类添加数据类型这种情况是标记接口最初的目的实现标记接口的类不需要定义任何接口方法因为标记接口根本就没有方法但是该类通过多态性变成一个接口类型枚举枚举是一个特殊的类一般表示一组常量比如一年的个季节一年的个月份一个星期的天方向有东南西北等枚举类使用关键字来定义各个常量使用逗号来分割例如定义一个颜色的枚举类和方法定义的枚举类默认继承了类并实现了和两个接口和方法位于类中返回枚举类中所有的值方法可以找到每个枚举常量的索引就像数组索引一样方法返回指定字符串值的枚举常量包为了更好地组织类提供了包机制用于区别类名的命名空间包的作用把功能相似或相关的类或接口组织在同一个包中方便类的查找和使用如同文件夹一样包也采用了树形目录的存储方式同一个包中的类名字是不同的不同的包中的类的名字是可以相同的当同时调用两个不同包中相同类名的类时应该加上包名加以区别因此包可以避免名字冲突包也限定了访问权限拥有包访问权限的类才能访问某个包中的类使用包这种机制是为了防止命名冲突访问控制提供搜索和定位类接口枚举和注释等一个包可以定义为一组相互联系的类型类接口枚举和注释为这些类型提供访问保护和命名空间管理的功能以下是一些中的包打包基础的类包含输入输出功能的函数开发者可以自己把一组类和接口等打包并定义自己的包而且在实际开发中这样做是值得提倡的当你自己完成类的实现之后将相关的类分组可以让其他的编程者更容易地确定哪些类接口枚举和注释等是相关的由于包创建了新的命名空间所以不会跟其他包中的任何名字产生命名冲突使用包这种机制更容易实现访问控制并且让定位相关类更加简单创建包创建包的时候你需要为这个包取一个合适的名字之后如果其他的一个源文件包含了这个包提供的类接口枚举或者注释类型的时候都必须将这个包的声明放在这个源文件的开头包声明应该在源文件的第一行每个源文件只能有一个包声明这个文件中的每个类型都应用于它如果一个源文件中没有使用包声明那么其中的类函数枚举注释等将被放在一个无名的包中关键字为了能够使用某一个包的成员我们需要在程序中明确导入该包在中关键字用于导入其他类或包中定义的类型以便在当前源文件中使用这些类型关键字用于引入其他包中的类接口或静态成员它允许你在代码中直接使用其他包中的类而不需要完整地指定类的包名集合框架早在中之前就提供了特设类比如和这些类用来存储和操作对象组虽然这些类都非常有用但是它们缺少一个核心的统一的主题由于这个原因使用类的方式和使用类的方式有着很大不同集合框架被设计成要满足以下几个目标该框架必须是高性能的基本集合动态数组链表树哈希表的实现也必须是高效的该框架允许不同类型的集合以类似的方式工作具有高度的互操作性对一个集合的扩展和适应必须是简单的为此整个集合框架就围绕一组标准接口而设计你可以直接使用这些接口的标准实现诸如和等除此之外你也可以通过这些接口实现自己的集合从上面的集合框架图可以看到集合框架主要包括两种类型的容器一种是集合存储一个元素集合另一种是图存储键值对映射接口又有种子类型和再下面是一些抽象类最后是具体实现类常用的有等等集合框架是一个用来代表和操纵集合的统一架构所有的集合框架都包含如下内容接口是代表集合的抽象数据类型例如等之所以定义多个接口是为了以不同的方式操作集合对象实现类是集合接口的具体实现从本质上讲它们是可重复使用的数据结构例如算法是实现集合接口的对象里的方法执行的一些有用的计算例如搜索和排序这些算法实现了多态那是因为相同的方法可以在相似的接口上有着不同的实现除了集合该框架也定义了几个接口和类里存储的是键值对尽管不是集合但是它们完全整合在集合中集合接口集合框架定义了一些接口本节提供了每个接口的概述序号接口描述接口是最基本的集合接口一个代表一组即的元素不提供直接继承自的类只提供继承于的子接口如和接口存储一组不唯一无序的对象接口接口是一个有序的使用此接口能够精确的控制每个元素插入的位置能够通过索引元素在中位置类似于数组的下标来访问中的元素第一个元素的索引为而且允许有相同的元素接口存储一组不唯一有序插入顺序的对象具有与完全一样的接口只是行为上不同不保存重复的元素接口存储一组唯一无序的对象继承于保存有序的集合接口存储一组键值对象提供键到值的映射描述在一个中的一个元素键值对是一个的内部接口继承于使保持在升序排列这是一个传统的接口和定义的方法通过它可以枚举一次获得一个对象集合中的元素这个传统接口已被迭代器取代和的区别接口实例存储的是无序的不重复的数据接口实例存储的是有序的可以重复的元素检索效率低下删除和插入效率高插入和删除不会引起元素位置改变实现类有和数组类似可以动态增长根据实际存储的数据的长度自动增长的长度查找元素效率高插入删除效率低因为会引起其他元素位置改变实现类有如何使用迭代器通常情况下你会希望遍历一个集合中的元素例如显示集合中的每个元素一般遍历数组都是采用循环或者增强这两个方法也可以用在集合框架但是还有一种方法是采用迭代器遍历集合框架它是一个对象实现了接口或接口迭代器使你能够通过循环来得到或删除集合的元素继承了以允许双向遍历列表和修改元素序号迭代器方法描述使用这里通过实例列出和接口提供的所有方法第一种遍历方法使用遍历也可以改写这种形式第二种遍历把链表变为数组相关的内容进行遍历这里也可以改写为这种形式第三种遍历使用迭代器进行相关遍历判断下一个元素之后有值第一种普遍使用二次取值通过遍历和第二种通过使用遍历和第三种推荐尤其是容量大时通过遍历和第四种通过遍历所有的但不能遍历总结集合框架为程序员提供了预先包装的数据结构和算法来操纵他们集合是一个对象可容纳其他对象的引用集合接口声明对每一种类型的集合可以执行的操作集合框架的类和接口均在包中任何对象加入集合类后自动转变为类型所以在取出的时候需要进行强制类型转换方法常用方法列表如下方法描述将元素插入到指定位置的中添加集合中的所有元素到中删除中的所有元素复制一份判断元素是否在通过索引值获取中的元素返回中元素的索引值删除存在于指定集合中的里的所有元素删除里的单个元素返回里元素数量判断是否为空截取部分的元素替换中指定索引的元素对元素进行排序将转换为数组将转换为字符串设置指定容量大小的返回指定元素在中最后一次出现的位置保留中在指定集合中也存在的那些元素查看是否包含指定集合中的所有元素将中的容量调整为数组中的元素个数删除中指定索引之间存在的元素将给定的操作内容替换掉数组中每一个元素删除所有满足特定条件的元素遍历中每一个元素并执行特定操作链表是一种常见的基础数据结构是一种线性表但是并不会按线性的顺序存储数据而是在每一个节点里存到下一个节点的地址链表可分为单向链表和双向链表一个单向链表包含两个值当前节点的值和一个指向下一个节点的链接一个双向链表有三个整数值数值向后的节点链接向前的节点链接链表类似于是一种常用的数据容器与相比的增加和删除的操作效率更高而查找和修改的操作效率较低以下情况使用频繁访问列表中的某一个元素只需要在列表末尾进行添加和删除元素操作以下情况使用你需要通过循环迭代来访问列表中的某些元素需要频繁的在列表开头中间末尾等位置进行添加和删除元素操作继承了类实现了接口可作为队列使用实现了接口可进行列表的相关操作实现了接口可作为队列使用实现了接口可实现克隆实现了接口即可支持序列化能通过序列化去传输常用方法方法描述链表末尾添加元素返回是否成功成功为失败为向指定位置插入元素将一个集合的所有元素添加到链表后面返回是否成功成功为失败为将一个集合的所有元素添加到链表的指定位置后面返回是否成功成功为失败为元素添加到头部元素添加到尾部向链表末尾添加元素返回是否成功成功为失败为头部插入元素返回是否成功成功为失败为尾部插入元素返回是否成功成功为失败为清空链表删除并返回第一个元素删除并返回最后一个元素删除某一元素返回是否成功成功为失败为删除指定位置的元素删除并返回第一个元素删除并返回第一个元素判断是否含有某一元素返回指定位置的元素返回第一个元素返回最后一个元素查找指定元素从前往后第一次出现的索引查找指定元素最后一次出现的索引返回第一个元素返回第一个元素返回头部元素返回尾部元素设置指定位置的元素克隆该列表返回倒序迭代器返回链表元素个数返回从指定位置开始到末尾的迭代器返回一个由链表元素组成的数组返回一个由链表元素转换类型而成的数组基于来实现的是一个不允许有重复元素的集合允许有值是无序的即不会记录插入的顺序不是线程安全的如果多个线程尝试同时修改则最终结果是不确定的您必须在多线程访问时显式同步对的并发访问实现了接口是一个散列表它存储的内容是键值对映射实现了接口根据键的值存储数据具有很快的访问速度最多允许一条记录的键为不支持线程同步是无序的即不会记录插入的顺序继承于实现了接口方法常用方法列表如下方法描述删除中的所有键值对复制一份判断是否为空计算中键值对的数量将键值对添加到中将所有键值对添加到中如果中不存在指定的键则将指定的键值对插入到中删除中指定键的映射关系检查中是否存在指定的对应的映射关系检查中是否存在指定的对应的映射关系替换中是指定的对应的将中的所有映射关系替换成给定的函数所执行的结果获取指定对应对获取指定对应对如果找不到则返回设置的默认值对中的每个映射执行指定的操作返回中所有映射项的集合集合视图返回中所有组成的集合视图返回中存在的所有值添加键值对到中对中指定的值进行重新计算对中指定的值进行重新计算如果不存在这个则添加到中对中指定的值进行重新计算前提是该存在于中迭代器迭代器是集合框架中的一种机制是一种用于遍历集合如列表集合和映射等的接口它提供了一种统一的方式来访问集合中的元素而不需要了解底层集合的具体实现细节迭代器不是一个集合它是一种用于访问集合的方法可用于迭代和等集合是迭代器最简单的实现是中的接口它扩展了接口迭代器接口定义了几个方法最常用的是以下三个返回迭代器的下一个元素并将迭代器的指针移到下一个位置用于判断集合中是否还有下一个元素可以访问从集合中删除迭代器最后访问的元素可选操作获取一个迭代器集合想获取一个迭代器可以使用方法引入和类创建集合获取迭代器输出集合中的第一个元素引入和类创建集合获取迭代器输出集合中的所有元素类类是所有类的父类也就是说的所有类都继承了子类可以使用的所有方法类位于包中编译时会自动导入我们创建一个类时如果没有明确继承一个父类那么它就会自动继承成为的子类类可以显式继承也可以隐式继承以下两种方式是一样的显式继承隐式继承类的构造函数序号构造方法描述构造一个新对象类的方法序号方法描述创建并返回一个对象的拷贝比较两个对象是否相等当垃圾回收器确定不存在对该对象的有更多引用时由对象的垃圾回收器调用此方法获取对象的运行时对象的类获取对象的值唤醒在该对象上等待的某个线程唤醒在该对象上等待的所有线程返回对象的字符串表示形式让当前线程进入等待状态直到其他线程调用此对象的方法或方法让当前线程处于等待阻塞状态直到其他线程调用此对象的方法或方法或者超过参数设置的超时时间与方法类似多了一个参数这个参数表示额外时间以纳秒为单位范围是所以超时的时间还需要加上纳秒泛型泛型是中引入的一个新特性泛型提供了编译时类型安全检测机制该机制允许程序员在编译时检测到非法的类型泛型的本质是参数化类型也就是说所操作的数据类型被指定为一个参数假定我们有这样一个需求写一个排序方法能够对整型数组字符串数组甚至其他任何类型的数组进行排序该如何实现答案是可以使用泛型使用泛型的概念我们可以写一个泛型方法来对一个对象数组排序然后调用该泛型方法来对整型数组浮点数数组字符串数组等进行排序泛型方法你可以写一个泛型方法该方法在调用时可以接收不同类型的参数根据传递给泛型方法的参数类型编译器适当地处理每一个方法调用下面是定义泛型方法的规则所有泛型方法声明都有一个类型参数声明部分由尖括号分隔该类型参数声明部分在方法返回类型之前在下面例子中的每一个类型参数声明部分包含一个或多个类型参数参数间用逗号隔开一个泛型参数也被称为一个类型变量是用于指定一个泛型类型名称的标识符类型参数能被用来声明返回值类型并且能作为泛型方法得到的实际参数类型的占位符泛型方法体的声明和其他方法一样注意类型参数只能代表引用型类型不能是原始类型像等中泛型标记符在集合中使用因为集合中存放的是元素类键值数值类型表示不确定的类型下面的例子演示了如何使用泛型方法打印不同类型的数组元素泛型方法输出数组元素创建不同类型数组和整型数组元素为传递一个整型数组双精度型数组元素为传递一个双精度型数组字符型数组元素为传递一个字符型数组泛型类泛型类的声明和非泛型类的声明类似除了在类名后面添加了类型参数声明部分和泛型方法一样泛型类的类型参数声明部分也包含一个或多个类型参数参数间用逗号隔开一个泛型参数也被称为一个类型变量是用于指定一个泛型类型名称的标识符因为他们接受一个或多个参数这些类被称为参数化的类或参数化的类型实例如下实例演示了我们如何定义一个泛型类菜鸟教程整型值为字符串为类型通配符类型通配符一般是使用代替具体的类型参数例如在逻辑上是等所有具体类型实参的父类类型通配符上限通过形如来定义如此定义就是通配符泛型值接受及其下层子类类型类型通配符下限通过形如来定义表示类型只能接受及其上层父类类型如类型的实例序列化序列化是一种将对象转换为字节流的过程以便可以将对象保存到磁盘上将其传输到网络上或者将其存储在内存中以后再进行反序列化将字节流重新转换为对象序列化在中是通过接口来实现的该接口没有任何方法只是一个标记接口用于标识类可以被序列化当你序列化对象时你把它包装成一个特殊文件可以保存传输或存储反序列化则是打开这个文件读取序列化的数据然后将其还原为对象以便在程序中使用序列化是一种用于保存传输和还原对象的方法它使得对象可以在不同的计算机之间移动和共享这对于分布式系统数据存储和跨平台通信非常有用以下是序列化的基本概念和用法实现接口要使一个类可序列化需要让该类实现接口这告诉编译器这个类可以被序列化例如类的成员和方法网络编程网络编程是指编写运行在多个设备计算机的程序这些设备都通过网络连接起来包中的包含有类和接口它们提供低层次的通信细节你可以直接使用这些类和接口来专注于解决问题而不用关注通信细节包中提供了两种常见的网络协议的支持英语传输控制协议是一种面向连接的可靠的基于字节流的传输层通信协议层是位于层之上应用层之下的中间层保障了两个应用程序之间的可靠通信通常用于互联网协议被称英语用户数据报协议位于模型的传输层一个无连接的协议提供了应用程序之间要发送数据的数据报由于缺乏可靠性且属于无连接协议所以应用程序通常必须容许一些丢失错误或重复的数据包本教程主要讲解以下两个主题编程这是使用最广泛的网络概念它已被解释地非常详细处理这部分会在另外的篇幅里讲点击这里更详细地了解在语言中的处理编程套接字使用提供了两台计算机之间的通信机制客户端程序创建一个套接字并尝试连接服务器的套接字当连接建立时服务器会创建一个对象客户端和服务器现在可以通过对对象的写入和读取来进行通信类代表一个套接字并且类为服务器程序提供了一种来监听客户端并与他们建立连接的机制以下步骤在两台计算机之间使用套接字建立连接时会出现服务器实例化一个对象表示通过服务器上的端口通信服务器调用类的方法该方法将一直等待直到客户端连接到服务器上给定的端口服务器正在等待时一个客户端实例化一个对象指定服务器名称和端口号来请求连接类的构造函数试图将客户端连接到指定的服务器和端口号如果通信被建立则在客户端创建一个对象能够与服务器进行通信在服务器端方法返回服务器上一个新的引用该连接到客户端的连接建立后通过使用流在进行通信每一个都有一个输出流和一个输入流客户端的输出流连接到服务器端的输入流而客户端的输入流连接到服务器端的输出流是一个双向的通信协议因此数据可以通过两个数据流在同一时间发送以下是一些类提供的一套完整的有用的方法来实现类的方法类代表客户端和服务器都用来互相沟通的套接字客户端要获取一个对象通过实例化而服务器获得一个对象则通过方法的返回值类有五个构造方法序号方法描述创建一个流套接字并将其连接到指定主机上的指定端口号创建一个流套接字并将其连接到指定地址的指定端口号创建一个套接字并将其连接到指定远程主机上的指定远程端口创建一个套接字并将其连接到指定远程地址上的指定远程端口通过系统默认类型的创建未连接套接字客户端实例如下的是一个客户端程序该程序通过连接到服务器并发送一个请求然后等待一个响应文件名连接到主机端口号远程主机地址服务器响应服务端实例如下的程序是一个服务器端应用程序使用来监听一个指定的端口文件名等待远程连接端口号为远程主机地址谢谢连接我多线程编程给多线程编程提供了内置的支持一条线程指的是进程中一个单一顺序的控制流一个进程中可以并发多个线程每条线程并行执行不同的任务多线程是多任务的一种特别的形式但多线程使用了更小的资源开销这里定义和线程相关的另一个术语进程一个进程包括由操作系统分配的内存空间包含一个或多个线程一个线程不能独立的存在它必须是进程的一部分一个进程一直运行直到所有的非守护线程都结束运行后才能结束多线程能满足程序员编写高效率的程序来达到充分利用的目的一个线程的生命周期线程是一个动态执行的过程它也有一个从产生到死亡的过程下图显示了一个线程完整的生命周期新建状态使用关键字和类或其子类建立一个线程对象后该线程对象就处于新建状态它保持这个状态直到程序这个线程就绪状态当线程对象调用了方法之后该线程就进入就绪状态就绪状态的线程处于就绪队列中要等待里线程调度器的调度运行状态如果就绪状态的线程获取资源就可以执行此时线程便处于运行状态处于运行状态的线程最为复杂它可以变为阻塞状态就绪状态和死亡状态阻塞状态如果一个线程执行了睡眠挂起等方法失去所占用资源之后该线程就从运行状态进入阻塞状态在睡眠时间已到或获得设备资源后可以重新进入就绪状态可以分为三种等待阻塞运行状态中的线程执行方法使线程进入到等待阻塞状态同步阻塞线程在获取同步锁失败因为同步锁被其他线程占用其他阻塞通过调用线程的或发出了请求时线程就会进入到阻塞状态当状态超时等待线程终止或超时或者处理完毕线程重新转入就绪状态死亡状态一个运行状态的线程完成任务或者其他终止条件发生时该线程就切换到终止状态线程的优先级每一个线程都有一个优先级这样有助于操作系统确定线程的调度顺序线程的优先级是一个整数其取值范围是默认情况下每一个线程都会分配一个优先级具有较高优先级的线程对程序更重要并且应该在低优先级的线程之前分配处理器资源但是线程优先级不能保证线程执行的顺序而且非常依赖于平台创建一个线程提供了三种创建线程的方法通过实现接口通过继承类本身通过和创建线程通过和创建线程创建接口的实现类并实现方法该方法将作为线程执行体并且有返回值创建实现类的实例使用类来包装对象该对象封装了该对象的方法的返回值使用对象作为对象的创建并启动新线程调用对象的方法来获得子线程执行结束后的返回值创建线程的三种方式的对比采用实现接口的方式创建多线程时线程类只是实现了接口或接口还可以继承其他类使用继承类的方式创建多线程时编写简单如果需要访问当前线程则无需使用方法直接使用即可获得当前线程线程的几个主要概念在多线程编程时你需要了解以下几个概念线程同步线程间通信线程死锁线程控制挂起停止和恢复多线程的使用有效利用多线程的关键是理解程序是并发执行而不是串行执行的例如程序中有两个子系统需要并发执行这时候就需要利用多线程编程通过对多线程的使用可以编写出非常高效的程序不过请注意如果你创建太多的线程程序执行的效率实际上是降低了而不是提升了请记住上下文的切换开销也很重要如果你创建了太多的线程花费在上下文的切换的时间将多于执行程序的时间文档注释支持三种注释方式前两种分别是和第三种被称作说明注释它以开始以结束说明注释允许你在程序中嵌入关于程序的信息你可以使用工具软件来生成信息并输出到文件中说明注释使你更加方便的记录你的程序信息标签工具软件识别以下标签标签描述示例标识一个类的作者指名一个过期的类或成员指明当前文档根目录的路径标志一个类抛出的异常从直接父类继承的注释插入一个到另一个主题的链接插入一个到另一个主题的链接但是该链接显示纯文本字体说明一个方法的参数说明返回值类型指定一个到另一个主题的链接说明一个序列化属性说明通过和方法写的数据说明一个组件标记当引入一个特定的变化时和标签一样显示常量的值该常量必须是属性指定类的版本',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-10-18 19:00:00',
  postMainColor: '',
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#18171d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#f7f9fe')
        }
      }
      const t = saveToLocal.get('theme')
    
          const isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
          const isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
          const isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
          const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

          if (t === undefined) {
            if (isLightMode) activateLightMode()
            else if (isDarkMode) activateDarkMode()
            else if (isNotSpecified || hasNoSupport) {
              const now = new Date()
              const hour = now.getHours()
              const isNight = hour <= 6 || hour >= 18
              isNight ? activateDarkMode() : activateLightMode()
            }
            window.matchMedia('(prefers-color-scheme: dark)').addListener(e => {
              if (saveToLocal.get('theme') === undefined) {
                e.matches ? activateDarkMode() : activateLightMode()
              }
            })
          } else if (t === 'light') activateLightMode()
          else activateDarkMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.3.0"></head><body data-type="anzhiyu"><div id="web_bg"></div><div id="an_music_bg"></div><div id="loading-box" onclick="document.getElementById(&quot;loading-box&quot;).classList.add(&quot;loaded&quot;)"><div class="loading-bg"><img class="loading-img nolazyload" alt="加载头像" src="https://s2.loli.net/2022/11/07/QVWvrnAsuGxelbS.jpg"/><div class="loading-image-dot"></div></div></div><script>const preloader = {
  endLoading: () => {
    document.getElementById('loading-box').classList.add("loaded");
  },
  initLoading: () => {
    document.getElementById('loading-box').classList.remove("loaded")
  }
}
window.addEventListener('load',()=> { preloader.endLoading() })
setTimeout(function(){preloader.endLoading();},10000)

if (true) {
  document.addEventListener('pjax:send', () => { preloader.initLoading() })
  document.addEventListener('pjax:complete', () => { preloader.endLoading() })
}</script><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.1.10/progress_bar/progress_bar.css"/><script async="async" src="https://cdn.cbd.int/pace-js@1.2.4/pace.min.js" data-pace-options="{ &quot;restartOnRequestAfter&quot;:false,&quot;eventLag&quot;:false}"></script><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><div id="nav-group"><span id="blog_name"><a id="site-name" href="/" accesskey="h"><div class="title">Wsk Blog</div><i class="anzhiyufont anzhiyu-icon-house-chimney"></i></a></span><div class="mask-name-container"><div id="name-container"><a id="page-name" href="javascript:anzhiyu.scrollToDest(0, 500)">PAGE_NAME</a></div></div><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 文章</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/archives/"><i class="anzhiyufont anzhiyu-icon-box-archive faa-tada" style="font-size: 0.9em;"></i><span> 隧道</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/categories/"><i class="anzhiyufont anzhiyu-icon-shapes faa-tada" style="font-size: 0.9em;"></i><span> 分类</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/tags/"><i class="anzhiyufont anzhiyu-icon-tags faa-tada" style="font-size: 0.9em;"></i><span> 标签</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 友链</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/link/"><i class="anzhiyufont anzhiyu-icon-link faa-tada" style="font-size: 0.9em;"></i><span> 友人帐</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/fcircle/"><i class="anzhiyufont anzhiyu-icon-artstation faa-tada" style="font-size: 0.9em;"></i><span> 朋友圈</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/comments/"><i class="anzhiyufont anzhiyu-icon-envelope faa-tada" style="font-size: 0.9em;"></i><span> 留言板</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 我的</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/music/?id=2898229193&amp;server=netease"><i class="anzhiyufont anzhiyu-icon-music faa-tada" style="font-size: 0.9em;"></i><span> 音乐馆</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/album/"><i class="anzhiyufont anzhiyu-icon-images faa-tada" style="font-size: 0.9em;"></i><span> 相册集</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/air-conditioner/"><i class="anzhiyufont anzhiyu-icon-fan faa-tada" style="font-size: 0.9em;"></i><span> 小空调</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 关于</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/about/"><i class="anzhiyufont anzhiyu-icon-paper-plane faa-tada" style="font-size: 0.9em;"></i><span> 关于本人</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/essay/"><i class="anzhiyufont anzhiyu-icon-lightbulb faa-tada" style="font-size: 0.9em;"></i><span> 闲言碎语</span></a></li></ul></div></div></div><div id="nav-right"><div class="nav-button" id="randomPost_button"><a class="site-page" onclick="toRandomPost()" title="随机前往一个文章" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-dice"></i></a></div><input id="center-console" type="checkbox"/><label class="widget" for="center-console" title="中控台" onclick="anzhiyu.switchConsole();"><i class="left"></i><i class="widget center"></i><i class="widget right"></i></label><div id="console"><div class="console-card-group-reward"><ul class="reward-all console-card"><li class="reward-item"><a href="/./img/wechat.jpg" target="_blank"><img class="post-qr-code-img" alt="微信" src="/./img/wechat.jpg"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="/./img/alipay.jpg" target="_blank"><img class="post-qr-code-img" alt="支付宝" src="/./img/alipay.jpg"/></a><div class="post-qr-code-desc">支付宝</div></li></ul></div><div class="console-card-group"><div class="console-card-group-left"><div class="console-card" id="card-newest-comments"><div class="card-content"><div class="author-content-item-tips">互动</div><span class="author-content-item-title"> 最新评论</span></div><div class="aside-list"><span>正在加载中...</span></div></div></div><div class="console-card-group-right"><div class="console-card tags"><div class="card-content"><div class="author-content-item-tips">兴趣点</div><span class="author-content-item-title">寻找你感兴趣的领域</span><div class="card-tags"><div class="item-headline"></div><div class="card-tag-cloud"><a href="/tags/JVM%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/" style="font-size: 1.05rem;">JVM内存模型<sup>1</sup></a><a href="/tags/JVM%E8%B0%83%E4%BC%98/" style="font-size: 1.05rem;">JVM调优<sup>1</sup></a><a href="/tags/java%E6%95%99%E7%A8%8B/" style="font-size: 1.05rem;">java教程<sup>1</sup></a><a href="/tags/mysql/" style="font-size: 1.05rem;">mysql<sup>1</sup></a><a href="/tags/%E5%87%BD%E6%95%B0/" style="font-size: 1.05rem;">函数<sup>1</sup></a><a href="/tags/%E5%8F%8D%E5%B0%84/" style="font-size: 1.05rem;">反射<sup>1</sup></a><a href="/tags/%E5%A4%8D%E4%B9%A0/" style="font-size: 1.05rem;">复习<sup>1</sup></a><a href="/tags/%E5%A4%8D%E4%B9%A0-%E5%8F%98%E9%87%8F/" style="font-size: 1.05rem;">复习 变量<sup>1</sup></a><a href="/tags/%E5%B7%A5%E5%85%B7/" style="font-size: 1.05rem;">工具<sup>1</sup></a><a href="/tags/%E5%B9%B6%E5%8F%91/" style="font-size: 1.05rem;">并发<sup>1</sup></a><a href="/tags/%E6%83%85%E6%84%9F/" style="font-size: 1.05rem;">情感<sup>1</sup></a><a href="/tags/%E6%8A%BD%E8%B1%A1%E7%B1%BB-%E6%8E%A5%E5%8F%A3/" style="font-size: 1.05rem;">抽象类 接口<sup>1</sup></a><a href="/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/" style="font-size: 1.05rem;">数据库<sup>1</sup></a><a href="/tags/%E6%AF%8F%E6%97%A5%E9%9D%A2%E8%AF%95/" style="font-size: 1.05rem;">每日面试<sup>2</sup></a><a href="/tags/%E7%94%B5%E5%95%86-%E8%AE%A2%E5%8D%95/" style="font-size: 1.05rem;">电商,订单<sup>1</sup></a><a href="/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" style="font-size: 1.05rem;">设计模式<sup>1</sup></a><a href="/tags/%E8%B6%85%E5%8D%96-%E5%BA%93%E5%AD%98/" style="font-size: 1.05rem;">超卖 , 库存<sup>1</sup></a><a href="/tags/%E9%9B%86%E5%90%88/" style="font-size: 1.05rem;">集合<sup>1</sup></a></div></div><hr/></div></div><div class="console-card history"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-box-archiv"></i><span>文章</span></div><div class="card-archives"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-archive"></i><span>归档</span></div><ul class="card-archive-list"><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2025/10/"><span class="card-archive-list-date">十月 2025</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">9</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2025/04/"><span class="card-archive-list-date">四月 2025</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">4</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2023/10/"><span class="card-archive-list-date">十月 2023</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">3</span><span>篇</span></div></a></li></ul></div><hr/></div></div></div><div class="button-group"><div class="console-btn-item"><a class="darkmode_switchbutton" title="显示模式切换" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-moon"></i></a></div><div class="console-btn-item" id="consoleHideAside" onclick="anzhiyu.hideAsideBtn()" title="边栏显示控制"><a class="asideSwitch"><i class="anzhiyufont anzhiyu-icon-arrows-left-right"></i></a></div><div class="console-btn-item on" id="consoleCommentBarrage" onclick="anzhiyu.switchCommentBarrage()" title="热评开关"><a class="commentBarrage"><i class="anzhiyufont anzhiyu-icon-message"></i></a></div><div class="console-btn-item" id="consoleMusic" onclick="anzhiyu.musicToggle()" title="音乐开关"><a class="music-switch"><i class="anzhiyufont anzhiyu-icon-music"></i></a></div></div><div class="console-mask" onclick="anzhiyu.hideConsole()" href="javascript:void(0);"></div></div><div class="nav-button" id="nav-totop"><a class="totopbtn" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i><span id="percent" onclick="anzhiyu.scrollToDest(0,500)">0</span></a></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);" title="切换"><i class="anzhiyufont anzhiyu-icon-bars"></i></a></div></div></div></nav><div id="post-info"><div id="post-firstinfo"><div class="meta-firstline"><a class="post-meta-original">原创</a><span class="post-meta-categories"><span class="post-meta-separator"></span><i class="anzhiyufont anzhiyu-icon-inbox post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E7%A8%8B%E5%BA%8F%E5%BC%80%E5%8F%91/" itemprop="url">程序开发</a></span><span class="article-meta tags"><a class="article-meta__tags" href="/tags/java%E6%95%99%E7%A8%8B/" tabindex="-1" itemprop="url"> <span> <i class="anzhiyufont anzhiyu-icon-hashtag"></i>java教程</span></a></span></div></div><h1 class="post-title" itemprop="name headline">java教程</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="anzhiyufont anzhiyu-icon-calendar-days post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" itemprop="dateCreated datePublished" datetime="2023-10-17T10:00:00.000Z" title="发表于 2023-10-17 18:00:00">2023-10-17</time><span class="post-meta-separator"></span><i class="anzhiyufont anzhiyu-icon-history post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" itemprop="dateCreated datePublished" datetime="2023-10-18T11:00:00.000Z" title="更新于 2023-10-18 19:00:00">2023-10-18</time></span></div><div class="meta-secondline"><span class="post-meta-separator"></span><span class="post-meta-pv-cv" id="" data-flag-title="java教程"><i class="anzhiyufont anzhiyu-icon-fw-eye post-meta-icon"></i><span class="post-meta-label" title="阅读量">阅读量:</span><span id="busuanzi_value_page_pv"><i class="anzhiyufont anzhiyu-icon-spinner anzhiyu-spin"></i></span></span><span class="post-meta-separator">       </span><span class="post-meta-position" title="作者IP属地为新乡"><i class="anzhiyufont anzhiyu-icon-location-dot"></i>新乡</span><span class="post-meta-separator"></span><span class="post-meta-commentcount"><i class="anzhiyufont anzhiyu-icon-comments post-meta-icon"></i><span class="post-meta-label">评论数:</span><a href="/posts/8003e2d3.html#post-comment" itemprop="discussionUrl"><span class="valine-comment-count" data-xid="/posts/8003e2d3.html" itemprop="commentCount"><i class="anzhiyufont anzhiyu-icon-spinner anzhiyu-spin"></i></span></a></span></div></div></div><section class="main-hero-waves-area waves-area"><svg class="waves-svg" xmlns="http://www.w3.org/2000/svg" xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M -160 44 c 30 0 58 -18 88 -18 s 58 18 88 18 s 58 -18 88 -18 s 58 18 88 18 v 44 h -352 Z"></path></defs><g class="parallax"><use href="#gentle-wave" x="48" y="0"></use><use href="#gentle-wave" x="48" y="3"></use><use href="#gentle-wave" x="48" y="5"></use><use href="#gentle-wave" x="48" y="7"></use></g></svg></section><div id="post-top-cover"><img class="nolazyload" id="post-top-bg" src="https://s2.loli.net/2025/10/23/wfbr2eNcL1VvXIn.png?_r_=204c01e8-b178-e5d6-c5d9-a8b8857b2e3a"></div></header><main id="blog-container"><div class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container" itemscope itemtype="https://wsk0404.github.io/posts/8003e2d3.html"><header><a class="post-meta-categories" href="/categories/%E7%A8%8B%E5%BA%8F%E5%BC%80%E5%8F%91/" itemprop="url">程序开发</a><a href="/tags/java%E6%95%99%E7%A8%8B/" tabindex="-1" itemprop="url">java教程</a><h1 id="CrawlerTitle" itemprop="name headline">java教程</h1><span itemprop="author" itemscope itemtype="http://schema.org/Person">Wsk</span><time itemprop="dateCreated datePublished" datetime="2023-10-17T10:00:00.000Z" title="发表于 2023-10-17 18:00:00">2023-10-17</time><time itemprop="dateCreated datePublished" datetime="2023-10-18T11:00:00.000Z" title="更新于 2023-10-18 19:00:00">2023-10-18</time></header><h1 id="Java教程"><a href="#Java教程" class="headerlink" title="Java教程"></a>Java教程</h1><h2 id="Java-简介"><a href="#Java-简介" class="headerlink" title="Java 简介"></a>Java 简介</h2><p>Java 是由 Sun Microsystems 公司于 1995 年 5 月推出的 Java 面向对象程序设计语言和 Java 平台的总称。由 James Gosling和同事们共同研发，并在 1995 年正式推出。</p>
<p>后来 Sun 公司被 Oracle （甲骨文）公司收购，Java 也随之成为 Oracle 公司的产品。</p>
<p>Java分为三个体系：</p>
<ul>
<li>JavaSE（J2SE）（Java2 Platform Standard Edition，java平台标准版）</li>
<li>JavaEE(J2EE)(Java 2 Platform,Enterprise Edition，java平台企业版)</li>
<li>JavaME(J2ME)(Java 2 Platform Micro Edition，java平台微型版)。</li>
</ul>
<p>2005 年 6 月，JavaOne 大会召开，SUN 公司公开 Java SE 6。此时，Java 的各种版本已经更名，以取消其中的数字 “2”：J2EE 更名为 Java EE，J2SE 更名为Java SE，J2ME 更名为 Java ME。</p>
<h2 id="主要特性"><a href="#主要特性" class="headerlink" title="主要特性"></a>主要特性</h2><ul>
<li><p><strong>Java 语言是简单的：</strong></p>
<p>Java 语言的语法与 C 语言和 C++ 语言很接近，使得大多数程序员很容易学习和使用。另一方面，Java 丢弃了 C++ 中很少使用的、很难理解的、令人迷惑的那些特性，如操作符重载、多继承、自动的强制类型转换。特别地，Java 语言不使用指针，而是引用。并提供了自动分配和回收内存空间，使得程序员不必为内存管理而担忧。</p>
</li>
<li><p><strong>Java 语言是面向对象的：</strong></p>
<p>Java 语言提供类、接口和继承等面向对象的特性，为了简单起见，只支持类之间的单继承，但支持接口之间的多继承，并支持类与接口之间的实现机制（关键字为 implements）。Java 语言全面支持动态绑定，而 C++语言只对虚函数使用动态绑定。总之，Java语言是一个纯的面向对象程序设计语言。</p>
</li>
<li><p><strong>Java语言是分布式的：</strong></p>
<p>Java 语言支持 Internet 应用的开发，在基本的 Java 应用编程接口中有一个网络应用编程接口（java net），它提供了用于网络应用编程的类库，包括 URL、URLConnection、Socket、ServerSocket 等。Java 的 RMI（远程方法激活）机制也是开发分布式应用的重要手段。</p>
</li>
<li><p><strong>Java 语言是健壮的：</strong></p>
<p>Java 的强类型机制、异常处理、垃圾的自动收集等是 Java 程序健壮性的重要保证。对指针的丢弃是 Java 的明智选择。Java 的安全检查机制使得 Java 更具健壮性。</p>
</li>
<li><p><strong>Java语言是安全的：</strong></p>
<p>Java通常被用在网络环境中，为此，Java 提供了一个安全机制以防恶意代码的攻击。除了Java 语言具有的许多安全特性以外，Java 对通过网络下载的类具有一个安全防范机制（类 ClassLoader），如分配不同的名字空间以防替代本地的同名类、字节代码检查，并提供安全管理机制（类 SecurityManager）让 Java 应用设置安全哨兵。</p>
</li>
<li><p><strong>Java 语言是体系结构中立的：</strong></p>
<p>Java 程序（后缀为 java 的文件）在 Java 平台上被编译为体系结构中立的字节码格式（后缀为 class 的文件），然后可以在实现这个 Java 平台的任何系统中运行。这种途径适合于异构的网络环境和软件的分发。</p>
</li>
<li><p><strong>Java 语言是可移植的：</strong></p>
<p>这种可移植性来源于体系结构中立性，另外，Java 还严格规定了各个基本数据类型的长度。Java 系统本身也具有很强的可移植性，Java 编译器是用 Java 实现的，Java 的运行环境是用 ANSI C 实现的。</p>
</li>
<li><p><strong>Java 语言是解释型的：</strong></p>
<p>如前所述，Java 程序在 Java 平台上被编译为字节码格式，然后可以在实现这个 Java 平台的任何系统中运行。在运行时，Java 平台中的 Java 解释器对这些字节码进行解释执行，执行过程中需要的类在联接阶段被载入到运行环境中。</p>
</li>
<li><p><strong>Java 是高性能的：</strong></p>
<p>与那些解释型的高级脚本语言相比，Java 的确是高性能的。事实上，Java 的运行速度随着 JIT(Just-In-Time）编译器技术的发展越来越接近于 C++。</p>
</li>
<li><p><strong>Java 语言是多线程的：</strong></p>
<p>在 Java 语言中，线程是一种特殊的对象，它必须由 Thread 类或其子（孙）类来创建。通常有两种方法来创建线程：其一，使用型构为 Thread(Runnable) 的构造子类将一个实现了 Runnable 接口的对象包装成一个线程，其二，从 Thread 类派生出子类并重写 run 方法，使用该子类创建的对象即为线程。值得注意的是 Thread 类已经实现了 Runnable 接口，因此，任何一个线程均有它的 run 方法，而 run 方法中包含了线程所要运行的代码。线程的活动由一组方法来控制。Java 语言支持多个线程的同时执行，并提供多线程之间的同步机制（关键字为 synchronized）。</p>
</li>
<li><p><strong>Java 语言是动态的：</strong></p>
<p>Java 语言的设计目标之一是适应于动态变化的环境。Java 程序需要的类能够动态地被载入到运行环境，也可以通过网络来载入所需要的类。这也有利于软件的升级。另外，Java 中的类有一个运行时刻的表示，能进行运行时刻的类型检查</p>
</li>
</ul>
<h2 id="发展历史-简略版"><a href="#发展历史-简略版" class="headerlink" title="发展历史(简略版)"></a>发展历史(简略版)</h2><ul>
<li>1995 年 5 月 23 日，Java 语言诞生</li>
<li>1999 年 6月，SUN 公司发布 Java 的三个版本：标准版（JavaSE, 以前是 J2SE）、企业版（JavaEE 以前是 J2EE）和微型版（JavaME，以前是 J2ME）</li>
<li>2004 年 9 月 30 日 18:00PM，J2SE1.5 发布，成为 Java 语言发展史上的又一里程碑。为了表示该版本的重要性，J2SE1.5 更名为 Java SE 5.0</li>
<li>2005 年 6 月，JavaOne 大会召开，SUN 公司公开 Java SE 6。此时，Java 的各种版本已经更名，以取消其中的数字 “2”：J2EE 更名为 Java EE，J2SE 更名为 Java SE，J2ME 更名为 Java ME</li>
<li>2006 年 12 月，SUN 公司发布 JRE6.0</li>
<li><strong>2009 年 04 月 20 日，甲骨文 74 亿美元收购 Sun，取得 Java 的版权。</strong></li>
<li>2011 年 7 月 28 日，甲骨文发布 Java7.0 的正式版。</li>
<li>2014 年 3 月 18 日，Oracle 公司发表 Java SE 8。</li>
<li>2017 年 9 月 21 日，Oracle 公司发表 Java SE 9</li>
<li>2018 年 3 月 21 日，Oracle 公司发表 Java SE 10</li>
<li>2018 年 9 月 25 日，Java SE 11 发布</li>
<li>2019 年 3 月 20 日，Java SE 12 发布</li>
</ul>
<h2 id="Java-开发工具"><a href="#Java-开发工具" class="headerlink" title="Java 开发工具"></a>Java 开发工具</h2><p>Java 语言尽量保证系统内存在 1G 以上，其他工具如下所示：</p>
<ul>
<li>Linux 系统、Mac OS 系统、Windows 95&#x2F;98&#x2F;2000&#x2F;XP，WIN 7&#x2F;8系统。</li>
<li><a target="_blank" rel="noopener" href="http://www.oracle.com/technetwork/cn/java/javase/downloads/index.html">Java JDK 7、8……</a></li>
<li><a target="_blank" rel="noopener" href="https://code.visualstudio.com/">vscode</a> 编辑器或者其他编辑器。</li>
<li>IDE：<a target="_blank" rel="noopener" href="http://www.eclipse.org/downloads/">Eclipse</a>、 <a target="_blank" rel="noopener" href="https://www.jetbrains.com/idea/">IntelliJ IDEA</a>、<a target="_blank" rel="noopener" href="https://netbeans.org/">NetBeans</a> 等。</li>
</ul>
<h1 id="Java-开发环境配置"><a href="#Java-开发环境配置" class="headerlink" title="Java 开发环境配置"></a>Java 开发环境配置</h1><h2 id="window系统安装java"><a href="#window系统安装java" class="headerlink" title="window系统安装java"></a>window系统安装java</h2><h3 id="下载JDK"><a href="#下载JDK" class="headerlink" title="下载JDK"></a>下载JDK</h3><p>首先我们需要下载 java 开发工具包 JDK，下载地址：<a target="_blank" rel="noopener" href="https://www.oracle.com/java/technologies/downloads/%EF%BC%8C%E5%9C%A8%E4%B8%8B%E8%BD%BD%E9%A1%B5%E9%9D%A2%E4%B8%AD%E6%A0%B9%E6%8D%AE%E8%87%AA%E5%B7%B1%E7%9A%84%E7%B3%BB%E7%BB%9F%E9%80%89%E6%8B%A9%E5%AF%B9%E5%BA%94%E7%9A%84%E7%89%88%E6%9C%AC%EF%BC%8C%E6%9C%AC%E6%96%87%E4%BB%A5">https://www.oracle.com/java/technologies/downloads/，在下载页面中根据自己的系统选择对应的版本，本文以</a> Window 64位系统为例：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="C:\Users\16564\AppData\Roaming\Typora\typora-user-images\image-20231002110725370.png" alt="image-20231002110725370"></p>
<p>下载后 JDK 的安装根据提示进行，还有安装 JDK 的时候也会安装 JRE，一并安装就可以了。</p>
<p>安装JDK，安装过程中可以自定义安装目录等信息，例如我们选择安装目录为 <strong>C:\Program Files (x86)\Java\jdk1.8.0_91</strong>。</p>
<h3 id="配置环境变量"><a href="#配置环境变量" class="headerlink" title="配置环境变量"></a>配置环境变量</h3><p>1.安装完成后，右击”我的电脑”，点击”属性”，选择”高级系统设置”；</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://www.runoob.com/wp-content/uploads/2013/12/win-java1.png" alt="img"></p>
<p>2.选择”高级”选项卡，点击”环境变量”；</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://www.runoob.com/wp-content/uploads/2013/12/java-win2.png" alt="img"></p>
<p>然后就会出现如下图所示的画面：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://www.runoob.com/wp-content/uploads/2013/12/java-win3.png" alt="img"></p>
<p>在 “系统变量” 中设置 3 项属性，JAVA_HOME、PATH、CLASSPATH(大小写无所谓),若已存在则点击”编辑”，不存在则点击”新建”。</p>
<p><code>**注意：***如果使用 1.5 以上版本的 JDK，不用设置 CLASSPATH 环境变量，也可以正常编译和运行 Java 程序。*</code></p>
<p>变量设置参数如下：</p>
<ul>
<li><p>变量名：<strong>JAVA_HOME</strong></p>
</li>
<li><p>变量值：<strong>C:\Program Files (x86)\Java\jdk1.8.0_91</strong>     &#x2F;&#x2F; 要根据自己的实际路径配置</p>
</li>
<li><p>变量名：<strong>CLASSPATH</strong></p>
</li>
<li><p>变量值：**.;%JAVA_HOME%\lib\dt.jar;%JAVA_HOME%\lib\tools.jar;**     &#x2F;&#x2F;记得前面有个”.”</p>
</li>
<li><p>变量名：<strong>Path</strong></p>
</li>
<li><p>变量值：**%JAVA_HOME%\bin;%JAVA_HOME%\jre\bin;**</p>
</li>
</ul>
<h3 id="测试JDK是否安装成功"><a href="#测试JDK是否安装成功" class="headerlink" title="测试JDK是否安装成功"></a>测试JDK是否安装成功</h3><p>1、”开始”-&gt;”运行”，键入”cmd”；</p>
<p>2、键入命令: <strong>java -version</strong>、<strong>java</strong>、<strong>javac</strong> 几个命令，出现以下信息，说明环境变量配置成功；</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://www.runoob.com/wp-content/uploads/2013/12/java-win9.png" alt="img"></p>
<h2 id="流行-Java-开发工具"><a href="#流行-Java-开发工具" class="headerlink" title="流行 Java 开发工具"></a>流行 Java 开发工具</h2><p>我们在开发 Java 语言过程中同样需要一款不错的开发工具，目前市场上的 IDE 很多，本文为大家推荐以下下几款 Java 开发工具：</p>
<ul>
<li><p>**Eclipse（推荐）:**另一个免费开源的 Java IDE，下载地址： <a target="_blank" rel="noopener" href="https://www.eclipse.org/downloads/packages/">https://www.eclipse.org/downloads/packages/</a></p>
<p>选择 <strong>Eclipse IDE for Java Developers</strong>：<br><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://www.runoob.com/wp-content/uploads/2013/12/5A92DEAE-EFB9-493D-AC4D-808E529B533C.jpg" alt="img"></p>
</li>
<li><p><strong>JetBrains</strong> **的 IDEA(推荐)**， 现在很多人开始使用了，功能很强大，下载地址：<a target="_blank" rel="noopener" href="https://www.jetbrains.com/idea/download/">https://www.jetbrains.com/idea/download/</a></p>
</li>
<li><p><strong>VSCode :</strong> VSCode（全称：Visual Studio Code）是一款由微软开发且跨平台的免费源代码编辑器。安装教程：<a target="_blank" rel="noopener" href="https://www.runoob.com/w3cnote/vscode-tutorial.html"> https://www.runoob.com/w3cnote/vscode-tutorial.html</a></p>
</li>
<li><p>**Netbeans:**开源免费的 Java IDE，下载地址： <a target="_blank" rel="noopener" href="https://www.netbeans.org/">https://www.netbeans.org/index.html</a></p>
</li>
</ul>
<h1 id="Java-基础语法"><a href="#Java-基础语法" class="headerlink" title="Java 基础语法"></a>Java 基础语法</h1><ul>
<li><strong>对象</strong>：对象是类的一个实例，有状态和行为。例如，一条狗是一个对象，它的状态有：颜色、名字、品种；行为有：摇尾巴、叫、吃等。</li>
<li><strong>类</strong>：类是一个模板，它描述一类对象的行为和状态。</li>
<li><strong>方法</strong>：方法就是行为，一个类可以有很多方法。逻辑运算、数据修改以及所有动作都是在方法中完成的。</li>
<li><strong>实例变量</strong>：每个对象都有独特的实例变量，对象的状态由这些实例变量的值决定。</li>
</ul>
<h2 id="第一个Java程序"><a href="#第一个Java程序" class="headerlink" title="第一个Java程序"></a>第一个Java程序</h2><p>下面看一个简单的 Java 程序，它将输出字符串 <em>Hello World</em></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloWorld</span> &#123;</span><br><span class="line">    <span class="comment">/* 第一个Java程序</span></span><br><span class="line"><span class="comment">     * 它将输出字符串 Hello World</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Hello World&quot;</span>); <span class="comment">// 输出 Hello World</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="C:\Users\16564\AppData\Roaming\Typora\typora-user-images\image-20231002111245029.png" alt="image-20231002111245029"></p>
<h2 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h2><p>编写 Java 程序时，应注意以下几点：</p>
<ul>
<li><strong>大小写敏感</strong>：Java 是大小写敏感的，这就意味着标识符 Hello 与 hello 是不同的。</li>
<li><strong>类名</strong>：对于所有的类来说，类名的首字母应该大写。如果类名由若干单词组成，那么每个单词的首字母应该大写，例如 <strong>MyFirstJavaClass</strong> 。</li>
<li><strong>方法名</strong>：所有的方法名都应该以小写字母开头。如果方法名含有若干单词，则后面的每个单词首字母大写。</li>
<li><strong>源文件名</strong>：源文件名必须和类名相同。当保存文件的时候，你应该使用类名作为文件名保存（切记 Java 是大小写敏感的），文件名的后缀为 <strong>.java</strong>。（如果文件名和类名不相同则会导致编译错误）。</li>
<li><strong>主方法入口</strong>：所有的 Java 程序由 <strong>public static void main(String[] args)</strong> 方法开始执行。</li>
</ul>
<h2 id="Java-标识符"><a href="#Java-标识符" class="headerlink" title="Java 标识符"></a>Java 标识符</h2><p>Java 所有的组成部分都需要名字。类名、变量名以及方法名都被称为标识符。</p>
<p>关于 Java 标识符，有以下几点需要注意：</p>
<ul>
<li>所有的标识符都应该以字母（A-Z 或者 a-z）,美元符（$）、或者下划线（_）开始</li>
<li>首字符之后可以是字母（A-Z 或者 a-z）,美元符（$）、下划线（_）或数字的任何字符组合</li>
<li>关键字不能用作标识符</li>
<li>标识符是大小写敏感的</li>
<li>合法标识符举例：age、$salary、_value、__1_value</li>
<li>非法标识符举例：123abc、-salary</li>
</ul>
<h2 id="Java修饰符"><a href="#Java修饰符" class="headerlink" title="Java修饰符"></a>Java修饰符</h2><p>像其他语言一样，Java可以使用修饰符来修饰类中方法和属性。主要有两类修饰符：</p>
<ul>
<li>访问控制修饰符 : default, public , protected, private</li>
<li>非访问控制修饰符 : final, abstract, static, synchronized</li>
</ul>
<p>在后面的章节中我们会深入讨论 Java 修饰符。</p>
<h2 id="Java-变量"><a href="#Java-变量" class="headerlink" title="Java 变量"></a>Java 变量</h2><p>Java 中主要有如下几种类型的变量</p>
<ul>
<li>局部变量</li>
<li>类变量（静态变量）</li>
<li>成员变量（非静态变量）</li>
</ul>
<h2 id="Java-数组"><a href="#Java-数组" class="headerlink" title="Java 数组"></a>Java 数组</h2><p>数组是储存在堆上的对象，可以保存多个同类型变量。在后面的章节中，我们将会学到如何声明、构造以及初始化一个数组。</p>
<h2 id="Java-枚举"><a href="#Java-枚举" class="headerlink" title="Java 枚举"></a>Java 枚举</h2><p>Java 5.0引入了枚举，枚举限制变量只能是预先设定好的值。使用枚举可以减少代码中的 bug。</p>
<p>例如，我们为果汁店设计一个程序，它将限制果汁为小杯、中杯、大杯。这就意味着它不允许顾客点除了这三种尺寸外的果汁。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">FreshJuice</span> &#123;</span><br><span class="line">   <span class="keyword">enum</span> <span class="title class_">FreshJuiceSize</span>&#123; SMALL, MEDIUM , LARGE &#125;</span><br><span class="line">   FreshJuiceSize size;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FreshJuiceTest</span> &#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">      <span class="type">FreshJuice</span> <span class="variable">juice</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FreshJuice</span>();</span><br><span class="line">      juice.size = FreshJuice.FreshJuiceSize.MEDIUM  ;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Java-关键字"><a href="#Java-关键字" class="headerlink" title="Java 关键字"></a>Java 关键字</h2><p>不需要特殊记忆,随着开发程序的进行,就会慢慢记住</p>
<h2 id="Java注释"><a href="#Java注释" class="headerlink" title="Java注释"></a>Java注释</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloWorld</span> &#123;</span><br><span class="line">   <span class="comment">/* 这是第一个Java程序</span></span><br><span class="line"><span class="comment">    * 它将输出 Hello World</span></span><br><span class="line"><span class="comment">    * 这是一个多行注释的示例</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">       <span class="comment">// 这是单行注释的示例</span></span><br><span class="line">       <span class="comment">/* 这个也是单行注释的示例 */</span></span><br><span class="line">       System.out.println(<span class="string">&quot;Hello World&quot;</span>); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><p>在 Java 中，一个类可以由其他类派生。如果你要创建一个类，而且已经存在一个类具有你所需要的属性或方法，那么你可以将新创建的类继承该类。</p>
<p>利用继承的方法，可以重用已存在类的方法和属性，而不用重写这些代码。被继承的类称为超类（super class），派生类称为子类（sub class）。</p>
<h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><p>在 Java 中，接口可理解为对象间相互通信的协议。接口在继承中扮演着很重要的角色。</p>
<p>接口只定义派生要用到的方法，但是方法的具体实现完全取决于派生类。</p>
<h1 id="Java-对象和类"><a href="#Java-对象和类" class="headerlink" title="Java 对象和类"></a>Java 对象和类</h1><p>Java作为一种面向对象语言。支持以下基本概念：</p>
<ul>
<li>多态</li>
<li>继承</li>
<li>封装</li>
<li>抽象</li>
<li>类</li>
<li>对象</li>
<li>实例</li>
<li>方法</li>
<li>重载</li>
</ul>
<p>重点研究对象和类的概念</p>
<ul>
<li><strong>对象</strong>：对象是类的一个实例（<strong>对象不是找个女朋友</strong>），有状态和行为。例如，一条狗是一个对象，它的状态有：颜色、名字、品种；行为有：摇尾巴、叫、吃等。</li>
<li><strong>类</strong>：类是一个模板，它描述一类对象的行为和状态。</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="C:\Users\16564\AppData\Roaming\Typora\typora-user-images\image-20231002112134949.png" alt="image-20231002112134949"></p>
<h2 id="Java中的对象"><a href="#Java中的对象" class="headerlink" title="Java中的对象"></a>Java中的对象</h2><p>软件对象也有状态和行为。软件对象的状态就是属性，行为通过方法体现。</p>
<p>在软件开发中，方法操作对象内部状态的改变，对象的相互调用也是通过方法来完成</p>
<h2 id="Java-中的类"><a href="#Java-中的类" class="headerlink" title="Java 中的类"></a>Java 中的类</h2><p>类可以看成是创建 Java 对象的模板。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="C:\Users\16564\AppData\Roaming\Typora\typora-user-images\image-20231002112233675.png" alt="image-20231002112233675"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Dog</span> &#123;</span><br><span class="line">    String breed;</span><br><span class="line">    <span class="type">int</span> size;</span><br><span class="line">    String colour;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">sleep</span><span class="params">()</span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">name</span><span class="params">()</span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>局部变量</strong>：在方法、构造方法或者语句块中定义的变量被称为局部变量。变量声明和初始化都是在方法中，方法结束后，变量就会自动销毁。</li>
<li><strong>成员变量</strong>：成员变量是定义在类中，方法体之外的变量。这种变量在创建对象的时候实例化。成员变量可以被类中方法、构造方法和特定类的语句块访问。</li>
<li><strong>类变量</strong>：类变量也声明在类中，方法体之外，但必须声明为 static 类型。</li>
</ul>
<p>一个类可以拥有多个方法，在上面的例子中：eat()、run()、sleep() 和 name() 都是 Dog 类的方法。</p>
<h2 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h2><p>每个类都有构造方法。如果没有显式地为类定义构造方法，Java 编译器将会为该类提供一个默认构造方法。</p>
<p>在创建一个对象的时候，至少要调用一个构造方法。构造方法的名称必须与类同名，一个类可以有多个构造方法。</p>
<p>下面是一个构造方法示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Puppy</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Puppy</span><span class="params">()</span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Puppy</span><span class="params">(String name)</span>&#123;</span><br><span class="line">        <span class="comment">// 这个构造器仅有一个参数：name</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="创建对象"><a href="#创建对象" class="headerlink" title="创建对象"></a>创建对象</h2><p>对象是根据类创建的。在Java中，使用关键字 new 来创建一个新的对象。创建对象需要以下三步：</p>
<ul>
<li><strong>声明</strong>：声明一个对象，包括对象名称和对象类型。</li>
<li><strong>实例化</strong>：使用关键字 new 来创建一个对象。</li>
<li><strong>初始化</strong>：使用 new 创建对象时，会调用构造方法初始化对象。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Puppy</span>&#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="title function_">Puppy</span><span class="params">(String name)</span>&#123;</span><br><span class="line">      <span class="comment">//这个构造器仅有一个参数：name</span></span><br><span class="line">      System.out.println(<span class="string">&quot;小狗的名字是 : &quot;</span> + name ); </span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">      <span class="comment">// 下面的语句将创建一个Puppy对象</span></span><br><span class="line">      <span class="type">Puppy</span> <span class="variable">myPuppy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Puppy</span>( <span class="string">&quot;tommy&quot;</span> );</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="访问实例变量和方法"><a href="#访问实例变量和方法" class="headerlink" title="访问实例变量和方法"></a>访问实例变量和方法</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 实例化对象 */</span></span><br><span class="line"><span class="type">Object</span> <span class="variable">referenceVariable</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Constructor</span>();</span><br><span class="line"><span class="comment">/* 访问类中的变量 */</span></span><br><span class="line">referenceVariable.variableName;</span><br><span class="line"><span class="comment">/* 访问类中的方法 */</span></span><br><span class="line">referenceVariable.methodName();</span><br></pre></td></tr></table></figure>

<h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><p>下面的例子展示如何访问实例变量和调用成员方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Puppy</span>&#123;</span><br><span class="line">   <span class="type">int</span> puppyAge;</span><br><span class="line">   <span class="keyword">public</span> <span class="title function_">Puppy</span><span class="params">(String name)</span>&#123;</span><br><span class="line">      <span class="comment">// 这个构造器仅有一个参数：name</span></span><br><span class="line">      System.out.println(<span class="string">&quot;小狗的名字是 : &quot;</span> + name ); </span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAge</span><span class="params">( <span class="type">int</span> age )</span>&#123;</span><br><span class="line">       puppyAge = age;</span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getAge</span><span class="params">( )</span>&#123;</span><br><span class="line">       System.out.println(<span class="string">&quot;小狗的年龄为 : &quot;</span> + puppyAge ); </span><br><span class="line">       <span class="keyword">return</span> puppyAge;</span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">      <span class="comment">/* 创建对象 */</span></span><br><span class="line">      <span class="type">Puppy</span> <span class="variable">myPuppy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Puppy</span>( <span class="string">&quot;tommy&quot;</span> );</span><br><span class="line">      <span class="comment">/* 通过方法来设定age */</span></span><br><span class="line">      myPuppy.setAge( <span class="number">2</span> );</span><br><span class="line">      <span class="comment">/* 调用另一个方法获取age */</span></span><br><span class="line">      myPuppy.getAge( );</span><br><span class="line">      <span class="comment">/*你也可以像下面这样访问成员变量 */</span></span><br><span class="line">      System.out.println(<span class="string">&quot;变量值 : &quot;</span> + myPuppy.puppyAge ); </span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="源文件声明规则"><a href="#源文件声明规则" class="headerlink" title="源文件声明规则"></a>源文件声明规则</h2><ul>
<li>一个源文件中只能有一个 public 类</li>
<li>一个源文件可以有多个非 public 类</li>
<li>源文件的名称应该和 public 类的类名保持一致。例如：源文件中 public 类的类名是 Employee，那么源文件应该命名为Employee.java。</li>
<li>如果一个类定义在某个包中，那么 package 语句应该在源文件的首行。</li>
<li>如果源文件包含 import 语句，那么应该放在 package 语句和类定义之间。如果没有 package 语句，那么 import 语句应该在源文件中最前面。</li>
<li>import 语句和 package 语句对源文件中定义的所有类都有效。在同一源文件中，不能给不同的类不同的包声明。</li>
</ul>
<h2 id="import-语句"><a href="#import-语句" class="headerlink" title="import 语句"></a>import 语句</h2><p>在 Java 中，如果给出一个完整的限定名，包括包名、类名，那么 Java 编译器就可以很容易地定位到源代码或者类。import 语句就是用来提供一个合理的路径，使得编译器可以找到某个类。</p>
<p>例如，下面的命令行将会命令编译器载入 java_installation&#x2F;java&#x2F;io 路径下的所有类</p>
<h2 id="一个简单的例子"><a href="#一个简单的例子" class="headerlink" title="一个简单的例子"></a>一个简单的例子</h2><p>在该例子中，我们创建两个类：<strong>Employee</strong> 和 <strong>EmployeeTest</strong>。</p>
<p>首先打开文本编辑器，把下面的代码粘贴进去。注意将文件保存为 Employee.java。</p>
<p>Employee 类有四个成员变量：name、age、designation 和 salary。该类显式声明了一个构造方法，该方法只有一个参数。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Employee</span>&#123;</span><br><span class="line">   String name;</span><br><span class="line">   <span class="type">int</span> age;</span><br><span class="line">   String designation;</span><br><span class="line">   <span class="type">double</span> salary;</span><br><span class="line">   <span class="comment">// Employee 类的构造器</span></span><br><span class="line">   <span class="keyword">public</span> <span class="title function_">Employee</span><span class="params">(String name)</span>&#123;</span><br><span class="line">      <span class="built_in">this</span>.name = name;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// 设置age的值</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">empAge</span><span class="params">(<span class="type">int</span> empAge)</span>&#123;</span><br><span class="line">      age =  empAge;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">/* 设置designation的值*/</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">empDesignation</span><span class="params">(String empDesig)</span>&#123;</span><br><span class="line">      designation = empDesig;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">/* 设置salary的值*/</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">empSalary</span><span class="params">(<span class="type">double</span> empSalary)</span>&#123;</span><br><span class="line">      salary = empSalary;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">/* 打印信息 */</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">printEmployee</span><span class="params">()</span>&#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;名字:&quot;</span>+ name );</span><br><span class="line">      System.out.println(<span class="string">&quot;年龄:&quot;</span> + age );</span><br><span class="line">      System.out.println(<span class="string">&quot;职位:&quot;</span> + designation );</span><br><span class="line">      System.out.println(<span class="string">&quot;薪水:&quot;</span> + salary);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>程序都是从main方法开始执行。为了能运行这个程序，必须包含main方法并且创建一个实例对象。</p>
<p>下面给出EmployeeTest类，该类实例化2个 Employee 类的实例，并调用方法设置变量的值。</p>
<p>将下面的代码保存在 EmployeeTest.java文件中。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EmployeeTest</span>&#123;</span><br><span class="line"> </span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">      <span class="comment">/* 使用构造器创建两个对象 */</span></span><br><span class="line">      <span class="type">Employee</span> <span class="variable">empOne</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Employee</span>(<span class="string">&quot;RUNOOB1&quot;</span>);</span><br><span class="line">      <span class="type">Employee</span> <span class="variable">empTwo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Employee</span>(<span class="string">&quot;RUNOOB2&quot;</span>);</span><br><span class="line"> </span><br><span class="line">      <span class="comment">// 调用这两个对象的成员方法</span></span><br><span class="line">      empOne.empAge(<span class="number">26</span>);</span><br><span class="line">      empOne.empDesignation(<span class="string">&quot;高级程序员&quot;</span>);</span><br><span class="line">      empOne.empSalary(<span class="number">1000</span>);</span><br><span class="line">      empOne.printEmployee();</span><br><span class="line"> </span><br><span class="line">      empTwo.empAge(<span class="number">21</span>);</span><br><span class="line">      empTwo.empDesignation(<span class="string">&quot;菜鸟程序员&quot;</span>);</span><br><span class="line">      empTwo.empSalary(<span class="number">500</span>);</span><br><span class="line">      empTwo.printEmployee();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Java-基本数据类型"><a href="#Java-基本数据类型" class="headerlink" title="Java 基本数据类型"></a>Java 基本数据类型</h1><p>变量就是申请内存来存储值。也就是说，当创建变量的时候，需要在内存中申请空间。</p>
<p>内存管理系统根据变量的类型为变量分配存储空间，分配的空间只能用来储存该类型数据。</p>
<p>因此，通过定义不同类型的变量，可以在内存中储存整数、小数或者字符。</p>
<p>Java 的两大数据类型:</p>
<ul>
<li>内置数据类型</li>
<li>引用数据类型</li>
</ul>
<h2 id="内置数据类型"><a href="#内置数据类型" class="headerlink" title="内置数据类型"></a>内置数据类型</h2><p>Java语言提供了八种基本类型。六种数字类型（四个整数型，两个浮点型），一种字符类型，还有一种布尔型。</p>
<p><strong>byte：</strong></p>
<ul>
<li>byte 数据类型是8位、有符号的，以二进制补码表示的整数；</li>
<li>最小值是 <strong>-128（-2^7）</strong>；</li>
<li>最大值是 <strong>127（2^7-1）</strong>；</li>
<li>默认值是 <strong>0</strong>；</li>
<li>byte 类型用在大型数组中节约空间，主要代替整数，因为 byte 变量占用的空间只有 int 类型的四分之一；</li>
<li>例子：byte a &#x3D; 100，byte b &#x3D; -50。</li>
</ul>
<p><strong>short：</strong></p>
<ul>
<li>short 数据类型是 16 位、有符号的以二进制补码表示的整数</li>
<li>最小值是 <strong>-32768（-2^15）</strong>；</li>
<li>最大值是 <strong>32767（2^15 - 1）</strong>；</li>
<li>Short 数据类型也可以像 byte 那样节省空间。一个short变量是int型变量所占空间的二分之一；</li>
<li>默认值是 <strong>0</strong>；</li>
<li>例子：short s &#x3D; 1000，short r &#x3D; -20000。</li>
</ul>
<p><strong>int：</strong></p>
<ul>
<li>int 数据类型是32位、有符号的以二进制补码表示的整数；</li>
<li>最小值是 <strong>-2,147,483,648（-2^31）</strong>；</li>
<li>最大值是 <strong>2,147,483,647（2^31 - 1）</strong>；</li>
<li>一般地整型变量默认为 int 类型；</li>
<li>默认值是 <strong>0</strong> ；</li>
<li>例子：int a &#x3D; 100000, int b &#x3D; -200000。</li>
</ul>
<p><strong>long：</strong></p>
<ul>
<li>long 数据类型是 64 位、有符号的以二进制补码表示的整数；</li>
<li>最小值是 <strong>-9,223,372,036,854,775,808（-2^63）</strong>；</li>
<li>最大值是 <strong>9,223,372,036,854,775,807（2^63 -1）</strong>；</li>
<li>这种类型主要使用在需要比较大整数的系统上；</li>
<li>默认值是 <strong>0L</strong>；</li>
<li>例子： <strong>long a &#x3D; 100000L</strong>，<strong>long b &#x3D; -200000L</strong>。<br>“L”理论上不分大小写，但是若写成”l”容易与数字”1”混淆，不容易分辩。所以最好大写。</li>
</ul>
<p><strong>float：</strong></p>
<ul>
<li>float 数据类型是单精度、32位、符合IEEE 754标准的浮点数；</li>
<li>float 在储存大型浮点数组的时候可节省内存空间；</li>
<li>默认值是 <strong>0.0f</strong>；</li>
<li>浮点数不能用来表示精确的值，如货币；</li>
<li>例子：float f1 &#x3D; 234.5f。</li>
</ul>
<p><strong>double：</strong></p>
<ul>
<li><p>double 数据类型是双精度、64 位、符合 IEEE 754 标准的浮点数；</p>
</li>
<li><p>浮点数的默认类型为 double 类型；</p>
</li>
<li><p>double类型同样不能表示精确的值，如货币；</p>
</li>
<li><p>默认值是 <strong>0.0d</strong>；</p>
</li>
<li><p>例子：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">double   d1  = 7D ;</span><br><span class="line">double   d2  = 7.; </span><br><span class="line">double   d3  =  8.0; </span><br><span class="line">double   d4  =  8.D; </span><br><span class="line">double   d5  =  12.9867; </span><br></pre></td></tr></table></figure>

<p>7 是一个 int 字面量，而 7D，7. 和 8.0 是 double 字面量。</p>
</li>
</ul>
<p><strong>boolean：</strong></p>
<ul>
<li>boolean数据类型表示一位的信息；</li>
<li>只有两个取值：true 和 false；</li>
<li>这种类型只作为一种标志来记录 true&#x2F;false 情况；</li>
<li>默认值是 <strong>false</strong>；</li>
<li>例子：boolean one &#x3D; true。</li>
</ul>
<p><strong>char：</strong></p>
<ul>
<li>char 类型是一个单一的 16 位 Unicode 字符；</li>
<li>最小值是 <strong>\u0000</strong>（十进制等效值为 0）；</li>
<li>最大值是 <strong>\uffff</strong>（即为 65535）；</li>
<li>char 数据类型可以储存任何字符；</li>
<li>例子：char letter &#x3D; ‘A’;。</li>
</ul>
<h3 id="实例-1"><a href="#实例-1" class="headerlink" title="实例"></a>实例</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// byte  </span></span><br><span class="line">System.out.println(<span class="string">&quot;基本类型：byte 二进制位数：&quot;</span> + Byte.SIZE);  </span><br><span class="line">System.out.println(<span class="string">&quot;包装类：java.lang.Byte&quot;</span>);  </span><br><span class="line">System.out.println(<span class="string">&quot;最小值：Byte.MIN_VALUE=&quot;</span> + Byte.MIN_VALUE);  </span><br><span class="line">System.out.println(<span class="string">&quot;最大值：Byte.MAX_VALUE=&quot;</span> + Byte.MAX_VALUE);  </span><br><span class="line">System.out.println();  </span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">基本类型：<span class="type">byte</span> 二进制位数：<span class="number">8</span></span><br><span class="line">包装类：java.lang.Byte</span><br><span class="line">最小值：Byte.MIN_VALUE=-<span class="number">128</span></span><br><span class="line">最大值：Byte.MAX_VALUE=<span class="number">127</span></span><br></pre></td></tr></table></figure>

<h3 id="类型默认值"><a href="#类型默认值" class="headerlink" title="类型默认值"></a>类型默认值</h3><p>下表列出了 Java 各个类型的默认值：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="C:\Users\16564\AppData\Roaming\Typora\typora-user-images\image-20231002144742299.png" alt="image-20231002144742299"></p>
<h2 id="引用类型"><a href="#引用类型" class="headerlink" title="引用类型"></a>引用类型</h2><ul>
<li>在Java中，引用类型的变量非常类似于C&#x2F;C++的指针。引用类型指向一个对象，指向对象的变量是引用变量。这些变量在声明时被指定为一个特定的类型，比如 Employee、Puppy 等。变量一旦声明后，类型就不能被改变了。</li>
<li>对象、数组都是引用数据类型。</li>
<li>所有引用类型的默认值都是null。</li>
<li>一个引用变量可以用来引用任何与之兼容的类型。</li>
<li>例子：Site site &#x3D; new Site(“Runoob”)。</li>
</ul>
<p>Java语言支持一些特殊的转义字符序列。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="C:\Users\16564\AppData\Roaming\Typora\typora-user-images\image-20231002145114224.png" alt="image-20231002145114224"></p>
<h2 id="自动类型转换"><a href="#自动类型转换" class="headerlink" title="自动类型转换"></a>自动类型转换</h2><p><strong>整型、实型（常量）、字符型数据可以混合运算。运算中，不同类型的数据先转化为同一类型，然后进行运算。</strong></p>
<p>转换从低级到高级。</p>
<p>&#96;低  ————————————&gt;  高</p>
<p>byte,short,char—&gt; int —&gt; long—&gt; float —&gt; double &#96;</p>
<ul>
<li><ol>
<li>不能对boolean类型进行类型转换。</li>
</ol>
</li>
<li><ol start="2">
<li>不能把对象类型转换成不相关类的对象。</li>
</ol>
</li>
<li><ol start="3">
<li>在把容量大的类型转换为容量小的类型时必须使用强制类型转换。</li>
</ol>
</li>
<li><ol start="4">
<li>转换过程中可能导致溢出或损失精度，例如：</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span><span class="number">128</span>;   </span><br><span class="line"><span class="type">byte</span> <span class="variable">b</span> <span class="operator">=</span> (<span class="type">byte</span>)i;</span><br></pre></td></tr></table></figure>

<p>因为 byte 类型是 8 位，最大值为127，所以当 int 强制转换为 byte 类型时，值 128 时候就会导致溢出。</p>
</li>
<li><ol start="5">
<li>浮点数到整数的转换是通过舍弃小数得到，而不是四舍五入，例如：</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">(<span class="type">int</span>)<span class="number">23.7</span> == <span class="number">23</span>;        </span><br><span class="line">(<span class="type">int</span>)-<span class="number">45.89f</span> == -<span class="number">45</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="自动类型转换-1"><a href="#自动类型转换-1" class="headerlink" title="自动类型转换"></a>自动类型转换</h3><p>必须满足转换前的数据类型的位数要低于转换后的数据类型，例如: short数据类型的位数为16位，就可以自动转换位数为32的int类型，同样float数据类型的位数为32，可以自动转换为64位的double类型。</p>
<p>示例</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ZiDongLeiZhuan</span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">            <span class="type">char</span> c1=<span class="string">&#x27;a&#x27;</span>;<span class="comment">//定义一个char类型</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">i1</span> <span class="operator">=</span> c1;<span class="comment">//char自动类型转换为int</span></span><br><span class="line">            System.out.println(<span class="string">&quot;char自动类型转换为int后的值等于&quot;</span>+i1);</span><br><span class="line">            <span class="type">char</span> <span class="variable">c2</span> <span class="operator">=</span> <span class="string">&#x27;A&#x27;</span>;<span class="comment">//定义一个char类型</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">i2</span> <span class="operator">=</span> c2+<span class="number">1</span>;<span class="comment">//char 类型和 int 类型计算</span></span><br><span class="line">            System.out.println(<span class="string">&quot;char类型和int计算后的值等于&quot;</span>+i2);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="强制类型转换"><a href="#强制类型转换" class="headerlink" title="强制类型转换"></a>强制类型转换</h3><ul>
<li><ol>
<li>条件是转换的数据类型必须是兼容的。</li>
</ol>
</li>
<li><ol start="2">
<li>格式：(type)value type是要强制类型转换后的数据类型</li>
</ol>
</li>
</ul>
<h3 id="隐含强制类型转换"><a href="#隐含强制类型转换" class="headerlink" title="隐含强制类型转换"></a>隐含强制类型转换</h3><ul>
<li><ol>
<li>整数的默认类型是 int。</li>
</ol>
</li>
<li><ol start="2">
<li>小数默认是 double 类型浮点型，在定义 float 类型时必须在数字后面跟上 F 或者 f。</li>
</ol>
</li>
</ul>
<h1 id="Java-变量类型"><a href="#Java-变量类型" class="headerlink" title="Java 变量类型"></a>Java 变量类型</h1><p>声明变量的格式：数据类型	变量名  如：int a;    或者多个变量名 如 int a,b,c; </p>
<p>示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> a, b, c;         <span class="comment">// 声明三个int型整数：a、 b、c</span></span><br><span class="line"><span class="type">int</span> <span class="variable">d</span> <span class="operator">=</span> <span class="number">3</span>, e = <span class="number">4</span>, f = <span class="number">5</span>; <span class="comment">// 声明三个整数并赋予初值</span></span><br><span class="line"><span class="type">byte</span> <span class="variable">z</span> <span class="operator">=</span> <span class="number">22</span>;         <span class="comment">// 声明并初始化 z</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;runoob&quot;</span>;  <span class="comment">// 声明并初始化字符串 s</span></span><br><span class="line"><span class="type">double</span> <span class="variable">pi</span> <span class="operator">=</span> <span class="number">3.14159</span>; <span class="comment">// 声明了双精度浮点型变量 pi</span></span><br><span class="line"><span class="type">char</span> <span class="variable">x</span> <span class="operator">=</span> <span class="string">&#x27;x&#x27;</span>;        <span class="comment">// 声明变量 x 的值是字符 &#x27;x&#x27;。</span></span><br></pre></td></tr></table></figure>

<p>Java 语言支持的变量类型有：</p>
<ul>
<li><strong>局部变量（Local Variables）：</strong>定义在方法、构造方法或语句块中的变量，作用域只限于当前方法、构造方法或语句块中。局部变量必须在使用前声明，并且不能被访问修饰符修饰。</li>
<li><strong>成员变量（Instance Variables）：</strong>定义在类中、方法之外的变量，作用域为整个类，可以被类中的任何方法、构造方法和语句块访问。成员变量可以被访问修饰符修饰。</li>
<li><strong>静态变量（Class Variables）：</strong>定义在类中、方法之外的变量，并且使用 <code>static</code> 关键字修饰，作用域为整个类，可以被类中的任何方法、构造方法和语句块访问，静态变量的值在程序运行期间只有一个副本。静态变量可以被访问修饰符修饰。</li>
<li><strong>参数变量（Parameters）：</strong>方法定义时声明的变量，作为调用该方法时传递给方法的值。参数变量的作用域只限于方法内部。</li>
</ul>
<p>示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RunoobTest</span> &#123;</span><br><span class="line">    <span class="comment">// 成员变量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> instanceVar;</span><br><span class="line">    <span class="comment">// 静态变量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> staticVar;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">(<span class="type">int</span> paramVar)</span> &#123;</span><br><span class="line">        <span class="comment">// 局部变量</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">localVar</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 使用变量</span></span><br><span class="line">        instanceVar = localVar;</span><br><span class="line">        staticVar = paramVar;</span><br><span class="line">        </span><br><span class="line">        System.out.println(<span class="string">&quot;成员变量: &quot;</span> + instanceVar);</span><br><span class="line">        System.out.println(<span class="string">&quot;静态变量: &quot;</span> + staticVar);</span><br><span class="line">        System.out.println(<span class="string">&quot;参数变量: &quot;</span> + paramVar);</span><br><span class="line">        System.out.println(<span class="string">&quot;局部变量: &quot;</span> + localVar);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">RunoobTest</span> <span class="variable">v</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RunoobTest</span>();</span><br><span class="line">        v.method(<span class="number">20</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Java-参数变量"><a href="#Java-参数变量" class="headerlink" title="Java 参数变量"></a>Java 参数变量</h2><p>Java 中的参数变量是指在方法或构造函数中声明的变量，用于接收传递给方法或构造函数的值。参数变量与局部变量类似，但它们只在方法或构造函数被调用时存在，并且只能在方法或构造函数内部使用。</p>
<p>Java 方法的声明语法如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">accessModifier returnType <span class="title function_">methodName</span><span class="params">(parameterType parameterName1, parameterType parameterName2, ...)</span> &#123;</span><br><span class="line">    <span class="comment">// 方法体</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>parameterType – 表示参数变量的类型。</li>
<li>parameterName – 表示参数变量的名称。</li>
</ul>
<p>在调用方法时，我们必须为参数变量传递值，这些值可以是常量、变量或表达式。</p>
<p>方法参数变量的值传递方式有两种：<strong>值传递</strong>和<strong>引用传递</strong>。</p>
<ul>
<li><strong>值传递：</strong>在方法调用时，传递的是实际参数的值的副本。当参数变量被赋予新的值时，只会修改副本的值，不会影响原始值。Java 中的基本数据类型都采用值传递方式传递参数变量的值。</li>
<li><strong>引用传递：</strong>在方法调用时，传递的是实际参数的引用（即内存地址）。当参数变量被赋予新的值时，会修改原始值的内容。Java 中的对象类型采用引用传递方式传递参数变量的值。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RunoobTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">10</span>, b = <span class="number">20</span>;</span><br><span class="line">        swap(a, b); <span class="comment">// 调用swap方法</span></span><br><span class="line">        System.out.println(<span class="string">&quot;a = &quot;</span> + a + <span class="string">&quot;, b = &quot;</span> + b); <span class="comment">// 输出a和b的值</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> x;</span><br><span class="line">        x = y;</span><br><span class="line">        y = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Java-局部变量"><a href="#Java-局部变量" class="headerlink" title="Java 局部变量"></a>Java 局部变量</h2><ul>
<li>局部变量声明在方法、构造方法或者语句块中。</li>
<li>局部变量在方法、构造方法、或者语句块被执行的时候创建，当它们执行完成后，变量将会被销毁。</li>
<li>局部变量必须在使用前声明，并且不能被访问修饰符修饰，因为它们的作用域已经被限制在了声明它们的方法、代码块或构造函数中。</li>
<li>局部变量只在声明它的方法、构造方法或者语句块中可见，不能被其他方法或代码块访问。</li>
<li>局部变量是在栈上分配的。</li>
<li>局部变量没有默认值，所以局部变量被声明后，必须经过初始化，才可以使用。</li>
</ul>
<h2 id="成员变量（实例变量）"><a href="#成员变量（实例变量）" class="headerlink" title="成员变量（实例变量）"></a>成员变量（实例变量）</h2><ul>
<li>成员变量声明在一个类中，但在方法、构造方法和语句块之外。</li>
<li>当一个对象被实例化之后，每个成员变量的值就跟着确定。</li>
<li>成员变量在对象创建的时候创建，在对象被销毁的时候销毁。</li>
<li>成员变量的值应该至少被一个方法、构造方法或者语句块引用，使得外部能够通过这些方式获取实例变量信息。</li>
<li>成员变量可以声明在使用前或者使用后。</li>
<li>访问修饰符可以修饰成员变量。</li>
<li>成员变量对于类中的方法、构造方法或者语句块是可见的。一般情况下应该把成员变量设为私有。通过使用访问修饰符可以使成员变量对子类可见。</li>
<li>成员变量具有默认值。数值型变量的默认值是0，布尔型变量的默认值是 false，引用类型变量的默认值是 null。变量的值可以在声明时指定，也可以在构造方法中指定；</li>
<li>成员变量可以直接通过变量名访问。但在静态方法以及其他类中，就应该使用完全限定名：<strong>ObjectReference.VariableName</strong>。</li>
</ul>
<p>与局部变量不同，成员变量的值在创建对象时被分配，即使未对其初始化，它们也会被赋予默认值，例如 int 类型的变量默认值为 0，boolean 类型的变量默认值为 false。成员变量可以通过对象访问，也可以通过类名访问（如果它们是静态成员变量）如果没有显式初始化成员变量，则它们将被赋予默认值。可以在构造函数或其他方法中初始化成员变量，或者通过对象或类名访问它们并设置它们的值。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RunoobTest</span> &#123;</span><br><span class="line">      <span class="keyword">private</span> <span class="type">int</span> a; <span class="comment">// 私有成员变量a</span></span><br><span class="line">      <span class="keyword">public</span> <span class="type">String</span> <span class="variable">b</span> <span class="operator">=</span> <span class="string">&quot;Hello&quot;</span>; <span class="comment">// 公有成员变量b</span></span><br><span class="line">      </span><br><span class="line">      <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">         <span class="type">RunoobTest</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RunoobTest</span>(); <span class="comment">// 创建对象</span></span><br><span class="line">          </span><br><span class="line">          obj.a = <span class="number">10</span>; <span class="comment">// 访问成员变量a，并设置其值为10</span></span><br><span class="line">          System.out.println(<span class="string">&quot;a = &quot;</span> + obj.a);</span><br><span class="line">          </span><br><span class="line">          obj.b = <span class="string">&quot;World&quot;</span>; <span class="comment">// 访问成员变量b，并设置其值为&quot;World&quot;</span></span><br><span class="line">          System.out.println(<span class="string">&quot;b = &quot;</span> + obj.b);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Employee</span>&#123;</span><br><span class="line">   <span class="comment">// 这个成员变量对子类可见</span></span><br><span class="line">   <span class="keyword">public</span> String name;</span><br><span class="line">   <span class="comment">// 私有变量，仅在该类可见</span></span><br><span class="line">   <span class="keyword">private</span> <span class="type">double</span> salary;</span><br><span class="line">   <span class="comment">//在构造器中对name赋值</span></span><br><span class="line">   <span class="keyword">public</span> <span class="title function_">Employee</span> <span class="params">(String empName)</span>&#123;</span><br><span class="line">      name = empName;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//设定salary的值</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setSalary</span><span class="params">(<span class="type">double</span> empSal)</span>&#123;</span><br><span class="line">      salary = empSal;</span><br><span class="line">   &#125;  </span><br><span class="line">   <span class="comment">// 打印信息</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">printEmp</span><span class="params">()</span>&#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;名字 : &quot;</span> + name );</span><br><span class="line">      System.out.println(<span class="string">&quot;薪水 : &quot;</span> + salary);</span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">      <span class="type">Employee</span> <span class="variable">empOne</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Employee</span>(<span class="string">&quot;RUNOOB&quot;</span>);</span><br><span class="line">      empOne.setSalary(<span class="number">1000.0</span>);</span><br><span class="line">      empOne.printEmp();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="类变量（静态变量）"><a href="#类变量（静态变量）" class="headerlink" title="类变量（静态变量）"></a>类变量（静态变量）</h2><p>Java 中的静态变量是指在类中定义的一个变量，它与类相关而不是与实例相关，即无论创建多少个类实例，静态变量在内存中只有一份拷贝，被所有实例共享。</p>
<p>静态变量在类加载时被创建，在整个程序运行期间都存在。</p>
<h3 id="定义方式"><a href="#定义方式" class="headerlink" title="定义方式"></a>定义方式</h3><p>静态变量的定义方式是在类中使用 <strong>static</strong> 关键字修饰变量，通常也称为类变量。</p>
<p>以下实例中我们定义一个静态变量 <strong>count</strong> ，其初始值为 0：</p>
<h2 id="实例-2"><a href="#实例-2" class="headerlink" title="实例"></a>实例</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">  <span class="comment">// 其他成员变量和方法*</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="访问方式"><a href="#访问方式" class="headerlink" title="访问方式"></a>访问方式</h3><p>由于静态变量是与类相关的，因此可以通过类名来访问静态变量，也可以通过实例名来访问静态变量。</p>
<h2 id="实例-3"><a href="#实例-3" class="headerlink" title="实例"></a>实例</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">MyClass.count = <span class="number">10</span>; <span class="comment">// 通过类名访问</span></span><br><span class="line"><span class="type">MyClass</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyClass</span>();</span><br><span class="line">obj.count = <span class="number">20</span>; <span class="comment">// 通过实例名访问</span></span><br></pre></td></tr></table></figure>

<h3 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h3><p>静态变量的生命周期与程序的生命周期一样长，即它们在类加载时被创建，在整个程序运行期间都存在，直到程序结束才会被销毁。因此，静态变量可以用来存储整个程序都需要使用的数据，如配置信息、全局变量等。</p>
<h3 id="初始化时机"><a href="#初始化时机" class="headerlink" title="初始化时机"></a>初始化时机</h3><p>静态变量在类加载时被初始化，其初始化顺序与定义顺序有关。</p>
<p>如果一个静态变量依赖于另一个静态变量，那么它必须在后面定义。</p>
<h2 id="实例-4"><a href="#实例-4" class="headerlink" title="实例"></a>实例</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">count1</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">count2</span> <span class="operator">=</span> count1 + <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 其他成员变量和方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的例子中，count1 要先于 count2 初始化，否则编译时会报错。</p>
<h3 id="常量和静态变量的区别"><a href="#常量和静态变量的区别" class="headerlink" title="常量和静态变量的区别"></a>常量和静态变量的区别</h3><p>常量也是与类相关的，但它是用 final 关键字修饰的变量，一旦被赋值就不能再修改。与静态变量不同的是，常量在编译时就已经确定了它的值，而静态变量的值可以在运行时改变。另外，常量通常用于存储一些固定的值，如数学常数、配置信息等，而静态变量通常用于存储可变的数据，如计数器、全局状态等。</p>
<p>总之，静态变量是与类相关的变量，具有唯一性和共享性，可以用于存储整个程序都需要使用的数据，但需要注意初始化时机和与常量的区别。</p>
<h3 id="静态变量的访问修饰符"><a href="#静态变量的访问修饰符" class="headerlink" title="静态变量的访问修饰符"></a>静态变量的访问修饰符</h3><p>静态变量的访问修饰符可以是 public、protected、private 或者默认的访问修饰符（即不写访问修饰符）。</p>
<p>需要注意的是，静态变量的访问权限与实例变量不同，因为静态变量是与类相关的，不依赖于任何实例。</p>
<h3 id="静态变量的线程安全性"><a href="#静态变量的线程安全性" class="headerlink" title="静态变量的线程安全性"></a>静态变量的线程安全性</h3><p>Java 中的静态变量是属于类的，而不是对象的实例。因此，当多个线程同时访问一个包含静态变量的类时，需要考虑其线程安全性。</p>
<p>静态变量在内存中只有一份拷贝，被所有实例共享。因此，如果一个线程修改了静态变量的值，那么其他线程在访问该静态变量时也会看到修改后的值。这可能会导致并发访问的问题，因为多个线程可能同时修改静态变量，导致不确定的结果或数据一致性问题。</p>
<p>为了确保静态变量的线程安全性，需要采取适当的同步措施，如同步机制、原子类或 volatile 关键字，以便在多线程环境中正确地读取和修改静态变量的值。</p>
<h3 id="静态变量的命名规范"><a href="#静态变量的命名规范" class="headerlink" title="静态变量的命名规范"></a>静态变量的命名规范</h3><p>静态变量的命名规范与实例变量相同，一般采用驼峰命名法，并且要用 static 关键字明确标识。例如：</p>
<h2 id="实例-5"><a href="#实例-5" class="headerlink" title="实例"></a>实例</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> 	<span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span>	<span class="type">int</span> <span class="variable">MAX_COUNT</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">  <span class="comment">// 其他成员变量和方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="静态变量的使用场景"><a href="#静态变量的使用场景" class="headerlink" title="静态变量的使用场景"></a>静态变量的使用场景</h3><p>静态变量通常用于以下场景：</p>
<ul>
<li>存储全局状态或配置信息</li>
<li>计数器或统计信息</li>
<li>缓存数据或共享资源</li>
<li>工具类的常量或方法</li>
<li>单例模式中的实例变量</li>
</ul>
<h1 id="Java-修饰符"><a href="#Java-修饰符" class="headerlink" title="Java 修饰符"></a>Java 修饰符</h1><p>Java语言提供了很多修饰符，主要分为以下两类：</p>
<ul>
<li>访问修饰符</li>
<li>非访问修饰符</li>
</ul>
<p>修饰符用来定义类、方法或者变量，通常放在语句的最前端。我们通过下面的例子来说明：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ClassName</span> &#123;</span><br><span class="line">   <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> myFlag;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">double</span> <span class="variable">weeks</span> <span class="operator">=</span> <span class="number">9.5</span>;</span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">BOXWIDTH</span> <span class="operator">=</span> <span class="number">42</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] arguments)</span> &#123;</span><br><span class="line">   <span class="comment">// 方法体</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="访问控制修饰符"><a href="#访问控制修饰符" class="headerlink" title="访问控制修饰符"></a>访问控制修饰符</h2><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="C:\Users\16564\AppData\Roaming\Typora\typora-user-images\image-20231002151817673.png" alt="image-20231002151817673"></p>
<h3 id="默认访问修饰符-不使用任何关键字"><a href="#默认访问修饰符-不使用任何关键字" class="headerlink" title="默认访问修饰符-不使用任何关键字"></a>默认访问修饰符-不使用任何关键字</h3><p>如果在类、变量、方法或构造函数的定义中没有指定任何访问修饰符，那么它们就默认具有默认访问修饰符。</p>
<p>默认访问修饰符的访问级别是包级别（package-level），即只能被同一包中的其他类访问。</p>
<h3 id="私有访问修饰符-private"><a href="#私有访问修饰符-private" class="headerlink" title="私有访问修饰符-private"></a>私有访问修饰符-private</h3><p>私有访问修饰符是最严格的访问级别，所以被声明为 <strong>private</strong> 的方法、变量和构造方法只能被所属类访问，并且类和接口不能声明为 <strong>private</strong>。</p>
<p>声明为私有访问类型的变量只能通过类中公共的 getter 方法被外部类访问。</p>
<p>Private 访问修饰符的使用主要用来隐藏类的实现细节和保护类的数据。</p>
<h3 id="公有访问修饰符-public"><a href="#公有访问修饰符-public" class="headerlink" title="公有访问修饰符-public"></a>公有访问修饰符-public</h3><p>被声明为 public 的类、方法、构造方法和接口能够被任何其他类访问。</p>
<p>如果几个相互访问的 public 类分布在不同的包中，则需要导入相应 public 类所在的包。由于类的继承性，类所有的公有方法和变量都能被其子类继承。</p>
<h3 id="受保护的访问修饰符-protected"><a href="#受保护的访问修饰符-protected" class="headerlink" title="受保护的访问修饰符-protected"></a>受保护的访问修饰符-protected</h3><p>protected 需要从以下两个点来分析说明：</p>
<ul>
<li><strong>子类与基类在同一包中</strong>：被声明为 protected 的变量、方法和构造器能被同一个包中的任何其他类访问；</li>
<li><strong>子类与基类不在同一包中</strong>：那么在子类中，子类实例可以访问其从基类继承而来的 protected 方法，而不能访问基类实例的protected方法。</li>
</ul>
<p>protected 可以修饰数据成员，构造方法，方法成员，<strong>不能修饰类（内部类除外）</strong>。</p>
<h3 id="访问控制和继承"><a href="#访问控制和继承" class="headerlink" title="访问控制和继承"></a>访问控制和继承</h3><p>请注意以下方法继承的规则：</p>
<ul>
<li>父类中声明为 public 的方法在子类中也必须为 public。</li>
<li>父类中声明为 protected 的方法在子类中要么声明为 protected，要么声明为 public，不能声明为 private。</li>
<li>父类中声明为 private 的方法，不能够被子类继承。</li>
</ul>
<h2 id="非访问修饰符"><a href="#非访问修饰符" class="headerlink" title="非访问修饰符"></a>非访问修饰符</h2><p>为了实现一些其他的功能，Java 也提供了许多非访问修饰符。</p>
<p>static 修饰符，用来修饰类方法和类变量。</p>
<p>final 修饰符，用来修饰类、方法和变量，final 修饰的类不能够被继承，修饰的方法不能被继承类重新定义，修饰的变量为常量，是不可修改的。</p>
<p>abstract 修饰符，用来创建抽象类和抽象方法。</p>
<p>synchronized 和 volatile 修饰符，主要用于线程的编程。</p>
<h3 id="static-修饰符"><a href="#static-修饰符" class="headerlink" title="static 修饰符"></a>static 修饰符</h3><ul>
<li><p><strong>静态变量：</strong></p>
<p>static 关键字用来声明独立于对象的静态变量，无论一个类实例化多少对象，它的静态变量只有一份拷贝。 静态变量也被称为类变量。局部变量不能被声明为 static 变量。</p>
</li>
<li><p><strong>静态方法：</strong></p>
<p>static 关键字用来声明独立于对象的静态方法。静态方法不能使用类的非静态变量。静态方法从参数列表得到数据，然后计算这些数据。</p>
</li>
</ul>
<p>对类变量和方法的访问可以直接使用 <strong>classname.variablename</strong> 和 <strong>classname.methodname</strong> 的方式访问。</p>
<h3 id="final-修饰符"><a href="#final-修饰符" class="headerlink" title="final 修饰符"></a>final 修饰符</h3><p><strong>final 变量：</strong></p>
<p>final 表示”最后的、最终的”含义，变量一旦赋值后，不能被重新赋值。被 final 修饰的实例变量必须显式指定初始值。</p>
<p>final 修饰符通常和 static 修饰符一起使用来创建类常量。</p>
<p><strong>final 方法</strong></p>
<p>父类中的 final 方法可以被子类继承，但是不能被子类重写。</p>
<p>声明 final 方法的主要目的是防止该方法的内容被修改。</p>
<p><strong>final 类</strong></p>
<p>final 类不能被继承，没有类能够继承 final 类的任何特性。</p>
<h3 id="abstract-修饰符"><a href="#abstract-修饰符" class="headerlink" title="abstract 修饰符"></a>abstract 修饰符</h3><p><strong>抽象类：</strong></p>
<p>抽象类不能用来实例化对象，声明抽象类的唯一目的是为了将来对该类进行扩充。</p>
<p>一个类不能同时被 abstract 和 final 修饰。如果一个类包含抽象方法，那么该类一定要声明为抽象类，否则将出现编译错误。</p>
<p>抽象类可以包含抽象方法和非抽象方法。</p>
<p><strong>抽象方法</strong></p>
<p>抽象方法是一种没有任何实现的方法，该方法的具体实现由子类提供。</p>
<p>抽象方法不能被声明成 final 和 static。</p>
<p>任何继承抽象类的子类必须实现父类的所有抽象方法，除非该子类也是抽象类。</p>
<p>如果一个类包含若干个抽象方法，那么该类必须声明为抽象类。抽象类可以不包含抽象方法。</p>
<p>抽象方法的声明以分号结尾，例如：**public abstract sample();**。</p>
<p>其他修饰：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="C:\Users\16564\AppData\Roaming\Typora\typora-user-images\image-20231002155346363.png" alt="image-20231002155346363"></p>
<h1 id="Java-运算符"><a href="#Java-运算符" class="headerlink" title="Java 运算符"></a>Java 运算符</h1><p>计算机的最基本用途之一就是执行数学运算，作为一门计算机语言，Java也提供了一套丰富的运算符来操纵变量。我们可以把运算符分成以下几组：</p>
<ul>
<li>算术运算符</li>
<li>关系运算符</li>
<li>位运算符</li>
<li>逻辑运算符</li>
<li>赋值运算符</li>
<li>其他运算符</li>
</ul>
<h2 id="算术运算符"><a href="#算术运算符" class="headerlink" title="算术运算符"></a>算术运算符</h2><p>算术运算符用在数学表达式中，它们的作用和在数学中的作用一样。下表列出了所有的算术运算符。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="C:\Users\16564\AppData\Roaming\Typora\typora-user-images\image-20231002155732868.png" alt="image-20231002155732868"></p>
<h2 id="关系运算符"><a href="#关系运算符" class="headerlink" title="关系运算符"></a>关系运算符</h2><p>下表为Java支持的关系运算符</p>
<p>表格中的实例整数变量A的值为10，变量B的值为20：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="C:\Users\16564\AppData\Roaming\Typora\typora-user-images\image-20231002155807873.png" alt="image-20231002155807873"></p>
<h2 id="位运算符"><a href="#位运算符" class="headerlink" title="位运算符"></a>位运算符</h2><p>Java定义了位运算符，应用于整数类型(int)，长整型(long)，短整型(short)，字符型(char)，和字节型(byte)等类型。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="C:\Users\16564\AppData\Roaming\Typora\typora-user-images\image-20231002155838575.png" alt="image-20231002155838575"></p>
<h2 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h2><p>下表列出了逻辑运算符的基本运算，假设布尔变量A为真，变量B为假</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="C:\Users\16564\AppData\Roaming\Typora\typora-user-images\image-20231002155935599.png" alt="image-20231002155935599"></p>
<h3 id="短路逻辑运算符"><a href="#短路逻辑运算符" class="headerlink" title="短路逻辑运算符"></a>短路逻辑运算符</h3><p>当使用与逻辑运算符时，在两个操作数都为true时，结果才为true，但是当得到第一个操作为false时，其结果就必定是false，这时候就不会再判断第二个操作了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LuoJi</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">5</span>;<span class="comment">//定义一个变量；</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">b</span> <span class="operator">=</span> (a&lt;<span class="number">4</span>)&amp;&amp;(a++&lt;<span class="number">10</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;使用短路逻辑运算符的结果为&quot;</span>+b);</span><br><span class="line">        System.out.println(<span class="string">&quot;a的结果为&quot;</span>+a);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="赋值运算符"><a href="#赋值运算符" class="headerlink" title="赋值运算符"></a>赋值运算符</h2><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="C:\Users\16564\AppData\Roaming\Typora\typora-user-images\image-20231002160740942.png" alt="image-20231002160740942"></p>
<h2 id="条件运算符（-）"><a href="#条件运算符（-）" class="headerlink" title="条件运算符（?:）"></a>条件运算符（?:）</h2><p>条件运算符也被称为三元运算符。该运算符有3个操作数，并且需要判断布尔表达式的值。该运算符的主要是决定哪个值应该赋值给变量。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">      <span class="type">int</span> a , b;</span><br><span class="line">      a = <span class="number">10</span>;</span><br><span class="line">      <span class="comment">// 如果 a 等于 1 成立，则设置 b 为 20，否则为 30</span></span><br><span class="line">      b = (a == <span class="number">1</span>) ? <span class="number">20</span> : <span class="number">30</span>;</span><br><span class="line">      System.out.println( <span class="string">&quot;Value of b is : &quot;</span> +  b );</span><br><span class="line"> </span><br><span class="line">      <span class="comment">// 如果 a 等于 10 成立，则设置 b 为 20，否则为 30</span></span><br><span class="line">      b = (a == <span class="number">10</span>) ? <span class="number">20</span> : <span class="number">30</span>;</span><br><span class="line">      System.out.println( <span class="string">&quot;Value of b is : &quot;</span> + b );</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="instanceof-运算符"><a href="#instanceof-运算符" class="headerlink" title="instanceof 运算符"></a>instanceof 运算符</h2><p>该运算符用于操作对象实例，检查该对象是否是一个特定类型（类类型或接口类型）。</p>
<p>instanceof运算符使用格式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">( Object reference variable ) instanceof  (class/interface type)</span><br></pre></td></tr></table></figure>

<p>如果运算符左侧变量所指的对象，是操作符右侧类或接口(class&#x2F;interface)的一个对象，那么结果为真。</p>
<p>下面是一个例子：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">String name = &quot;James&quot;;</span><br><span class="line">boolean result = name instanceof String; // 由于 name 是 String 类型，所以返回真</span><br></pre></td></tr></table></figure>

<p>如果被比较的对象兼容于右侧类型，该运算符仍然返回 true。</p>
<h2 id="Java运算符优先级"><a href="#Java运算符优先级" class="headerlink" title="Java运算符优先级"></a>Java运算符优先级</h2><p>当多个运算符出现在一个表达式中，谁先谁后呢？这就涉及到运算符的优先级别的问题。在一个多运算符的表达式中，运算符优先级不同会导致最后得出的结果差别甚大。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="C:\Users\16564\AppData\Roaming\Typora\typora-user-images\image-20231002160933832.png" alt="image-20231002160933832"></p>
<h1 id="Java-循环结构-for-while-及-do…while"><a href="#Java-循环结构-for-while-及-do…while" class="headerlink" title="Java 循环结构 - for, while 及 do…while"></a>Java 循环结构 - for, while 及 do…while</h1><p>顺序结构的程序语句只能被执行一次。</p>
<p>如果您想要同样的操作执行多次，就需要使用循环结构。</p>
<p>Java中有三种主要的循环结构：</p>
<ul>
<li><strong>while</strong> 循环</li>
<li><strong>do…while</strong> 循环</li>
<li><strong>for</strong> 循环</li>
</ul>
<p>在 Java5 中引入了一种主要用于数组的增强型 for 循环。</p>
<h2 id="while-循环"><a href="#while-循环" class="headerlink" title="while 循环"></a>while 循环</h2><p>while是最基本的循环，它的结构为：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>( 布尔表达式 ) &#123;</span><br><span class="line">  <span class="comment">//循环内容</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="do…while-循环"><a href="#do…while-循环" class="headerlink" title="do…while 循环"></a>do…while 循环</h2><p>对于 while 语句而言，如果不满足条件，则不能进入循环。但有时候我们需要即使不满足条件，也至少执行一次。</p>
<p>do…while 循环和 while 循环相似，不同的是，do…while 循环至少会执行一次。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">       <span class="comment">//代码语句</span></span><br><span class="line">&#125;<span class="keyword">while</span>(布尔表达式);</span><br></pre></td></tr></table></figure>

<h2 id="for循环"><a href="#for循环" class="headerlink" title="for循环"></a>for循环</h2><p>虽然所有循环结构都可以用 while 或者 do…while表示，但 Java 提供了另一种语句 —— for 循环，使一些循环结构变得更加简单。</p>
<p>for循环执行的次数是在执行前就确定的。语法格式如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(初始化; 布尔表达式; 更新) &#123;</span><br><span class="line">    <span class="comment">//代码语句</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>关于 for 循环有以下几点说明：</p>
<ul>
<li>最先执行初始化步骤。可以声明一种类型，但可初始化一个或多个循环控制变量，也可以是空语句。</li>
<li>然后，检测布尔表达式的值。如果为 true，循环体被执行。如果为false，循环终止，开始执行循环体后面的语句。</li>
<li>执行一次循环后，更新循环控制变量。</li>
<li>再次检测布尔表达式。循环执行上面的过程。</li>
</ul>
<h2 id="Java-增强-for-循环"><a href="#Java-增强-for-循环" class="headerlink" title="Java 增强 for 循环"></a>Java 增强 for 循环</h2><p>Java5 引入了一种主要用于数组的增强型 for 循环。</p>
<p>Java 增强 for 循环语法格式如下:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(声明语句 : 表达式) &#123;   </span><br><span class="line">	<span class="comment">//代码句子 </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>声明语句：</strong>声明新的局部变量，该变量的类型必须和数组元素的类型匹配。其作用域限定在循环语句块，其值与此时数组元素的值相等。</p>
<p><strong>表达式：</strong>表达式是要访问的数组名，或者是返回值为数组的方法。</p>
<h3 id="实例-6"><a href="#实例-6" class="headerlink" title="实例"></a>实例</h3><h2 id="Test-java-文件代码："><a href="#Test-java-文件代码：" class="headerlink" title="Test.java 文件代码："></a>Test.java 文件代码：</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">      <span class="type">int</span> [] numbers = &#123;<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>, <span class="number">50</span>&#125;;</span><br><span class="line"> </span><br><span class="line">      <span class="keyword">for</span>(<span class="type">int</span> x : numbers )&#123;</span><br><span class="line">         System.out.print( x );</span><br><span class="line">         System.out.print(<span class="string">&quot;,&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      System.out.print(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">      String [] names =&#123;<span class="string">&quot;James&quot;</span>, <span class="string">&quot;Larry&quot;</span>, <span class="string">&quot;Tom&quot;</span>, <span class="string">&quot;Lacy&quot;</span>&#125;;</span><br><span class="line">      <span class="keyword">for</span>( String name : names ) &#123;</span><br><span class="line">         System.out.print( name );</span><br><span class="line">         System.out.print(<span class="string">&quot;,&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上实例编译运行结果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">10,20,30,40,50,</span><br><span class="line">James,Larry,Tom,Lacy,</span><br></pre></td></tr></table></figure>

<h2 id="break-关键字"><a href="#break-关键字" class="headerlink" title="break 关键字"></a>break 关键字</h2><p>break 主要用在循环语句或者 switch 语句中，用来跳出整个语句块。</p>
<p>break 跳出最里层的循环，并且继续执行该循环下面的语句。</p>
<h2 id="continue-关键字"><a href="#continue-关键字" class="headerlink" title="continue 关键字"></a>continue 关键字</h2><p>continue 适用于任何循环控制结构中。作用是让程序立刻跳转到下一次循环的迭代。</p>
<p>在 for 循环中，continue 语句使程序立即跳转到更新语句。</p>
<p>在 while 或者 do…while 循环中，程序立即跳转到布尔表达式的判断语句。</p>
<h1 id="Java-条件语句-if…else"><a href="#Java-条件语句-if…else" class="headerlink" title="Java 条件语句 - if…else"></a>Java 条件语句 - if…else</h1><p>Java 中的条件语句允许程序根据条件的不同执行不同的代码块。</p>
<p>一个 if 语句包含一个布尔表达式和一条或多条语句。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(布尔表达式)</span><br><span class="line">&#123;</span><br><span class="line">   <span class="comment">//如果布尔表达式为true将执行的语句</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="if…else语句"><a href="#if…else语句" class="headerlink" title="if…else语句"></a>if…else语句</h2><p>if 语句后面可以跟 else 语句，当 if 语句的布尔表达式值为 false 时，else 语句块会被执行。</p>
<h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(布尔表达式)&#123;</span><br><span class="line">   <span class="comment">//如果布尔表达式的值为true</span></span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">   <span class="comment">//如果布尔表达式的值为false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="if…else-if…else-语句"><a href="#if…else-if…else-语句" class="headerlink" title="if…else if…else 语句"></a>if…else if…else 语句</h2><p>if 语句后面可以跟 else if…else 语句，这种语句可以检测到多种可能的情况。</p>
<p>使用 if，else if，else 语句的时候，需要注意下面几点：</p>
<ul>
<li>if 语句至多有 1 个 else 语句，else 语句在所有的 else if 语句之后。</li>
<li>if 语句可以有若干个 else if 语句，它们必须在 else 语句之前。</li>
<li>一旦其中一个 else if 语句检测为 true，其他的 else if 以及 else 语句都将跳过执行。</li>
</ul>
<h2 id="嵌套的-if…else-语句"><a href="#嵌套的-if…else-语句" class="headerlink" title="嵌套的 if…else 语句"></a>嵌套的 if…else 语句</h2><p>使用嵌套的 if…else 语句是合法的。也就是说你可以在另一个 if 或者 else if 语句中使用 if 或者 else if 语句。</p>
<h3 id="语法-1"><a href="#语法-1" class="headerlink" title="语法"></a>语法</h3><p>嵌套的 if…else 语法格式如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(布尔表达式 <span class="number">1</span>)&#123;</span><br><span class="line">   <span class="comment">////如果布尔表达式 1的值为true执行代码</span></span><br><span class="line">   <span class="keyword">if</span>(布尔表达式 <span class="number">2</span>)&#123;</span><br><span class="line">      <span class="comment">////如果布尔表达式 2的值为true执行代码</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Java-switch-case-语句"><a href="#Java-switch-case-语句" class="headerlink" title="Java switch case 语句"></a>Java switch case 语句</h1><p>switch case 语句判断一个变量与一系列值中某个值是否相等，每个值称为一个分支。</p>
<h3 id="语法-2"><a href="#语法-2" class="headerlink" title="语法"></a>语法</h3><p>switch case 语句语法格式如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">switch</span>(expression)&#123;</span><br><span class="line">    <span class="keyword">case</span> value :</span><br><span class="line">       <span class="comment">//语句</span></span><br><span class="line">       <span class="keyword">break</span>; <span class="comment">//可选</span></span><br><span class="line">    <span class="keyword">case</span> value :</span><br><span class="line">       <span class="comment">//语句</span></span><br><span class="line">       <span class="keyword">break</span>; <span class="comment">//可选</span></span><br><span class="line">    <span class="comment">//你可以有任意数量的case语句</span></span><br><span class="line">    <span class="keyword">default</span> : <span class="comment">//可选</span></span><br><span class="line">       <span class="comment">//语句</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>switch case 语句有如下规则：</p>
<ul>
<li>switch 语句中的变量类型可以是： byte、short、int 或者 char。从 Java SE 7 开始，switch 支持字符串 String 类型了，同时 case 标签必须为字符串常量或字面量。</li>
<li>switch 语句可以拥有多个 case 语句。每个 case 后面跟一个要比较的值和冒号。</li>
<li>case 语句中的值的数据类型必须与变量的数据类型相同，而且只能是常量或者字面常量。</li>
<li>当变量的值与 case 语句的值相等时，那么 case 语句之后的语句开始执行，直到 break 语句出现才会跳出 switch 语句。</li>
<li>当遇到 break 语句时，switch 语句终止。程序跳转到 switch 语句后面的语句执行。case 语句不必须要包含 break 语句。如果没有 break 语句出现，程序会继续执行下一条 case 语句，直到出现 break 语句。</li>
<li>switch 语句可以包含一个 default 分支，该分支一般是 switch 语句的最后一个分支（可以在任何位置，但建议在最后一个）。default 在没有 case 语句的值和变量值相等的时候执行。default 分支不需要 break 语句。</li>
</ul>
<h1 id="Java-Number-Math-类"><a href="#Java-Number-Math-类" class="headerlink" title="Java Number &amp; Math 类"></a>Java Number &amp; Math 类</h1><p>一般地，当需要使用数字的时候，我们通常使用内置数据类型，如：<strong>byte、int、long、double</strong> 等。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="C:\Users\16564\AppData\Roaming\Typora\typora-user-images\image-20231002165716077.png" alt="image-20231002165716077"></p>
<h2 id="Java-Math-类"><a href="#Java-Math-类" class="headerlink" title="Java Math 类"></a>Java Math 类</h2><p>Java 的 Math 包含了用于执行基本数学运算的属性和方法，如初等指数、对数、平方根和三角函数。</p>
<p>Math 的方法都被定义为 static 形式，通过 Math 类可以在主函数中直接调用。</p>
<h2 id="Number-Math-类方法"><a href="#Number-Math-类方法" class="headerlink" title="Number &amp; Math 类方法"></a>Number &amp; Math 类方法</h2><p>下面的表中列出的是 Number &amp; Math 类常用的一些方法：</p>
<table>
<thead>
<tr>
<th align="left">序号</th>
<th align="left">方法与描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">1</td>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/java/number-xxxvalue.html">xxxValue()</a> 将 Number 对象转换为xxx数据类型的值并返回。</td>
</tr>
<tr>
<td align="left">2</td>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/java/number-compareto.html">compareTo()</a> 将number对象与参数比较。</td>
</tr>
<tr>
<td align="left">3</td>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/java/number-equals.html">equals()</a> 判断number对象是否与参数相等。</td>
</tr>
<tr>
<td align="left">4</td>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/java/number-valueof.html">valueOf()</a> 返回一个 Number 对象指定的内置数据类型</td>
</tr>
<tr>
<td align="left">5</td>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/java/number-tostring.html">toString()</a> 以字符串形式返回值。</td>
</tr>
<tr>
<td align="left">6</td>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/java/number-parseInt.html">parseInt()</a> 将字符串解析为int类型。</td>
</tr>
<tr>
<td align="left">7</td>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/java/number-abs.html">abs()</a> 返回参数的绝对值。</td>
</tr>
<tr>
<td align="left">8</td>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/java/number-ceil.html">ceil()</a> 返回大于等于( &gt;&#x3D; )给定参数的的最小整数，类型为双精度浮点型。</td>
</tr>
<tr>
<td align="left">9</td>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/java/number-floor.html">floor()</a> 返回小于等于（&lt;&#x3D;）给定参数的最大整数 。</td>
</tr>
<tr>
<td align="left">10</td>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/java/number-rint.html">rint()</a> 返回与参数最接近的整数。返回类型为double。</td>
</tr>
<tr>
<td align="left">11</td>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/java/number-round.html">round()</a> 它表示<strong>四舍五入</strong>，算法为 **Math.floor(x+0.5)**，即将原来的数字加上 0.5 后再向下取整，所以，Math.round(11.5) 的结果为12，Math.round(-11.5) 的结果为-11。</td>
</tr>
<tr>
<td align="left">12</td>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/java/number-min.html">min()</a> 返回两个参数中的最小值。</td>
</tr>
<tr>
<td align="left">13</td>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/java/number-max.html">max()</a> 返回两个参数中的最大值。</td>
</tr>
<tr>
<td align="left">14</td>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/java/number-exp.html">exp()</a> 返回自然数底数e的参数次方。</td>
</tr>
<tr>
<td align="left">15</td>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/java/number-log.html">log()</a> 返回参数的自然数底数的对数值。</td>
</tr>
<tr>
<td align="left">16</td>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/java/number-pow.html">pow()</a> 返回第一个参数的第二个参数次方。</td>
</tr>
<tr>
<td align="left">17</td>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/java/number-sqrt.html">sqrt()</a> 求参数的算术平方根。</td>
</tr>
<tr>
<td align="left">18</td>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/java/number-sin.html">sin()</a> 求指定double类型参数的正弦值。</td>
</tr>
<tr>
<td align="left">19</td>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/java/number-cos.html">cos()</a> 求指定double类型参数的余弦值。</td>
</tr>
<tr>
<td align="left">20</td>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/java/number-tan.html">tan()</a> 求指定double类型参数的正切值。</td>
</tr>
<tr>
<td align="left">21</td>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/java/number-asin.html">asin()</a> 求指定double类型参数的反正弦值。</td>
</tr>
<tr>
<td align="left">22</td>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/java/number-acos.html">acos()</a> 求指定double类型参数的反余弦值。</td>
</tr>
<tr>
<td align="left">23</td>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/java/number-atan.html">atan()</a> 求指定double类型参数的反正切值。</td>
</tr>
<tr>
<td align="left">24</td>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/java/number-atan2.html">atan2()</a> 将笛卡尔坐标转换为极坐标，并返回极坐标的角度值。</td>
</tr>
<tr>
<td align="left">25</td>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/java/number-todegrees.html">toDegrees()</a> 将参数转化为角度。</td>
</tr>
<tr>
<td align="left">26</td>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/java/number-toradians.html">toRadians()</a> 将角度转换为弧度。</td>
</tr>
<tr>
<td align="left">27</td>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/java/number-random.html">random()</a> 返回一个随机数。</td>
</tr>
</tbody></table>
<h1 id="Java-Character-类"><a href="#Java-Character-类" class="headerlink" title="Java Character 类"></a>Java Character 类</h1><p>Character 类用于对单个字符进行操作。</p>
<p>Character 类在对象中包装一个基本类型 <strong>char</strong> 的值</p>
<h2 id="转义序列"><a href="#转义序列" class="headerlink" title="转义序列"></a>转义序列</h2><p>前面有反斜杠（\）的字符代表转义字符，它对编译器来说是有特殊含义的。</p>
<p>下面列表展示了Java的转义序列：</p>
<table>
<thead>
<tr>
<th align="left">转义序列</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">\t</td>
<td align="left">在文中该处插入一个tab键</td>
</tr>
<tr>
<td align="left">\b</td>
<td align="left">在文中该处插入一个后退键</td>
</tr>
<tr>
<td align="left">\n</td>
<td align="left">在文中该处换行</td>
</tr>
<tr>
<td align="left">\r</td>
<td align="left">在文中该处插入回车</td>
</tr>
<tr>
<td align="left">\f</td>
<td align="left">在文中该处插入换页符</td>
</tr>
<tr>
<td align="left">&#39;</td>
<td align="left">在文中该处插入单引号</td>
</tr>
<tr>
<td align="left">&quot;</td>
<td align="left">在文中该处插入双引号</td>
</tr>
<tr>
<td align="left">\</td>
<td align="left">在文中该处插入反斜杠</td>
</tr>
</tbody></table>
<h2 id="Character-方法"><a href="#Character-方法" class="headerlink" title="Character 方法"></a>Character 方法</h2><p>下面是Character类的方法：</p>
<table>
<thead>
<tr>
<th align="left">序号</th>
<th align="left">方法与描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">1</td>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/java/character-isletter.html">isLetter()</a> 是否是一个字母</td>
</tr>
<tr>
<td align="left">2</td>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/java/character-isdigit.html">isDigit()</a> 是否是一个数字字符</td>
</tr>
<tr>
<td align="left">3</td>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/java/character-iswhitespace.html">isWhitespace()</a> 是否是一个空白字符</td>
</tr>
<tr>
<td align="left">4</td>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/java/character-isuppercase.html">isUpperCase()</a> 是否是大写字母</td>
</tr>
<tr>
<td align="left">5</td>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/java/character-islowercase.html">isLowerCase()</a> 是否是小写字母</td>
</tr>
<tr>
<td align="left">6</td>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/java/character-touppercase.html">toUpperCase()</a> 指定字母的大写形式</td>
</tr>
<tr>
<td align="left">7</td>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/java/character-tolowercase.html">toLowerCase</a>() 指定字母的小写形式</td>
</tr>
<tr>
<td align="left">8</td>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/java/character-tostring.html">toString</a>() 返回字符的字符串形式，字符串的长度仅为1</td>
</tr>
</tbody></table>
<h1 id="Java-String-类"><a href="#Java-String-类" class="headerlink" title="Java String 类"></a>Java String 类</h1><p>字符串广泛应用 在 Java 编程中，在 Java 中字符串属于对象，Java 提供了 String 类来创建和操作字符串。</p>
<hr>
<h2 id="创建字符串"><a href="#创建字符串" class="headerlink" title="创建字符串"></a>创建字符串</h2><p>创建字符串最简单的方式如下:</p>
<p>String str &#x3D; “Runoob”;</p>
<p>在代码中遇到字符串常量时，这里的值是 “<strong>Runoob</strong>“，编译器会使用该值创建一个 String 对象。</p>
<p>和其它对象一样，可以使用关键字和构造方法来创建 String 对象。</p>
<p>用构造函数创建字符串：</p>
<p>String str2&#x3D;new String(“Runoob”);</p>
<p>String 创建的字符串存储在公共池中，而 new 创建的字符串对象在堆上：</p>
<p>String s1 &#x3D; “Runoob”;              &#x2F;&#x2F; String 直接创建 String s2 &#x3D; “Runoob”;              &#x2F;&#x2F; String 直接创建 String s3 &#x3D; s1;                    &#x2F;&#x2F; 相同引用 String s4 &#x3D; new String(“Runoob”);   &#x2F;&#x2F; String 对象创建 String s5 &#x3D; new String(“Runoob”);   &#x2F;&#x2F; String 对象创建</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="C:\Users\16564\AppData\Roaming\Typora\typora-user-images\image-20231002170230902.png" alt="image-20231002170230902"></p>
<h2 id="String-方法"><a href="#String-方法" class="headerlink" title="String 方法"></a>String 方法</h2><p>下面是 String 类支持的方法，更多详细，参看 <a target="_blank" rel="noopener" href="https://www.runoob.com/manual/jdk11api/java.base/java/lang/String.html">Java String API</a> 文档:</p>
<table>
<thead>
<tr>
<th align="left">SN(序号)</th>
<th align="left">方法描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">1</td>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/java/java-string-charat.html">char charAt(int index)</a> 返回指定索引处的 char 值。</td>
</tr>
<tr>
<td align="left">2</td>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/java/java-string-compareto.html">int compareTo(Object o)</a> 把这个字符串和另一个对象比较。</td>
</tr>
<tr>
<td align="left">3</td>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/java/java-string-compareto.html">int compareTo(String anotherString)</a> 按字典顺序比较两个字符串。</td>
</tr>
<tr>
<td align="left">4</td>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/java/java-string-comparetoignorecase.html">int compareToIgnoreCase(String str)</a> 按字典顺序比较两个字符串，不考虑大小写。</td>
</tr>
<tr>
<td align="left">5</td>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/java/java-string-concat.html">String concat(String str)</a> 将指定字符串连接到此字符串的结尾。</td>
</tr>
<tr>
<td align="left">6</td>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/java/java-string-contentequals.html">boolean contentEquals(StringBuffer sb)</a> 当且仅当字符串与指定的StringBuffer有相同顺序的字符时候返回真。</td>
</tr>
<tr>
<td align="left">7</td>
<td align="left">[static String copyValueOf(char<a target="_blank" rel="noopener" href="https://www.runoob.com/java/java-string-copyvalueof.html">] data)</a> 返回指定数组中表示该字符序列的 String。</td>
</tr>
<tr>
<td align="left">8</td>
<td align="left">[static String copyValueOf(char<a target="_blank" rel="noopener" href="https://www.runoob.com/java/java-string-copyvalueof.html">] data, int offset, int count)</a> 返回指定数组中表示该字符序列的 String。</td>
</tr>
<tr>
<td align="left">9</td>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/java/java-string-endswith.html">boolean endsWith(String suffix)</a> 测试此字符串是否以指定的后缀结束。</td>
</tr>
<tr>
<td align="left">10</td>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/java/java-string-equals.html">boolean equals(Object anObject)</a> 将此字符串与指定的对象比较。</td>
</tr>
<tr>
<td align="left">11</td>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/java/java-string-equalsignorecase.html">boolean equalsIgnoreCase(String anotherString)</a> 将此 String 与另一个 String 比较，不考虑大小写。</td>
</tr>
<tr>
<td align="left">12</td>
<td align="left">[byte<a target="_blank" rel="noopener" href="https://www.runoob.com/java/java-string-getbytes.html">] getBytes()</a>  使用平台的默认字符集将此 String 编码为 byte 序列，并将结果存储到一个新的 byte 数组中。</td>
</tr>
<tr>
<td align="left">13</td>
<td align="left">[byte<a target="_blank" rel="noopener" href="https://www.runoob.com/java/java-string-getbytes.html">] getBytes(String charsetName)</a> 使用指定的字符集将此 String 编码为 byte 序列，并将结果存储到一个新的 byte 数组中。</td>
</tr>
<tr>
<td align="left">14</td>
<td align="left">[void getChars(int srcBegin, int srcEnd, char<a target="_blank" rel="noopener" href="https://www.runoob.com/java/java-string-getchars.html">] dst, int dstBegin)</a> 将字符从此字符串复制到目标字符数组。</td>
</tr>
<tr>
<td align="left">15</td>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/java/java-string-hashcode.html">int hashCode()</a> 返回此字符串的哈希码。</td>
</tr>
<tr>
<td align="left">16</td>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/java/java-string-indexof.html">int indexOf(int ch)</a> 返回指定字符在此字符串中第一次出现处的索引。</td>
</tr>
<tr>
<td align="left">17</td>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/java/java-string-indexof.html">int indexOf(int ch, int fromIndex)</a> 返回在此字符串中第一次出现指定字符处的索引，从指定的索引开始搜索。</td>
</tr>
<tr>
<td align="left">18</td>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/java/java-string-indexof.html">int indexOf(String str)</a>  返回指定子字符串在此字符串中第一次出现处的索引。</td>
</tr>
<tr>
<td align="left">19</td>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/java/java-string-indexof.html">int indexOf(String str, int fromIndex)</a> 返回指定子字符串在此字符串中第一次出现处的索引，从指定的索引开始。</td>
</tr>
<tr>
<td align="left">20</td>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/java/java-string-intern.html">String intern()</a>  返回字符串对象的规范化表示形式。</td>
</tr>
<tr>
<td align="left">21</td>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/java/java-string-lastindexof.html">int lastIndexOf(int ch)</a>  返回指定字符在此字符串中最后一次出现处的索引。</td>
</tr>
<tr>
<td align="left">22</td>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/java/java-string-lastindexof.html">int lastIndexOf(int ch, int fromIndex)</a> 返回指定字符在此字符串中最后一次出现处的索引，从指定的索引处开始进行反向搜索。</td>
</tr>
<tr>
<td align="left">23</td>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/java/java-string-lastindexof.html">int lastIndexOf(String str)</a> 返回指定子字符串在此字符串中最右边出现处的索引。</td>
</tr>
<tr>
<td align="left">24</td>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/java/java-string-lastindexof.html">int lastIndexOf(String str, int fromIndex)</a>  返回指定子字符串在此字符串中最后一次出现处的索引，从指定的索引开始反向搜索。</td>
</tr>
<tr>
<td align="left">25</td>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/java/java-string-length.html">int length()</a> 返回此字符串的长度。</td>
</tr>
<tr>
<td align="left">26</td>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/java/java-string-matches.html">boolean matches(String regex)</a> 告知此字符串是否匹配给定的正则表达式。</td>
</tr>
<tr>
<td align="left">27</td>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/java/java-string-regionmatches.html">boolean regionMatches(boolean ignoreCase, int toffset, String other, int ooffset, int len)</a> 测试两个字符串区域是否相等。</td>
</tr>
<tr>
<td align="left">28</td>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/java/java-string-regionmatches.html">boolean regionMatches(int toffset, String other, int ooffset, int len)</a> 测试两个字符串区域是否相等。</td>
</tr>
<tr>
<td align="left">29</td>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/java/java-string-replace.html">String replace(char oldChar, char newChar)</a> 返回一个新的字符串，它是通过用 newChar 替换此字符串中出现的所有 oldChar 得到的。</td>
</tr>
<tr>
<td align="left">30</td>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/java/java-string-replaceall.html">String replaceAll(String regex, String replacement)</a> 使用给定的 replacement 替换此字符串所有匹配给定的正则表达式的子字符串。</td>
</tr>
<tr>
<td align="left">31</td>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/java/java-string-replacefirst.html">String replaceFirst(String regex, String replacement)</a>  使用给定的 replacement 替换此字符串匹配给定的正则表达式的第一个子字符串。</td>
</tr>
<tr>
<td align="left">32</td>
<td align="left">[String<a target="_blank" rel="noopener" href="https://www.runoob.com/java/java-string-split.html">] split(String regex)</a> 根据给定正则表达式的匹配拆分此字符串。</td>
</tr>
<tr>
<td align="left">33</td>
<td align="left">[String<a target="_blank" rel="noopener" href="https://www.runoob.com/java/java-string-split.html">] split(String regex, int limit)</a> 根据匹配给定的正则表达式来拆分此字符串。</td>
</tr>
<tr>
<td align="left">34</td>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/java/java-string-startswith.html">boolean startsWith(String prefix)</a> 测试此字符串是否以指定的前缀开始。</td>
</tr>
<tr>
<td align="left">35</td>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/java/java-string-startswith.html">boolean startsWith(String prefix, int toffset)</a> 测试此字符串从指定索引开始的子字符串是否以指定前缀开始。</td>
</tr>
<tr>
<td align="left">36</td>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/java/java-string-subsequence.html">CharSequence subSequence(int beginIndex, int endIndex)</a>  返回一个新的字符序列，它是此序列的一个子序列。</td>
</tr>
<tr>
<td align="left">37</td>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/java/java-string-substring.html">String substring(int beginIndex)</a> 返回一个新的字符串，它是此字符串的一个子字符串。</td>
</tr>
<tr>
<td align="left">38</td>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/java/java-string-substring.html">String substring(int beginIndex, int endIndex)</a> 返回一个新字符串，它是此字符串的一个子字符串。</td>
</tr>
<tr>
<td align="left">39</td>
<td align="left">[char<a target="_blank" rel="noopener" href="https://www.runoob.com/java/java-string-tochararray.html">] toCharArray()</a> 将此字符串转换为一个新的字符数组。</td>
</tr>
<tr>
<td align="left">40</td>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/java/java-string-tolowercase.html">String toLowerCase()</a> 使用默认语言环境的规则将此 String 中的所有字符都转换为小写。</td>
</tr>
<tr>
<td align="left">41</td>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/java/java-string-tolowercase.html">String toLowerCase(Locale locale)</a>  使用给定 Locale 的规则将此 String 中的所有字符都转换为小写。</td>
</tr>
<tr>
<td align="left">42</td>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/java/java-string-tostring.html">String toString()</a>  返回此对象本身（它已经是一个字符串！）。</td>
</tr>
<tr>
<td align="left">43</td>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/java/java-string-touppercase.html">String toUpperCase()</a> 使用默认语言环境的规则将此 String 中的所有字符都转换为大写。</td>
</tr>
<tr>
<td align="left">44</td>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/java/java-string-touppercase.html">String toUpperCase(Locale locale)</a> 使用给定 Locale 的规则将此 String 中的所有字符都转换为大写。</td>
</tr>
<tr>
<td align="left">45</td>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/java/java-string-trim.html">String trim()</a> 返回字符串的副本，忽略前导空白和尾部空白。</td>
</tr>
<tr>
<td align="left">46</td>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/java/java-string-valueof.html">static String valueOf(primitive data type x)</a> 返回给定data type类型x参数的字符串表示形式。</td>
</tr>
<tr>
<td align="left">47</td>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/java/java-string-contains.html">contains(CharSequence chars)</a> 判断是否包含指定的字符系列。</td>
</tr>
<tr>
<td align="left">48</td>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/java/java-string-isempty.html">isEmpty()</a> 判断字符串是否为空。</td>
</tr>
</tbody></table>
<h1 id="Java-StringBuffer-和-StringBuilder-类"><a href="#Java-StringBuffer-和-StringBuilder-类" class="headerlink" title="Java StringBuffer 和 StringBuilder 类"></a>Java StringBuffer 和 StringBuilder 类</h1><p>当对字符串进行修改的时候，需要使用 StringBuffer 和 StringBuilder 类。</p>
<p>和 String 类不同的是，StringBuffer 和 StringBuilder 类的对象能够被多次的修改，并且不产生新的未使用对象。</p>
<p>在使用 StringBuffer 类时，每次都会对 StringBuffer 对象本身进行操作，而不是生成新的对象，所以如果需要对字符串进行修改推荐使用 StringBuffer。</p>
<p>StringBuilder 类在 Java 5 中被提出，它和 StringBuffer 之间的最大不同在于 StringBuilder 的方法不是线程安全的（不能同步访问）。</p>
<p>由于 StringBuilder 相较于 StringBuffer 有速度优势，所以多数情况下建议使用 StringBuilder 类。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="C:\Users\16564\AppData\Roaming\Typora\typora-user-images\image-20231002170435279.png" alt="image-20231002170435279"></p>
<h2 id="StringBuffer-方法"><a href="#StringBuffer-方法" class="headerlink" title="StringBuffer 方法"></a>StringBuffer 方法</h2><p>以下是 StringBuffer 类支持的主要方法：</p>
<table>
<thead>
<tr>
<th align="left">序号</th>
<th align="left">方法描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">1</td>
<td align="left">public StringBuffer append(String s) 将指定的字符串追加到此字符序列。</td>
</tr>
<tr>
<td align="left">2</td>
<td align="left">public StringBuffer reverse()  将此字符序列用其反转形式取代。</td>
</tr>
<tr>
<td align="left">3</td>
<td align="left">public delete(int start, int end) 移除此序列的子字符串中的字符。</td>
</tr>
<tr>
<td align="left">4</td>
<td align="left">public insert(int offset, int i) 将 <code>int</code> 参数的字符串表示形式插入此序列中。</td>
</tr>
<tr>
<td align="left">5</td>
<td align="left">insert(int offset, String str) 将 <code>str</code> 参数的字符串插入此序列中。</td>
</tr>
<tr>
<td align="left">6</td>
<td align="left">replace(int start, int end, String str) 使用给定 <code>String</code> 中的字符替换此序列的子字符串中的字符。</td>
</tr>
</tbody></table>
<p>以下列表列出了 StringBuffer 类的其他常用方法：</p>
<table>
<thead>
<tr>
<th align="left">序号</th>
<th align="left">方法描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">1</td>
<td align="left">int capacity() 返回当前容量。</td>
</tr>
<tr>
<td align="left">2</td>
<td align="left">char charAt(int index) 返回此序列中指定索引处的 <code>char</code> 值。</td>
</tr>
<tr>
<td align="left">3</td>
<td align="left">void ensureCapacity(int minimumCapacity) 确保容量至少等于指定的最小值。</td>
</tr>
<tr>
<td align="left">4</td>
<td align="left">void getChars(int srcBegin, int srcEnd, char[] dst, int dstBegin) 将字符从此序列复制到目标字符数组 <code>dst</code>。</td>
</tr>
<tr>
<td align="left">5</td>
<td align="left">int indexOf(String str) 返回第一次出现的指定子字符串在该字符串中的索引。</td>
</tr>
<tr>
<td align="left">6</td>
<td align="left">int indexOf(String str, int fromIndex) 从指定的索引处开始，返回第一次出现的指定子字符串在该字符串中的索引。</td>
</tr>
<tr>
<td align="left">7</td>
<td align="left">int lastIndexOf(String str) 返回最右边出现的指定子字符串在此字符串中的索引。</td>
</tr>
<tr>
<td align="left">8</td>
<td align="left">int lastIndexOf(String str, int fromIndex) 返回 String 对象中子字符串最后出现的位置。</td>
</tr>
<tr>
<td align="left">9</td>
<td align="left">int length()  返回长度（字符数）。</td>
</tr>
<tr>
<td align="left">10</td>
<td align="left">void setCharAt(int index, char ch) 将给定索引处的字符设置为 <code>ch</code>。</td>
</tr>
<tr>
<td align="left">11</td>
<td align="left">void setLength(int newLength) 设置字符序列的长度。</td>
</tr>
<tr>
<td align="left">12</td>
<td align="left">CharSequence subSequence(int start, int end) 返回一个新的字符序列，该字符序列是此序列的子序列。</td>
</tr>
<tr>
<td align="left">13</td>
<td align="left">String substring(int start) 返回一个新的 <code>String</code>，它包含此字符序列当前所包含的字符子序列。</td>
</tr>
<tr>
<td align="left">14</td>
<td align="left">String substring(int start, int end) 返回一个新的 <code>String</code>，它包含此序列当前所包含的字符子序列。</td>
</tr>
<tr>
<td align="left">15</td>
<td align="left">String toString() 返回此序列中数据的字符串表示形式。</td>
</tr>
</tbody></table>
<h1 id="Java-数组-1"><a href="#Java-数组-1" class="headerlink" title="Java 数组"></a>Java 数组</h1><h2 id="声明数组变量"><a href="#声明数组变量" class="headerlink" title="声明数组变量"></a>声明数组变量</h2><p>首先必须声明数组变量，才能在程序中使用数组。下面是声明数组变量的语法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">dataType[] arrayRefVar;   <span class="comment">// 首选的方法</span></span><br><span class="line"> </span><br><span class="line">或</span><br><span class="line"> </span><br><span class="line">dataType arrayRefVar[];  <span class="comment">// 效果相同，但不是首选方法</span></span><br></pre></td></tr></table></figure>

<h2 id="创建数组"><a href="#创建数组" class="headerlink" title="创建数组"></a>创建数组</h2><p>Java语言使用new操作符来创建数组，语法如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">arrayRefVar = new dataType[arraySize];</span><br></pre></td></tr></table></figure>

<p>上面的语法语句做了两件事：</p>
<ul>
<li>一、使用 dataType[arraySize] 创建了一个数组。</li>
<li>二、把新创建的数组的引用赋值给变量 arrayRefVar。</li>
</ul>
<p>数组变量的声明，和创建数组可以用一条语句完成，如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">dataType[] arrayRefVar = new dataType[arraySize];</span><br></pre></td></tr></table></figure>

<p>另外，你还可以使用如下的方式创建数组。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">dataType[] arrayRefVar = &#123;value0, value1, ..., valuek&#125;;</span><br></pre></td></tr></table></figure>

<p>数组的元素是通过索引访问的。数组索引从 0 开始，所以索引值从 0 到 arrayRefVar.length-1。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="C:\Users\16564\AppData\Roaming\Typora\typora-user-images\image-20231002170618852.png" alt="image-20231002170618852"></p>
<h2 id="处理数组"><a href="#处理数组" class="headerlink" title="处理数组"></a>处理数组</h2><p>数组的元素类型和数组的大小都是确定的，所以当处理数组元素时候，我们通常使用基本循环或者 For-Each 循环。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestArray</span> &#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">      <span class="type">double</span>[] myList = &#123;<span class="number">1.9</span>, <span class="number">2.9</span>, <span class="number">3.4</span>, <span class="number">3.5</span>&#125;;</span><br><span class="line"> </span><br><span class="line">      <span class="comment">// 打印所有数组元素</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; myList.length; i++) &#123;</span><br><span class="line">         System.out.println(myList[i] + <span class="string">&quot; &quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 计算所有元素的总和</span></span><br><span class="line">      <span class="type">double</span> <span class="variable">total</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; myList.length; i++) &#123;</span><br><span class="line">         total += myList[i];</span><br><span class="line">      &#125;</span><br><span class="line">      System.out.println(<span class="string">&quot;Total is &quot;</span> + total);</span><br><span class="line">      <span class="comment">// 查找最大元素</span></span><br><span class="line">      <span class="type">double</span> <span class="variable">max</span> <span class="operator">=</span> myList[<span class="number">0</span>];</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; myList.length; i++) &#123;</span><br><span class="line">         <span class="keyword">if</span> (myList[i] &gt; max) max = myList[i];</span><br><span class="line">      &#125;</span><br><span class="line">      System.out.println(<span class="string">&quot;Max is &quot;</span> + max);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="For-Each-循环"><a href="#For-Each-循环" class="headerlink" title="For-Each 循环"></a>For-Each 循环</h2><p>JDK 1.5 引进了一种新的循环类型，被称为 For-Each 循环或者加强型循环，它能在不使用下标的情况下遍历数组。</p>
<p>语法格式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">for(type element: array)</span><br><span class="line">&#123;</span><br><span class="line">    System.out.println(element);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestArray</span> &#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">      <span class="type">double</span>[] myList = &#123;<span class="number">1.9</span>, <span class="number">2.9</span>, <span class="number">3.4</span>, <span class="number">3.5</span>&#125;;</span><br><span class="line"> </span><br><span class="line">      <span class="comment">// 打印所有数组元素</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="type">double</span> element: myList) &#123;</span><br><span class="line">         System.out.println(element);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="多维数组"><a href="#多维数组" class="headerlink" title="多维数组"></a>多维数组</h2><p>多维数组可以看成是数组的数组，比如二维数组就是一个特殊的一维数组，其每一个元素都是一个一维数组，例如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">String[][] str = new String[3][4];</span><br></pre></td></tr></table></figure>



<h3 id="多维数组的动态初始化（以二维数组为例）"><a href="#多维数组的动态初始化（以二维数组为例）" class="headerlink" title="多维数组的动态初始化（以二维数组为例）"></a>多维数组的动态初始化（以二维数组为例）</h3><ol>
<li>直接为每一维分配空间，格式如下：</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">type[][] typeName = new type[typeLength1][typeLength2];</span><br></pre></td></tr></table></figure>



<p>type 可以为基本数据类型和复合数据类型，typeLength1 和 typeLength2 必须为正整数，typeLength1 为行数，typeLength2 为列数。</p>
<p>例如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int[][] a = new int[2][3];</span><br></pre></td></tr></table></figure>

<p>解析：</p>
<p>二维数组 a 可以看成一个两行三列的数组。</p>
<ol start="2">
<li>从最高维开始，分别为每一维分配空间，例如：</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">String[][] s = new String[2][];</span><br><span class="line">s[0] = new String[2];</span><br><span class="line">s[1] = new String[3];</span><br><span class="line">s[0][0] = new String(&quot;Good&quot;);</span><br><span class="line">s[0][1] = new String(&quot;Luck&quot;);</span><br><span class="line">s[1][0] = new String(&quot;to&quot;);</span><br><span class="line">s[1][1] = new String(&quot;you&quot;);</span><br><span class="line">s[1][2] = new String(&quot;!&quot;);</span><br></pre></td></tr></table></figure>

<p>解析：</p>
<p><strong>s[0]&#x3D;new String[2]</strong> 和 <strong>s[1]&#x3D;new String[3]</strong> 是为最高维分配引用空间，也就是为最高维限制其能保存数据的最长的长度，然后再为其每个数组元素单独分配空间 <strong>s0&#x3D;new String(“Good”)</strong> 等操作。</p>
<h2 id="Arrays-类"><a href="#Arrays-类" class="headerlink" title="Arrays 类"></a>Arrays 类</h2><p>java.util.Arrays 类能方便地操作数组，它提供的所有方法都是静态的。</p>
<p>具有以下功能：</p>
<ul>
<li>给数组赋值：通过 fill 方法。</li>
<li>对数组排序：通过 sort 方法,按升序。</li>
<li>比较数组：通过 equals 方法比较数组中元素值是否相等。</li>
<li>查找数组元素：通过 binarySearch 方法能对排序好的数组进行二分查找法操作。</li>
</ul>
<table>
<thead>
<tr>
<th align="left">序号</th>
<th align="left">方法和说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">1</td>
<td align="left"><strong>public static int binarySearch(Object[] a, Object key)</strong> 用二分查找算法在给定数组中搜索给定值的对象(Byte,Int,double等)。数组在调用前必须排序好的。如果查找值包含在数组中，则返回搜索键的索引；否则返回 (-(<em>插入点</em>) - 1)。</td>
</tr>
<tr>
<td align="left">2</td>
<td align="left"><strong>public static boolean equals(long[] a, long[] a2)</strong> 如果两个指定的 long 型数组彼此<em>相等</em>，则返回 true。如果两个数组包含相同数量的元素，并且两个数组中的所有相应元素对都是相等的，则认为这两个数组是相等的。换句话说，如果两个数组以相同顺序包含相同的元素，则两个数组是相等的。同样的方法适用于所有的其他基本数据类型（Byte，short，Int等）。</td>
</tr>
<tr>
<td align="left">3</td>
<td align="left"><strong>public static void fill(int[] a, int val)</strong> 将指定的 int 值分配给指定 int 型数组指定范围中的每个元素。同样的方法适用于所有的其他基本数据类型（Byte，short，Int等）。</td>
</tr>
<tr>
<td align="left">4</td>
<td align="left"><strong>public static void sort(Object[] a)</strong> 对指定对象数组根据其元素的自然顺序进行升序排列。同样的方法适用于所有的其他基本数据类型（Byte，short，Int等）。</td>
</tr>
</tbody></table>
<h1 id="Java-日期时间"><a href="#Java-日期时间" class="headerlink" title="Java 日期时间"></a>Java 日期时间</h1><p>java.util 包提供了 Date 类来封装当前的日期和时间。 Date 类提供两个构造函数来实例化 Date 对象。</p>
<p>第一个构造函数使用当前日期和时间来初始化对象。</p>
<p>Date( )</p>
<p>第二个构造函数接收一个参数，该参数是从 1970 年 1 月 1 日起的毫秒数。</p>
<p>Date(long millisec)</p>
<p>Date 对象创建以后，可以调用下面的方法。</p>
<table>
<thead>
<tr>
<th align="left">序号</th>
<th align="left">方法和描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">1</td>
<td align="left"><strong>boolean after(Date date)</strong> 若当调用此方法的Date对象在指定日期之后返回true,否则返回false。</td>
</tr>
<tr>
<td align="left">2</td>
<td align="left"><strong>boolean before(Date date)</strong> 若当调用此方法的Date对象在指定日期之前返回true,否则返回false。</td>
</tr>
<tr>
<td align="left">3</td>
<td align="left"><strong>Object clone( )</strong> 返回此对象的副本。</td>
</tr>
<tr>
<td align="left">4</td>
<td align="left"><strong>int compareTo(Date date)</strong> 比较当调用此方法的Date对象和指定日期。两者相等时候返回0。调用对象在指定日期之前则返回负数。调用对象在指定日期之后则返回正数。</td>
</tr>
<tr>
<td align="left">5</td>
<td align="left"><strong>int compareTo(Object obj)</strong> 若obj是Date类型则操作等同于compareTo(Date) 。否则它抛出ClassCastException。</td>
</tr>
<tr>
<td align="left">6</td>
<td align="left"><strong>boolean equals(Object date)</strong> 当调用此方法的Date对象和指定日期相等时候返回true,否则返回false。</td>
</tr>
<tr>
<td align="left">7</td>
<td align="left"><strong>long getTime( )</strong> 返回自 1970 年 1 月 1 日 00:00:00 GMT 以来此 Date 对象表示的毫秒数。</td>
</tr>
<tr>
<td align="left">8</td>
<td align="left"><strong>int hashCode( )</strong>  返回此对象的哈希码值。</td>
</tr>
<tr>
<td align="left">9</td>
<td align="left"><strong>void setTime(long time)</strong>   用自1970年1月1日00:00:00 GMT以后time毫秒数设置时间和日期。</td>
</tr>
<tr>
<td align="left">10</td>
<td align="left"><strong>String toString( )</strong> 把此 Date 对象转换为以下形式的 String： dow mon dd hh:mm:ss zzz yyyy 其中： dow 是一周中的某一天 (Sun, Mon, Tue, Wed, Thu, Fri, Sat)。</td>
</tr>
</tbody></table>
<h2 id="获取当前日期时间"><a href="#获取当前日期时间" class="headerlink" title="获取当前日期时间"></a>获取当前日期时间</h2><p>Java中获取当前日期和时间很简单，使用 Date 对象的 toString() 方法来打印当前日期和时间，如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line">  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DateDemo</span> &#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">       <span class="comment">// 初始化 Date 对象</span></span><br><span class="line">       <span class="type">Date</span> <span class="variable">date</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line">        </span><br><span class="line">       <span class="comment">// 使用 toString() 函数显示日期时间</span></span><br><span class="line">       System.out.println(date.toString());</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="日期比较"><a href="#日期比较" class="headerlink" title="日期比较"></a>日期比较</h2><p>Java使用以下三种方法来比较两个日期：</p>
<ul>
<li>使用 getTime() 方法获取两个日期（自1970年1月1日经历的毫秒数值），然后比较这两个值。</li>
<li>使用方法 before()，after() 和 equals()。例如，一个月的12号比18号早，则 new Date(99, 2, 12).before(new Date (99, 2, 18)) 返回true。</li>
<li>使用 compareTo() 方法，它是由 Comparable 接口定义的，Date 类实现了这个接口。</li>
</ul>
<h2 id="使用-SimpleDateFormat-格式化日期"><a href="#使用-SimpleDateFormat-格式化日期" class="headerlink" title="使用 SimpleDateFormat 格式化日期"></a>使用 SimpleDateFormat 格式化日期</h2><p>SimpleDateFormat 是一个以语言环境敏感的方式来格式化和分析日期的类。SimpleDateFormat 允许你选择任何用户自定义日期时间格式来运行。例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span>  java.util.*;</span><br><span class="line"><span class="keyword">import</span> java.text.*;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DateDemo</span> &#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"> </span><br><span class="line">      <span class="type">Date</span> <span class="variable">dNow</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>( );</span><br><span class="line">      <span class="type">SimpleDateFormat</span> <span class="variable">ft</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span> (<span class="string">&quot;yyyy-MM-dd hh:mm:ss&quot;</span>);</span><br><span class="line"> </span><br><span class="line">      System.out.println(<span class="string">&quot;当前时间为: &quot;</span> + ft.format(dNow));</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="使用printf格式化日期"><a href="#使用printf格式化日期" class="headerlink" title="使用printf格式化日期"></a>使用printf格式化日期</h2><p>printf 方法可以很轻松地格式化时间和日期。使用两个字母格式，它以 <strong>%t</strong> 开头并且以下面表格中的一个字母结尾。</p>
<ul>
<li>%tY：输出四位数的年份，例如：2023</li>
<li>%ty：输出两位数的年份，例如：23</li>
<li>%tm：输出两位数的月份，例如：02</li>
<li>%tB：输出月份的全名，例如：February</li>
<li>%tb：输出月份的缩写，例如：Feb</li>
<li>%tA：输出星期的全名，例如：Wednesday</li>
<li>%ta：输出星期的缩写，例如：Wed</li>
<li>%td：输出两位数的日期，例如：24</li>
<li>%te：输出一位或两位数的日期，例如：24 或 02</li>
<li>%tH：输出24小时制的小时数，例如：23</li>
<li>%tI：输出12小时制的小时数，例如：11</li>
<li>%tM：输出分钟数，例如：45</li>
<li>%tS：输出秒数，例如：30</li>
<li>%tp：输出上午还是下午，例如：AM 或 PM</li>
<li>%tZ：输出时区，例如：GMT+08:00</li>
</ul>
<table>
<thead>
<tr>
<th align="left">转换符</th>
<th align="left">说明</th>
<th align="left">示例</th>
</tr>
</thead>
<tbody><tr>
<td align="left">%tc</td>
<td align="left">包括全部日期和时间信息</td>
<td align="left">星期六 十月 27 14:21:20 CST 2007</td>
</tr>
<tr>
<td align="left">%tF</td>
<td align="left">“年-月-日”格式</td>
<td align="left">2007-10-27</td>
</tr>
<tr>
<td align="left">%tD</td>
<td align="left">“月&#x2F;日&#x2F;年”格式</td>
<td align="left">10&#x2F;27&#x2F;07</td>
</tr>
<tr>
<td align="left">%tr</td>
<td align="left">“HH:MM:SS PM”格式（12时制）</td>
<td align="left">02:25:51 下午</td>
</tr>
<tr>
<td align="left">%tT</td>
<td align="left">“HH:MM:SS”格式（24时制）</td>
<td align="left">14:28:16</td>
</tr>
<tr>
<td align="left">%tR</td>
<td align="left">“HH:MM”格式（24时制）</td>
<td align="left">14:28</td>
</tr>
</tbody></table>
<h2 id="Java-休眠-sleep"><a href="#Java-休眠-sleep" class="headerlink" title="Java 休眠(sleep)"></a>Java 休眠(sleep)</h2><p>sleep()使当前线程进入停滞状态（阻塞当前线程），让出CPU的使用、目的是不让当前线程独自霸占该进程所获的CPU资源，以留一定时间给其他线程执行的机会	</p>
<h2 id="Calendar类"><a href="#Calendar类" class="headerlink" title="Calendar类"></a>Calendar类</h2><p>我们现在已经能够格式化并创建一个日期对象了，但是我们如何才能设置和获取日期数据的特定部分呢，比如说小时，日，或者分钟? 我们又如何在日期的这些部分加上或者减去值呢? 答案是使用Calendar 类。</p>
<p>Calendar类的功能要比Date类强大很多，而且在实现方式上也比Date类要复杂一些。</p>
<p>Calendar类是一个抽象类，在实际使用时实现特定的子类的对象，创建对象的过程对程序员来说是透明的，只需要使用getInstance方法创建即可。</p>
<h3 id="创建一个代表系统当前日期的Calendar对象"><a href="#创建一个代表系统当前日期的Calendar对象" class="headerlink" title="创建一个代表系统当前日期的Calendar对象"></a>创建一个代表系统当前日期的Calendar对象</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Calendar c = Calendar.getInstance();//默认是当前日期</span><br></pre></td></tr></table></figure>

<h3 id="创建一个指定日期的Calendar对象"><a href="#创建一个指定日期的Calendar对象" class="headerlink" title="创建一个指定日期的Calendar对象"></a>创建一个指定日期的Calendar对象</h3><p>使用Calendar类代表特定的时间，需要首先创建一个Calendar的对象，然后再设定该对象中的年月日参数来完成。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//创建一个代表2009年6月12日的Calendar对象</span><br><span class="line">Calendar c1 = Calendar.getInstance();</span><br><span class="line">c1.set(2009, 6 - 1, 12);</span><br></pre></td></tr></table></figure>

<h3 id="Calendar类对象字段类型"><a href="#Calendar类对象字段类型" class="headerlink" title="Calendar类对象字段类型"></a>Calendar类对象字段类型</h3><p>Calendar类中用以下这些常量表示不同的意义，jdk内的很多类其实都是采用的这种思想</p>
<table>
<thead>
<tr>
<th align="left">常量</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">Calendar.YEAR</td>
<td align="left">年份</td>
</tr>
<tr>
<td align="left">Calendar.MONTH</td>
<td align="left">月份</td>
</tr>
<tr>
<td align="left">Calendar.DATE</td>
<td align="left">日期</td>
</tr>
<tr>
<td align="left">Calendar.DAY_OF_MONTH</td>
<td align="left">日期，和上面的字段意义完全相同</td>
</tr>
<tr>
<td align="left">Calendar.HOUR</td>
<td align="left">12小时制的小时</td>
</tr>
<tr>
<td align="left">Calendar.HOUR_OF_DAY</td>
<td align="left">24小时制的小时</td>
</tr>
<tr>
<td align="left">Calendar.MINUTE</td>
<td align="left">分钟</td>
</tr>
<tr>
<td align="left">Calendar.SECOND</td>
<td align="left">秒</td>
</tr>
<tr>
<td align="left">Calendar.DAY_OF_WEEK</td>
<td align="left">星期几</td>
</tr>
</tbody></table>
<h3 id="Calendar类对象信息的获得"><a href="#Calendar类对象信息的获得" class="headerlink" title="Calendar类对象信息的获得"></a>Calendar类对象信息的获得</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Calendar</span> <span class="variable">c1</span> <span class="operator">=</span> Calendar.getInstance();</span><br><span class="line"><span class="comment">// 获得年份</span></span><br><span class="line"><span class="type">int</span> <span class="variable">year</span> <span class="operator">=</span> c1.get(Calendar.YEAR);</span><br><span class="line"><span class="comment">// 获得月份</span></span><br><span class="line"><span class="type">int</span> <span class="variable">month</span> <span class="operator">=</span> c1.get(Calendar.MONTH) + <span class="number">1</span>;</span><br><span class="line"><span class="comment">// 获得日期</span></span><br><span class="line"><span class="type">int</span> <span class="variable">date</span> <span class="operator">=</span> c1.get(Calendar.DATE);</span><br><span class="line"><span class="comment">// 获得小时</span></span><br><span class="line"><span class="type">int</span> <span class="variable">hour</span> <span class="operator">=</span> c1.get(Calendar.HOUR_OF_DAY);</span><br><span class="line"><span class="comment">// 获得分钟</span></span><br><span class="line"><span class="type">int</span> <span class="variable">minute</span> <span class="operator">=</span> c1.get(Calendar.MINUTE);</span><br><span class="line"><span class="comment">// 获得秒</span></span><br><span class="line"><span class="type">int</span> <span class="variable">second</span> <span class="operator">=</span> c1.get(Calendar.SECOND);</span><br><span class="line"><span class="comment">// 获得星期几（注意（这个与Date类是不同的）：1代表星期日、2代表星期1、3代表星期二，以此类推）</span></span><br><span class="line"><span class="type">int</span> <span class="variable">day</span> <span class="operator">=</span> c1.get(Calendar.DAY_OF_WEEK);</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line">  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GregorianCalendarDemo</span> &#123;</span><br><span class="line"> </span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">      String months[] = &#123;</span><br><span class="line">      <span class="string">&quot;Jan&quot;</span>, <span class="string">&quot;Feb&quot;</span>, <span class="string">&quot;Mar&quot;</span>, <span class="string">&quot;Apr&quot;</span>,</span><br><span class="line">      <span class="string">&quot;May&quot;</span>, <span class="string">&quot;Jun&quot;</span>, <span class="string">&quot;Jul&quot;</span>, <span class="string">&quot;Aug&quot;</span>,</span><br><span class="line">      <span class="string">&quot;Sep&quot;</span>, <span class="string">&quot;Oct&quot;</span>, <span class="string">&quot;Nov&quot;</span>, <span class="string">&quot;Dec&quot;</span>&#125;;</span><br><span class="line">      </span><br><span class="line">      <span class="type">int</span> year;</span><br><span class="line">      <span class="comment">// 初始化 Gregorian 日历</span></span><br><span class="line">      <span class="comment">// 使用当前时间和日期</span></span><br><span class="line">      <span class="comment">// 默认为本地时间和时区</span></span><br><span class="line">      <span class="type">GregorianCalendar</span> <span class="variable">gcalendar</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GregorianCalendar</span>();</span><br><span class="line">      <span class="comment">// 显示当前时间和日期的信息</span></span><br><span class="line">      System.out.print(<span class="string">&quot;Date: &quot;</span>);</span><br><span class="line">      System.out.print(months[gcalendar.get(Calendar.MONTH)]);</span><br><span class="line">      System.out.print(<span class="string">&quot; &quot;</span> + gcalendar.get(Calendar.DATE) + <span class="string">&quot; &quot;</span>);</span><br><span class="line">      System.out.println(year = gcalendar.get(Calendar.YEAR));</span><br><span class="line">      System.out.print(<span class="string">&quot;Time: &quot;</span>);</span><br><span class="line">      System.out.print(gcalendar.get(Calendar.HOUR) + <span class="string">&quot;:&quot;</span>);</span><br><span class="line">      System.out.print(gcalendar.get(Calendar.MINUTE) + <span class="string">&quot;:&quot;</span>);</span><br><span class="line">      System.out.println(gcalendar.get(Calendar.SECOND));</span><br><span class="line">      </span><br><span class="line">      <span class="comment">// 测试当前年份是否为闰年</span></span><br><span class="line">      <span class="keyword">if</span>(gcalendar.isLeapYear(year)) &#123;</span><br><span class="line">         System.out.println(<span class="string">&quot;当前年份是闰年&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">         System.out.println(<span class="string">&quot;当前年份不是闰年&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Java-方法"><a href="#Java-方法" class="headerlink" title="Java 方法"></a>Java 方法</h1><p>在前面几个章节中我们经常使用到 **System.out.println()**，那么它是什么呢？</p>
<ul>
<li>println() 是一个方法。</li>
<li>System 是系统类。</li>
<li>out 是标准输出对象。</li>
</ul>
<p>这句话的用法是调用系统类 System 中的标准输出对象 out 中的方法 println()。</p>
<h3 id="那么什么是方法呢？"><a href="#那么什么是方法呢？" class="headerlink" title="那么什么是方法呢？"></a>那么什么是方法呢？</h3><p>Java方法是语句的集合，它们在一起执行一个功能。</p>
<ul>
<li>方法是解决一类问题的步骤的有序组合</li>
<li>方法包含于类或对象中</li>
<li>方法在程序中被创建，在其他地方被引用</li>
</ul>
<h3 id="方法的优点"><a href="#方法的优点" class="headerlink" title="方法的优点"></a>方法的优点</h3><ul>
<li><ol>
<li>使程序变得更简短而清晰。</li>
</ol>
</li>
<li><ol start="2">
<li>有利于程序维护。</li>
</ol>
</li>
<li><ol start="3">
<li>可以提高程序开发的效率。</li>
</ol>
</li>
<li><ol start="4">
<li>提高了代码的重用性。</li>
</ol>
</li>
</ul>
<h3 id="方法的命名规则"><a href="#方法的命名规则" class="headerlink" title="方法的命名规则"></a>方法的命名规则</h3><ul>
<li>1.方法的名字的第一个单词应以小写字母作为开头，后面的单词则用大写字母开头写，不使用连接符。例如：<strong>addPerson</strong>。</li>
<li>2.下划线可能出现在 JUnit 测试方法名称中用以分隔名称的逻辑组件。一个典型的模式是：**test<MethodUnderTest>_<state>**，例如 <strong>testPop_emptyStack</strong>。</li>
</ul>
<h2 id="方法的定义"><a href="#方法的定义" class="headerlink" title="方法的定义"></a>方法的定义</h2><p>一般情况下，定义一个方法包含以下语法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">修饰符 返回值类型 方法名(参数类型 参数名)&#123;</span><br><span class="line">    ...</span><br><span class="line">    方法体</span><br><span class="line">    ...</span><br><span class="line">    return 返回值;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>方法包含一个方法头和一个方法体。下面是一个方法的所有部分：</p>
<ul>
<li><strong>修饰符：</strong>修饰符，这是可选的，告诉编译器如何调用该方法。定义了该方法的访问类型。</li>
<li><strong>返回值类型 ：</strong>方法可能会返回值。returnValueType 是方法返回值的数据类型。有些方法执行所需的操作，但没有返回值。在这种情况下，returnValueType 是关键字<strong>void</strong>。</li>
<li><strong>方法名：</strong>是方法的实际名称。方法名和参数表共同构成方法签名。</li>
<li><strong>参数类型：</strong>参数像是一个占位符。当方法被调用时，传递值给参数。这个值被称为实参或变量。参数列表是指方法的参数类型、顺序和参数的个数。参数是可选的，方法可以不包含任何参数。</li>
<li><strong>方法体：</strong>方法体包含具体的语句，定义该方法的功能。</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="C:\Users\16564\AppData\Roaming\Typora\typora-user-images\image-20231003092734272.png" alt="image-20231003092734272"></p>
<h2 id="方法的重载"><a href="#方法的重载" class="headerlink" title="方法的重载"></a>方法的重载</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestMax</span> &#123;</span><br><span class="line">   <span class="comment">/** 主方法 */</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">      <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">5</span>;</span><br><span class="line">      <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line">      <span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> max(i, j);</span><br><span class="line">      System.out.println( i + <span class="string">&quot; 和 &quot;</span> + j + <span class="string">&quot; 比较，最大值是：&quot;</span> + k);</span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   <span class="comment">/** 返回两个整数变量较大的值 */</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">max</span><span class="params">(<span class="type">int</span> num1, <span class="type">int</span> num2)</span> &#123;</span><br><span class="line">      <span class="type">int</span> result;</span><br><span class="line">      <span class="keyword">if</span> (num1 &gt; num2)</span><br><span class="line">         result = num1;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">         result = num2;</span><br><span class="line"> </span><br><span class="line">      <span class="keyword">return</span> result; </span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面使用的max方法仅仅适用于int型数据。但如果你想得到两个浮点类型数据的最大值呢？</p>
<p>解决方法是创建另一个有相同名字但参数不同的方法，如下面代码所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">double</span> <span class="title function_">max</span><span class="params">(<span class="type">double</span> num1, <span class="type">double</span> num2)</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (num1 &gt; num2)</span><br><span class="line">    <span class="keyword">return</span> num1;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="keyword">return</span> num2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果你调用max方法时传递的是int型参数，则 int型参数的max方法就会被调用；</p>
<p>如果传递的是double型参数，则double类型的max方法体会被调用，这叫做方法重载；</p>
<p>就是说一个类的两个方法拥有相同的名字，但是有不同的参数列表。</p>
<p>Java编译器根据方法签名判断哪个方法应该被调用。</p>
<p>方法重载可以让程序更清晰易读。执行密切相关任务的方法应该使用相同的名字。</p>
<p>重载的方法必须拥有不同的参数列表。你不能仅仅依据修饰符或者返回类型的不同来重载方法。</p>
<h2 id="构造方法-1"><a href="#构造方法-1" class="headerlink" title="构造方法"></a>构造方法</h2><p>当一个对象被创建时候，构造方法用来初始化该对象。构造方法和它所在类的名字相同，但构造方法没有返回值。</p>
<p>通常会使用构造方法给一个类的实例变量赋初值，或者执行其它必要的步骤来创建一个完整的对象。</p>
<p>不管你是否自定义构造方法，所有的类都有构造方法，因为 Java 自动提供了一个默认构造方法，默认构造方法的访问修饰符和类的访问修饰符相同(类为 public，构造函数也为 public；类改为 protected，构造函数也改为 protected)。</p>
<p>一旦你定义了自己的构造方法，默认构造方法就会失效。</p>
<h2 id="finalize-方法"><a href="#finalize-方法" class="headerlink" title="finalize() 方法"></a>finalize() 方法</h2><p>Java 允许定义这样的方法，它在对象被垃圾收集器析构(回收)之前调用，这个方法叫做 finalize( )，它用来清除回收对象。</p>
<p>例如，你可以使用 finalize() 来确保一个对象打开的文件被关闭了。</p>
<p>在 finalize() 方法里，你必须指定在对象销毁时候要执行的操作。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">finalize</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="comment">// 在这里终结代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Java-流-Stream-、文件-File-和IO"><a href="#Java-流-Stream-、文件-File-和IO" class="headerlink" title="Java 流(Stream)、文件(File)和IO"></a>Java 流(Stream)、文件(File)和IO</h1><p>Java.io 包几乎包含了所有操作输入、输出需要的类。所有这些流类代表了输入源和输出目标。</p>
<p>Java.io 包中的流支持很多种格式，比如：基本类型、对象、本地化字符集等等。</p>
<p>一个流可以理解为一个数据的序列。输入流表示从一个源读取数据，输出流表示向一个目标写数据。</p>
<p>Java 为 I&#x2F;O 提供了强大的而灵活的支持，使其更广泛地应用到文件传输和网络编程中。</p>
<p>但本节讲述最基本的和流与 I&#x2F;O 相关的功能。我们将通过一个个例子来学习这些功能。</p>
<h2 id="读取控制台输入"><a href="#读取控制台输入" class="headerlink" title="读取控制台输入"></a>读取控制台输入</h2><p>Java 的控制台输入由 System.in 完成。</p>
<p>为了获得一个绑定到控制台的字符流，你可以把 System.in 包装在一个 BufferedReader 对象中来创建一个字符流。</p>
<p>下面是创建 BufferedReader 的基本语法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">BufferedReader</span> <span class="variable">br</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> </span><br><span class="line">                      <span class="title class_">InputStreamReader</span>(System.in));</span><br></pre></td></tr></table></figure>

<p>BufferedReader 对象创建后，我们便可以使用 read() 方法从控制台读取一个字符，或者用 readLine() 方法读取一个字符串。</p>
<h2 id="从控制台读取多字符输入"><a href="#从控制台读取多字符输入" class="headerlink" title="从控制台读取多字符输入"></a>从控制台读取多字符输入</h2><p>从 BufferedReader 对象读取一个字符要使用 read() 方法，它的语法如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">read</span><span class="params">( )</span> <span class="keyword">throws</span> IOException</span><br></pre></td></tr></table></figure>

<p>每次调用 read() 方法，它从输入流读取一个字符并把该字符作为整数值返回。 当流结束的时候返回 -1。该方法抛出 IOException。</p>
<p>下面的程序示范了用 read() 方法从控制台不断读取字符直到用户输入 <strong>q</strong>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//使用 BufferedReader 在控制台读取字符</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BRRead</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">char</span> c;</span><br><span class="line">        <span class="comment">// 使用 System.in 创建 BufferedReader</span></span><br><span class="line">        <span class="type">BufferedReader</span> <span class="variable">br</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(System.in));</span><br><span class="line">        System.out.println(<span class="string">&quot;输入字符, 按下 &#x27;q&#x27; 键退出。&quot;</span>);</span><br><span class="line">        <span class="comment">// 读取字符</span></span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            c = (<span class="type">char</span>) br.read();</span><br><span class="line">            System.out.println(c);</span><br><span class="line">        &#125; <span class="keyword">while</span> (c != <span class="string">&#x27;q&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="从控制台读取字符串"><a href="#从控制台读取字符串" class="headerlink" title="从控制台读取字符串"></a>从控制台读取字符串</h2><p>从标准输入读取一个字符串需要使用 BufferedReader 的 readLine() 方法。</p>
<p>它的一般格式是：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String <span class="title function_">readLine</span><span class="params">( )</span> <span class="keyword">throws</span> IOException</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//使用 BufferedReader 在控制台读取字符</span></span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BRReadLines</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">// 使用 System.in 创建 BufferedReader</span></span><br><span class="line">        <span class="type">BufferedReader</span> <span class="variable">br</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(System.in));</span><br><span class="line">        String str;</span><br><span class="line">        System.out.println(<span class="string">&quot;Enter lines of text.&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;Enter &#x27;end&#x27; to quit.&quot;</span>);</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            str = br.readLine();</span><br><span class="line">            System.out.println(str);</span><br><span class="line">        &#125; <span class="keyword">while</span> (!str.equals(<span class="string">&quot;end&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="控制台输出"><a href="#控制台输出" class="headerlink" title="控制台输出"></a>控制台输出</h2><p>在此前已经介绍过，控制台的输出由 print( ) 和 println() 完成。这些方法都由类 PrintStream 定义，System.out 是该类对象的一个引用。</p>
<p>PrintStream 继承了 OutputStream类，并且实现了方法 write()。这样，write() 也可以用来往控制台写操作。</p>
<p>PrintStream 定义 write() 的最简单格式如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">write</span><span class="params">(<span class="type">int</span> byteval)</span></span><br></pre></td></tr></table></figure>

<p>下面的例子用 write() 把字符 “A” 和紧跟着的换行符输出到屏幕：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//演示 System.out.write().</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WriteDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> b;</span><br><span class="line">        b = <span class="string">&#x27;A&#x27;</span>;</span><br><span class="line">        System.out.write(b);</span><br><span class="line">        System.out.write(<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="FileInputStream"><a href="#FileInputStream" class="headerlink" title="FileInputStream"></a>FileInputStream</h2><p>该流用于从文件读取数据，它的对象可以用关键字 new 来创建。</p>
<p>有多种构造方法可用来创建对象。</p>
<p>可以使用字符串类型的文件名来创建一个输入流对象来读取文件：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">InputStream f = new FileInputStream(&quot;C:/java/hello&quot;);</span><br></pre></td></tr></table></figure>

<p>也可以使用一个文件对象来创建一个输入流对象来读取文件。我们首先得使用 File() 方法来创建一个文件对象：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">File f = new File(&quot;C:/java/hello&quot;); InputStream in = new FileInputStream(f);</span><br></pre></td></tr></table></figure>

<p>创建了InputStream对象，就可以使用下面的方法来读取流或者进行其他的流操作。</p>
<table>
<thead>
<tr>
<th align="left"><strong>序号</strong></th>
<th align="left"><strong>方法及描述</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="left">1</td>
<td align="left"><strong>public void close() throws IOException{}</strong> 关闭此文件输入流并释放与此流有关的所有系统资源。抛出IOException异常。</td>
</tr>
<tr>
<td align="left">2</td>
<td align="left"><strong>protected void finalize()throws IOException {}</strong> 这个方法清除与该文件的连接。确保在不再引用文件输入流时调用其 close 方法。抛出IOException异常。</td>
</tr>
<tr>
<td align="left">3</td>
<td align="left"><strong>public int read(int r)throws IOException{}</strong> 这个方法从 InputStream 对象读取指定字节的数据。返回为整数值。返回下一字节数据，如果已经到结尾则返回-1。</td>
</tr>
<tr>
<td align="left">4</td>
<td align="left"><strong>public int read(byte[] r) throws IOException{}</strong> 这个方法从输入流读取r.length长度的字节。返回读取的字节数。如果是文件结尾则返回-1。</td>
</tr>
<tr>
<td align="left">5</td>
<td align="left"><strong>public int available() throws IOException{}</strong> 返回下一次对此输入流调用的方法可以不受阻塞地从此输入流读取的字节数。返回一个整数值。</td>
</tr>
</tbody></table>
<h2 id="FileOutputStream"><a href="#FileOutputStream" class="headerlink" title="FileOutputStream"></a>FileOutputStream</h2><p>该类用来创建一个文件并向文件中写数据。</p>
<p>如果该流在打开文件进行输出前，目标文件不存在，那么该流会创建该文件。</p>
<p>有两个构造方法可以用来创建 FileOutputStream 对象。</p>
<p>使用字符串类型的文件名来创建一个输出流对象：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">OutputStream f = new FileOutputStream(&quot;C:/java/hello&quot;)</span><br></pre></td></tr></table></figure>

<p>也可以使用一个文件对象来创建一个输出流来写文件。我们首先得使用File()方法来创建一个文件对象：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">File f = new File(&quot;C:/java/hello&quot;);</span><br><span class="line">OutputStream fOut = new FileOutputStream(f);</span><br></pre></td></tr></table></figure>

<p>创建OutputStream 对象完成后，就可以使用下面的方法来写入流或者进行其他的流操作。</p>
<table>
<thead>
<tr>
<th align="left"><strong>序号</strong></th>
<th align="left"><strong>方法及描述</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="left">1</td>
<td align="left"><strong>public void close() throws IOException{}</strong> 关闭此文件输入流并释放与此流有关的所有系统资源。抛出IOException异常。</td>
</tr>
<tr>
<td align="left">2</td>
<td align="left"><strong>protected void finalize()throws IOException {}</strong> 这个方法清除与该文件的连接。确保在不再引用文件输入流时调用其 close 方法。抛出IOException异常。</td>
</tr>
<tr>
<td align="left">3</td>
<td align="left"><strong>public void write(int w)throws IOException{}</strong> 这个方法把指定的字节写到输出流中。</td>
</tr>
<tr>
<td align="left">4</td>
<td align="left"><strong>public void write(byte[] w)</strong> 把指定数组中w.length长度的字节写到OutputStream中</td>
</tr>
</tbody></table>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//文件名 :fileStreamTest2.java</span></span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">fileStreamTest2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line"> </span><br><span class="line">        <span class="type">File</span> <span class="variable">f</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;a.txt&quot;</span>);</span><br><span class="line">        <span class="type">FileOutputStream</span> <span class="variable">fop</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(f);</span><br><span class="line">        <span class="comment">// 构建FileOutputStream对象,文件不存在会自动新建</span></span><br><span class="line"> </span><br><span class="line">        <span class="type">OutputStreamWriter</span> <span class="variable">writer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OutputStreamWriter</span>(fop, <span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">        <span class="comment">// 构建OutputStreamWriter对象,参数可以指定编码,默认为操作系统默认编码,windows上是gbk</span></span><br><span class="line"> </span><br><span class="line">        writer.append(<span class="string">&quot;中文输入&quot;</span>);</span><br><span class="line">        <span class="comment">// 写入到缓冲区</span></span><br><span class="line"> </span><br><span class="line">        writer.append(<span class="string">&quot;\r\n&quot;</span>);</span><br><span class="line">        <span class="comment">// 换行</span></span><br><span class="line"> </span><br><span class="line">        writer.append(<span class="string">&quot;English&quot;</span>);</span><br><span class="line">        <span class="comment">// 刷新缓存冲,写入到文件,如果下面已经没有写入的内容了,直接close也会写入</span></span><br><span class="line"> </span><br><span class="line">        writer.close();</span><br><span class="line">        <span class="comment">// 关闭写入流,同时会把缓冲区内容写入文件,所以上面的注释掉</span></span><br><span class="line"> </span><br><span class="line">        fop.close();</span><br><span class="line">        <span class="comment">// 关闭输出流,释放系统资源</span></span><br><span class="line"> </span><br><span class="line">        <span class="type">FileInputStream</span> <span class="variable">fip</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(f);</span><br><span class="line">        <span class="comment">// 构建FileInputStream对象</span></span><br><span class="line"> </span><br><span class="line">        <span class="type">InputStreamReader</span> <span class="variable">reader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(fip, <span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">        <span class="comment">// 构建InputStreamReader对象,编码与写入相同</span></span><br><span class="line"> </span><br><span class="line">        <span class="type">StringBuffer</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>();</span><br><span class="line">        <span class="keyword">while</span> (reader.ready()) &#123;</span><br><span class="line">            sb.append((<span class="type">char</span>) reader.read());</span><br><span class="line">            <span class="comment">// 转成char加到StringBuffer对象中</span></span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(sb.toString());</span><br><span class="line">        reader.close();</span><br><span class="line">        <span class="comment">// 关闭读取流</span></span><br><span class="line"> </span><br><span class="line">        fip.close();</span><br><span class="line">        <span class="comment">// 关闭输入流,释放系统资源</span></span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="文件和I-O"><a href="#文件和I-O" class="headerlink" title="文件和I&#x2F;O"></a>文件和I&#x2F;O</h2><p>还有一些关于文件和I&#x2F;O的类，我们也需要知道：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://www.runoob.com/java/java-file.html">File Class(类)</a></li>
<li><a target="_blank" rel="noopener" href="https://www.runoob.com/java/java-filereader.html">FileReader Class(类)</a></li>
<li><a target="_blank" rel="noopener" href="https://www.runoob.com/java/java-filewriter.html">FileWriter Class(类)</a></li>
</ul>
<h2 id="Java中的目录"><a href="#Java中的目录" class="headerlink" title="Java中的目录"></a>Java中的目录</h2><h3 id="创建目录："><a href="#创建目录：" class="headerlink" title="创建目录："></a>创建目录：</h3><p>File类中有两个方法可以用来创建文件夹：</p>
<ul>
<li>**mkdir( )**方法创建一个文件夹，成功则返回true，失败则返回false。失败表明File对象指定的路径已经存在，或者由于整个路径还不存在，该文件夹不能被创建。</li>
<li>**mkdirs()**方法创建一个文件夹和它的所有父文件夹。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CreateDir</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">dirname</span> <span class="operator">=</span> <span class="string">&quot;/tmp/user/java/bin&quot;</span>;</span><br><span class="line">        <span class="type">File</span> <span class="variable">d</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(dirname);</span><br><span class="line">        <span class="comment">// 现在创建目录</span></span><br><span class="line">        d.mkdirs();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="读取目录"><a href="#读取目录" class="headerlink" title="读取目录"></a>读取目录</h2><p>一个目录其实就是一个 File 对象，它包含其他文件和文件夹。</p>
<p>如果创建一个 File 对象并且它是一个目录，那么调用 isDirectory() 方法会返回 true。</p>
<p>可以通过调用该对象上的 list() 方法，来提取它包含的文件和文件夹的列表。</p>
<p>下面展示的例子说明如何使用 list() 方法来检查一个文件夹中包含的内容：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DirList</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">dirname</span> <span class="operator">=</span> <span class="string">&quot;/tmp&quot;</span>;</span><br><span class="line">        <span class="type">File</span> <span class="variable">f1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(dirname);</span><br><span class="line">        <span class="keyword">if</span> (f1.isDirectory()) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;目录 &quot;</span> + dirname);</span><br><span class="line">            String s[] = f1.list();</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; s.length; i++) &#123;</span><br><span class="line">                <span class="type">File</span> <span class="variable">f</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(dirname + <span class="string">&quot;/&quot;</span> + s[i]);</span><br><span class="line">                <span class="keyword">if</span> (f.isDirectory()) &#123;</span><br><span class="line">                    System.out.println(s[i] + <span class="string">&quot; 是一个目录&quot;</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    System.out.println(s[i] + <span class="string">&quot; 是一个文件&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(dirname + <span class="string">&quot; 不是一个目录&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="删除目录或文件"><a href="#删除目录或文件" class="headerlink" title="删除目录或文件"></a>删除目录或文件</h2><p>删除文件可以使用 <strong>java.io.File.delete()</strong> 方法。</p>
<p>以下代码会删除目录 **&#x2F;tmp&#x2F;java&#x2F;**，需要注意的是当删除某一目录时，必须保证该目录下没有其他文件才能正确删除，否则将删除失败。</p>
<p>测试目录结构：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/tmp/java/</span><br><span class="line">|-- 1.log</span><br><span class="line">|-- test</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DeleteFileDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 这里修改为自己的测试目录</span></span><br><span class="line">        <span class="type">File</span> <span class="variable">folder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;/tmp/java/&quot;</span>);</span><br><span class="line">        deleteFolder(folder);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 删除文件及目录</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">deleteFolder</span><span class="params">(File folder)</span> &#123;</span><br><span class="line">        File[] files = folder.listFiles();</span><br><span class="line">        <span class="keyword">if</span> (files != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (File f : files) &#123;</span><br><span class="line">                <span class="keyword">if</span> (f.isDirectory()) &#123;</span><br><span class="line">                    deleteFolder(f);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    f.delete();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        folder.delete();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Java-Scanner-类"><a href="#Java-Scanner-类" class="headerlink" title="Java Scanner 类"></a>Java Scanner 类</h1><p>java.util.Scanner 是 Java5 的新特征，我们可以通过 Scanner 类来获取用户的输入。</p>
<p>下面是创建 Scanner 对象的基本语法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Scanner</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br></pre></td></tr></table></figure>

<h3 id="使用-next-方法："><a href="#使用-next-方法：" class="headerlink" title="使用 next 方法："></a>使用 next 方法：</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner; </span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ScannerDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">scan</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="comment">// 从键盘接收数据</span></span><br><span class="line"> </span><br><span class="line">        <span class="comment">// next方式接收字符串</span></span><br><span class="line">        System.out.println(<span class="string">&quot;next方式接收：&quot;</span>);</span><br><span class="line">        <span class="comment">// 判断是否还有输入</span></span><br><span class="line">        <span class="keyword">if</span> (scan.hasNext()) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">str1</span> <span class="operator">=</span> scan.next();</span><br><span class="line">            System.out.println(<span class="string">&quot;输入的数据为：&quot;</span> + str1);</span><br><span class="line">        &#125;</span><br><span class="line">        scan.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="使用-nextLine-方法："><a href="#使用-nextLine-方法：" class="headerlink" title="使用 nextLine 方法："></a>使用 nextLine 方法：</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ScannerDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">scan</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="comment">// 从键盘接收数据</span></span><br><span class="line"> </span><br><span class="line">        <span class="comment">// nextLine方式接收字符串</span></span><br><span class="line">        System.out.println(<span class="string">&quot;nextLine方式接收：&quot;</span>);</span><br><span class="line">        <span class="comment">// 判断是否还有输入</span></span><br><span class="line">        <span class="keyword">if</span> (scan.hasNextLine()) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">str2</span> <span class="operator">=</span> scan.nextLine();</span><br><span class="line">            System.out.println(<span class="string">&quot;输入的数据为：&quot;</span> + str2);</span><br><span class="line">        &#125;</span><br><span class="line">        scan.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="next-与-nextLine-区别"><a href="#next-与-nextLine-区别" class="headerlink" title="next() 与 nextLine() 区别"></a>next() 与 nextLine() 区别</h3><p>next():</p>
<ul>
<li>1、一定要读取到有效字符后才可以结束输入。</li>
<li>2、对输入有效字符之前遇到的空白，next() 方法会自动将其去掉。</li>
<li>3、只有输入有效字符后才将其后面输入的空白作为分隔符或者结束符。</li>
<li>next() 不能得到带有空格的字符串。</li>
</ul>
<p>nextLine()：</p>
<ul>
<li>1、以Enter为结束符,也就是说 nextLine()方法返回的是输入回车之前的所有字符。</li>
<li>2、可以获得空白。</li>
</ul>
<h1 id="Java-异常处理"><a href="#Java-异常处理" class="headerlink" title="Java 异常处理"></a>Java 异常处理</h1><p>异常是程序中的一些错误，但并不是所有的错误都是异常，并且错误有时候是可以避免的。</p>
<p>比如说，你的代码少了一个分号，那么运行出来结果是提示是错误 java.lang.Error；如果你用System.out.println(11&#x2F;0)，那么你是因为你用0做了除数，会抛出 java.lang.ArithmeticException 的异常。</p>
<p>异常发生的原因有很多，通常包含以下几大类：</p>
<ul>
<li>用户输入了非法数据。</li>
<li>要打开的文件不存在。</li>
<li>网络通信时连接中断，或者JVM内存溢出。</li>
</ul>
<p>这些异常有的是因为用户错误引起，有的是程序错误引起的，还有其它一些是因为物理错误引起的。-</p>
<p>要理解Java异常处理是如何工作的，你需要掌握以下三种类型的异常：</p>
<ul>
<li><strong>检查性异常：</strong>最具代表的检查性异常是用户错误或问题引起的异常，这是程序员无法预见的。例如要打开一个不存在文件时，一个异常就发生了，这些异常在编译时不能被简单地忽略。</li>
<li><strong>运行时异常：</strong> 运行时异常是可能被程序员避免的异常。与检查性异常相反，运行时异常可以在编译时被忽略。</li>
<li><strong>错误：</strong> 错误不是异常，而是脱离程序员控制的问题。错误在代码中通常被忽略。例如，当栈溢出时，一个错误就发生了，它们在编译也检查不到的。</li>
</ul>
<h2 id="Exception-类的层次"><a href="#Exception-类的层次" class="headerlink" title="Exception 类的层次"></a>Exception 类的层次</h2><p>所有的异常类是从 java.lang.Exception 类继承的子类。</p>
<p>Exception 类是 Throwable 类的子类。除了Exception类外，Throwable还有一个子类Error 。</p>
<p>Java 程序通常不捕获错误。错误一般发生在严重故障时，它们在Java程序处理的范畴之外。</p>
<p>Error 用来指示运行时环境发生的错误。</p>
<p>例如，JVM 内存溢出。一般地，程序不会从错误中恢复。</p>
<p>异常类有两个主要的子类：IOException 类和 RuntimeException 类。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://www.runoob.com/wp-content/uploads/2013/12/exception-hierarchy.png" alt="img"></p>
<h2 id="捕获异常"><a href="#捕获异常" class="headerlink" title="捕获异常"></a>捕获异常</h2><p>使用 try 和 catch 关键字可以捕获异常。try&#x2F;catch 代码块放在异常可能发生的地方。</p>
<p>try&#x2F;catch代码块中的代码称为保护代码，使用 try&#x2F;catch 的语法如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">try</span><br><span class="line">&#123;</span><br><span class="line">   // 程序代码</span><br><span class="line">&#125;catch(ExceptionName e1)</span><br><span class="line">&#123;</span><br><span class="line">   //Catch 块</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Catch 语句包含要捕获异常类型的声明。当保护代码块中发生一个异常时，try 后面的 catch 块就会被检查。</p>
<p>如果发生的异常包含在 catch 块中，异常会被传递到该 catch 块，这和传递一个参数到方法是一样。</p>
<h2 id="throws-throw-关键字"><a href="#throws-throw-关键字" class="headerlink" title="throws&#x2F;throw 关键字"></a>throws&#x2F;throw 关键字</h2><p>在Java中， <strong>throw</strong> 和 <strong>throws</strong> 关键字是用于处理异常的。</p>
<p><strong>throw</strong> 关键字用于在代码中抛出异常，而 <strong>throws</strong> 关键字用于在方法声明中指定可能会抛出的异常类型。</p>
<h3 id="throw-关键字"><a href="#throw-关键字" class="headerlink" title="throw 关键字"></a>throw 关键字</h3><p><strong>throw</strong> 关键字用于在当前方法中抛出一个异常。</p>
<p>通常情况下，当代码执行到某个条件下无法继续正常执行时，可以使用 <strong>throw</strong> 关键字抛出异常，以告知调用者当前代码的执行状态。</p>
<p>例如，下面的代码中，在方法中判断 num 是否小于 0，如果是，则抛出一个 IllegalArgumentException 异常。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">checkNumber</span><span class="params">(<span class="type">int</span> num)</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (num &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Number must be positive&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="throws-关键字"><a href="#throws-关键字" class="headerlink" title="throws 关键字"></a>throws 关键字</h3><p><strong>throws</strong> 关键字用于在方法声明中指定该方法可能抛出的异常。当方法内部抛出指定类型的异常时，该异常会被传递给调用该方法的代码，并在该代码中处理异常。</p>
<p>例如，下面的代码中，当 readFile 方法内部发生 IOException 异常时，会将该异常传递给调用该方法的代码。在调用该方法的代码中，必须捕获或声明处理 IOException 异常。</p>
<h2 id="finally关键字"><a href="#finally关键字" class="headerlink" title="finally关键字"></a>finally关键字</h2><p>finally 关键字用来创建在 try 代码块后面执行的代码块。</p>
<p>无论是否发生异常，finally 代码块中的代码总会被执行。</p>
<p>在 finally 代码块中，可以运行清理类型等收尾善后性质的语句。</p>
<p>finally 代码块出现在 catch 代码块最后，语法如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">  <span class="comment">// 程序代码</span></span><br><span class="line">&#125;<span class="keyword">catch</span>(异常类型<span class="number">1</span> 异常的变量名<span class="number">1</span>)&#123;</span><br><span class="line">  <span class="comment">// 程序代码</span></span><br><span class="line">&#125;<span class="keyword">catch</span>(异常类型<span class="number">2</span> 异常的变量名<span class="number">2</span>)&#123;</span><br><span class="line">  <span class="comment">// 程序代码</span></span><br><span class="line">&#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">  <span class="comment">// 程序代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="try-with-resources"><a href="#try-with-resources" class="headerlink" title="try-with-resources"></a>try-with-resources</h2><p>JDK7 之后，Java 新增的 <strong>try-with-resource</strong> 语法糖来打开资源，并且可以在语句执行完毕后确保每个资源都被自动关闭 。</p>
<p>try-with-resources 是一种异常处理机制，它可以简化资源管理代码的编写。</p>
<p>JDK7 之前所有被打开的系统资源，比如流、文件或者 Socket 连接等，都需要被开发者手动关闭，否则将会造成资源泄露。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">try (resource declaration) &#123;</span><br><span class="line">  // 使用的资源</span><br><span class="line">&#125; catch (ExceptionType e1) &#123;</span><br><span class="line">  // 异常块</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上的语法中 try 用于声明和实例化资源，catch 用于处理关闭资源时可能引发的所有异常。</p>
<h2 id="声明自定义异常"><a href="#声明自定义异常" class="headerlink" title="声明自定义异常"></a>声明自定义异常</h2><p>在 Java 中你可以自定义异常。编写自己的异常类时需要记住下面的几点。</p>
<ul>
<li>所有异常都必须是 Throwable 的子类。</li>
<li>如果希望写一个检查性异常类，则需要继承 Exception 类。</li>
<li>如果你想写一个运行时异常类，那么需要继承 RuntimeException 类。</li>
</ul>
<p>可以像下面这样定义自己的异常类：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class MyException extends Exception&#123; &#125;</span><br></pre></td></tr></table></figure>

<p>只继承Exception 类来创建的异常类是检查性异常类。</p>
<p>下面的 InsufficientFundsException 类是用户定义的异常类，它继承自 Exception。</p>
<p>一个异常类和其它任何类一样，包含有变量和方法。</p>
<h1 id="Java-继承"><a href="#Java-继承" class="headerlink" title="Java 继承"></a>Java 继承</h1><hr>
<h2 id="继承的概念"><a href="#继承的概念" class="headerlink" title="继承的概念"></a>继承的概念</h2><p>继承是java面向对象编程技术的一块基石，因为它允许创建分等级层次的类。</p>
<p>继承就是子类继承父类的特征和行为，使得子类对象（实例）具有父类的实例域和方法，或子类从父类继承方法，使得子类具有父类相同的行为。</p>
<h3 id="生活中的继承："><a href="#生活中的继承：" class="headerlink" title="生活中的继承："></a>生活中的继承：</h3><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://www.runoob.com/wp-content/uploads/2013/12/14B0951E-FC75-47A3-B611-4E1883887339.jpg" alt="img"></p>
<p>兔子和羊属于食草动物类，狮子和豹属于食肉动物类。</p>
<p>食草动物和食肉动物又是属于动物类。</p>
<p>所以继承需要符合的关系是：is-a，父类更通用，子类更具体。</p>
<p>虽然食草动物和食肉动物都是属于动物，但是两者的属性和行为上有差别，所以子类会具有父类的一般特性也会具有自身的特性。</p>
<h3 id="类的继承格式"><a href="#类的继承格式" class="headerlink" title="类的继承格式"></a>类的继承格式</h3><p>在 Java 中通过 extends 关键字可以申明一个类是从另外一个类继承而来的，一般形式如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">class 父类 &#123;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">class 子类 extends 父类 &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="继承类型"><a href="#继承类型" class="headerlink" title="继承类型"></a>继承类型</h3><p>需要注意的是 Java 不支持多继承，但支持多重继承。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://www.runoob.com/wp-content/uploads/2013/12/java-extends-2020-12-08.png" alt="img"></p>
<h2 id="继承的特性"><a href="#继承的特性" class="headerlink" title="继承的特性"></a>继承的特性</h2><ul>
<li>子类拥有父类非 private 的属性、方法。</li>
<li>子类可以拥有自己的属性和方法，即子类可以对父类进行扩展。</li>
<li>子类可以用自己的方式实现父类的方法。</li>
<li>Java 的继承是单继承，但是可以多重继承，单继承就是一个子类只能继承一个父类，多重继承就是，例如 B 类继承 A 类，C 类继承 B 类，所以按照关系就是 B 类是 C 类的父类，A 类是 B 类的父类，这是 Java 继承区别于 C++ 继承的一个特性。</li>
<li>提高了类之间的耦合性（继承的缺点，耦合度高就会造成代码之间的联系越紧密，代码独立性越差）。</li>
</ul>
<h2 id="继承关键字"><a href="#继承关键字" class="headerlink" title="继承关键字"></a>继承关键字</h2><p>继承可以使用 extends 和 implements 这两个关键字来实现继承，而且所有的类都是继承于 java.lang.Object，当一个类没有继承的两个关键字，则默认继承 Object（这个类在 <strong>java.lang</strong> 包中，所以不需要 <strong>import</strong>）祖先类。</p>
<h3 id="extends关键字"><a href="#extends关键字" class="headerlink" title="extends关键字"></a>extends关键字</h3><p>在 Java 中，类的继承是单一继承，也就是说，一个子类只能拥有一个父类，所以 extends 只能继承一个类。</p>
<h2 id="构造器"><a href="#构造器" class="headerlink" title="构造器"></a>构造器</h2><p>子类是不继承父类的构造器（构造方法或者构造函数）的，它只是调用（隐式或显式）。如果父类的构造器带有参数，则必须在子类的构造器中显式地通过 <strong>super</strong> 关键字调用父类的构造器并配以适当的参数列表。</p>
<p>如果父类构造器没有参数，则在子类的构造器中不需要使用 <strong>super</strong> 关键字调用父类构造器，系统会自动调用父类的无参构造器。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SuperClass</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="type">int</span> n;</span><br><span class="line">  SuperClass()&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;SuperClass()&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  SuperClass(<span class="type">int</span> n) &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;SuperClass(int n)&quot;</span>);</span><br><span class="line">    <span class="built_in">this</span>.n = n;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// SubClass 类继承</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SubClass</span> <span class="keyword">extends</span> <span class="title class_">SuperClass</span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="type">int</span> n;</span><br><span class="line">  </span><br><span class="line">  SubClass()&#123; <span class="comment">// 自动调用父类的无参数构造器</span></span><br><span class="line">    System.out.println(<span class="string">&quot;SubClass&quot;</span>);</span><br><span class="line">  &#125;  </span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">SubClass</span><span class="params">(<span class="type">int</span> n)</span>&#123; </span><br><span class="line">    <span class="built_in">super</span>(<span class="number">300</span>);  <span class="comment">// 调用父类中带有参数的构造器</span></span><br><span class="line">    System.out.println(<span class="string">&quot;SubClass(int n):&quot;</span>+n);</span><br><span class="line">    <span class="built_in">this</span>.n = n;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// SubClass2 类继承</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SubClass2</span> <span class="keyword">extends</span> <span class="title class_">SuperClass</span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="type">int</span> n;</span><br><span class="line">  </span><br><span class="line">  SubClass2()&#123;</span><br><span class="line">    <span class="built_in">super</span>(<span class="number">300</span>);  <span class="comment">// 调用父类中带有参数的构造器</span></span><br><span class="line">    System.out.println(<span class="string">&quot;SubClass2&quot;</span>);</span><br><span class="line">  &#125;  </span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">SubClass2</span><span class="params">(<span class="type">int</span> n)</span>&#123; <span class="comment">// 自动调用父类的无参数构造器</span></span><br><span class="line">    System.out.println(<span class="string">&quot;SubClass2(int n):&quot;</span>+n);</span><br><span class="line">    <span class="built_in">this</span>.n = n;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestSuperSub</span>&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span> <span class="params">(String args[])</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;------SubClass 类继承------&quot;</span>);</span><br><span class="line">    <span class="type">SubClass</span> <span class="variable">sc1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SubClass</span>();</span><br><span class="line">    <span class="type">SubClass</span> <span class="variable">sc2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SubClass</span>(<span class="number">100</span>); </span><br><span class="line">    System.out.println(<span class="string">&quot;------SubClass2 类继承------&quot;</span>);</span><br><span class="line">    <span class="type">SubClass2</span> <span class="variable">sc3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SubClass2</span>();</span><br><span class="line">    <span class="type">SubClass2</span> <span class="variable">sc4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SubClass2</span>(<span class="number">200</span>); </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Java-重写-Override-与重载-Overload"><a href="#Java-重写-Override-与重载-Overload" class="headerlink" title="Java 重写(Override)与重载(Overload)"></a>Java 重写(Override)与重载(Overload)</h1><hr>
<h2 id="重写-Override"><a href="#重写-Override" class="headerlink" title="重写(Override)"></a>重写(Override)</h2><p>重写是子类对父类的允许访问的方法的实现过程进行重新编写, 返回值和形参都不能改变。<strong>即外壳不变，核心重写！</strong></p>
<p>重写的好处在于子类可以根据需要，定义特定于自己的行为。 也就是说子类能够根据需要实现父类的方法。</p>
<p>重写方法不能抛出新的检查异常或者比被重写方法申明更加宽泛的异常。例如： 父类的一个方法申明了一个检查异常 IOException，但是在重写这个方法的时候不能抛出 Exception 异常，因为 Exception 是 IOException 的父类，抛出 IOException 异常或者 IOException 的子类异常。</p>
<p>在面向对象原则里，重写意味着可以重写任何现有方法。实例如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span>&#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">move</span><span class="params">()</span>&#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;动物可以移动&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span> <span class="keyword">extends</span> <span class="title class_">Animal</span>&#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">move</span><span class="params">()</span>&#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;狗可以跑和走&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestDog</span>&#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span>&#123;</span><br><span class="line">      <span class="type">Animal</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Animal</span>(); <span class="comment">// Animal 对象</span></span><br><span class="line">      <span class="type">Animal</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Dog</span>(); <span class="comment">// Dog 对象</span></span><br><span class="line"> </span><br><span class="line">      a.move();<span class="comment">// 执行 Animal 类的方法</span></span><br><span class="line"> </span><br><span class="line">      b.move();<span class="comment">//执行 Dog 类的方法</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="方法的重写规则"><a href="#方法的重写规则" class="headerlink" title="方法的重写规则"></a>方法的重写规则</h2><ul>
<li>参数列表与被重写方法的参数列表必须完全相同。</li>
<li>返回类型与被重写方法的返回类型可以不相同，但是必须是父类返回值的派生类（java5 及更早版本返回类型要一样，java7 及更高版本可以不同）。</li>
<li>访问权限不能比父类中被重写的方法的访问权限更低。例如：如果父类的一个方法被声明为 public，那么在子类中重写该方法就不能声明为 protected。</li>
<li>父类的成员方法只能被它的子类重写。</li>
<li>声明为 final 的方法不能被重写。</li>
<li>声明为 static 的方法不能被重写，但是能够被再次声明。</li>
<li>子类和父类在同一个包中，那么子类可以重写父类所有方法，除了声明为 private 和 final 的方法。</li>
<li>子类和父类不在同一个包中，那么子类只能够重写父类的声明为 public 和 protected 的非 final 方法。</li>
<li>重写的方法能够抛出任何非强制异常，无论被重写的方法是否抛出异常。但是，重写的方法不能抛出新的强制性异常，或者比被重写方法声明的更广泛的强制性异常，反之则可以。</li>
<li>构造方法不能被重写。</li>
<li>如果不能继承一个类，则不能重写该类的方法。</li>
</ul>
<h2 id="重载-Overload"><a href="#重载-Overload" class="headerlink" title="重载(Overload)"></a>重载(Overload)</h2><p>重载(overloading) 是在一个类里面，方法名字相同，而参数不同。返回类型可以相同也可以不同。</p>
<p>每个重载的方法（或者构造函数）都必须有一个独一无二的参数类型列表。</p>
<p>最常用的地方就是构造器的重载。</p>
<p><strong>重载规则:</strong></p>
<ul>
<li>被重载的方法必须改变参数列表(参数个数或类型不一样)；</li>
<li>被重载的方法可以改变返回类型；</li>
<li>被重载的方法可以改变访问修饰符；</li>
<li>被重载的方法可以声明新的或更广的检查异常；</li>
<li>方法能够在同一个类中或者在一个子类中被重载。</li>
<li>无法以返回值类型作为重载函数的区分标准。</li>
</ul>
<h2 id="重写与重载之间的区别"><a href="#重写与重载之间的区别" class="headerlink" title="重写与重载之间的区别"></a>重写与重载之间的区别</h2><table>
<thead>
<tr>
<th align="left">区别点</th>
<th align="left">重载方法</th>
<th align="left">重写方法</th>
</tr>
</thead>
<tbody><tr>
<td align="left">参数列表</td>
<td align="left">必须修改</td>
<td align="left">一定不能修改</td>
</tr>
<tr>
<td align="left">返回类型</td>
<td align="left">可以修改</td>
<td align="left">一定不能修改</td>
</tr>
<tr>
<td align="left">异常</td>
<td align="left">可以修改</td>
<td align="left">可以减少或删除，一定不能抛出新的或者更广的异常</td>
</tr>
<tr>
<td align="left">访问</td>
<td align="left">可以修改</td>
<td align="left">一定不能做更严格的限制（可以降低限制）</td>
</tr>
</tbody></table>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>方法的重写(Overriding)和重载(Overloading)是java多态性的不同表现，重写是父类与子类之间多态性的一种表现，重载可以理解成多态的具体表现形式。</p>
<ul>
<li>(1)方法重载是一个类中定义了多个方法名相同,而他们的参数的数量不同或数量相同而类型和次序不同,则称为方法的重载(Overloading)。</li>
<li>(2)方法重写是在子类存在方法与父类的方法的名字相同,而且参数的个数与类型一样,返回值也一样的方法,就称为重写(Overriding)。</li>
<li>(3)方法重载是一个类的多态性表现,而方法重写是子类与父类的一种多态性表现。</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://www.runoob.com/wp-content/uploads/2013/12/overloading-vs-overriding.png" alt="img"></p>
<h1 id="Java-多态"><a href="#Java-多态" class="headerlink" title="Java 多态"></a>Java 多态</h1><hr>
<p>多态是同一个行为具有多个不同表现形式或形态的能力。</p>
<p>多态就是同一个接口，使用不同的实例而执行不同操作，如图所示：</p>
<h3 id="多态的优点"><a href="#多态的优点" class="headerlink" title="多态的优点"></a>多态的优点</h3><ul>
<li><ol>
<li>消除类型之间的耦合关系</li>
</ol>
</li>
<li><ol start="2">
<li>可替换性</li>
</ol>
</li>
<li><ol start="3">
<li>可扩充性</li>
</ol>
</li>
<li><ol start="4">
<li>接口性</li>
</ol>
</li>
<li><ol start="5">
<li>灵活性</li>
</ol>
</li>
<li><ol start="6">
<li>简化性</li>
</ol>
</li>
</ul>
<h3 id="多态存在的三个必要条件"><a href="#多态存在的三个必要条件" class="headerlink" title="多态存在的三个必要条件"></a>多态存在的三个必要条件</h3><ul>
<li>继承</li>
<li>重写</li>
<li>父类引用指向子类对象：<strong>Parent p &#x3D; new Child();</strong></li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://www.runoob.com/wp-content/uploads/2013/12/2DAC601E-70D8-4B3C-86CC-7E4972FC2466.jpg" alt="img"></p>
<h2 id="多态的实现方式"><a href="#多态的实现方式" class="headerlink" title="多态的实现方式"></a>多态的实现方式</h2><h3 id="方式一：重写："><a href="#方式一：重写：" class="headerlink" title="方式一：重写："></a>方式一：重写：</h3><p>这个内容已经在上一章节详细讲过，就不再阐述，详细可访问：<a target="_blank" rel="noopener" href="https://www.runoob.com/java/java-override-overload.html">Java 重写(Override)与重载(Overload)</a>。</p>
<h3 id="方式二：接口"><a href="#方式二：接口" class="headerlink" title="方式二：接口"></a>方式二：接口</h3><ul>
<li><ol>
<li>生活中的接口最具代表性的就是插座，例如一个三接头的插头都能接在三孔插座中，因为这个是每个国家都有各自规定的接口规则，有可能到国外就不行，那是因为国外自己定义的接口类型。</li>
</ol>
</li>
<li><ol start="2">
<li>java中的接口类似于生活中的接口，就是一些方法特征的集合，但没有方法的实现。具体可以看 <a target="_blank" rel="noopener" href="https://www.runoob.com/java/java-interfaces.html">java接口</a> 这一章节的内容。</li>
</ol>
</li>
</ul>
<h3 id="方式三：抽象类和抽象方法"><a href="#方式三：抽象类和抽象方法" class="headerlink" title="方式三：抽象类和抽象方法"></a>方式三：抽象类和抽象方法</h3><h1 id="Java-抽象类"><a href="#Java-抽象类" class="headerlink" title="Java 抽象类"></a>Java 抽象类</h1><hr>
<p>在面向对象的概念中，所有的对象都是通过类来描绘的，但是反过来，并不是所有的类都是用来描绘对象的，如果一个类中没有包含足够的信息来描绘一个具体的对象，这样的类就是抽象类。</p>
<p>抽象类除了不能实例化对象之外，类的其它功能依然存在，成员变量、成员方法和构造方法的访问方式和普通类一样。</p>
<p>由于抽象类不能实例化对象，所以抽象类必须被继承，才能被使用。也是因为这个原因，通常在设计阶段决定要不要设计抽象类。</p>
<p>父类包含了子类集合的常见的方法，但是由于父类本身是抽象的，所以不能使用这些方法。</p>
<p>在 Java 中抽象类表示的是一种继承关系，一个类只能继承一个抽象类，而一个类却可以实现多个接口。</p>
<h2 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h2><p>在 Java 语言中使用 abstract class 来定义抽象类。如下实例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 文件名 : Employee.java */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Employee</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="keyword">private</span> String name;</span><br><span class="line">   <span class="keyword">private</span> String address;</span><br><span class="line">   <span class="keyword">private</span> <span class="type">int</span> number;</span><br><span class="line">   <span class="keyword">public</span> <span class="title function_">Employee</span><span class="params">(String name, String address, <span class="type">int</span> number)</span></span><br><span class="line">   &#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;Constructing an Employee&quot;</span>);</span><br><span class="line">      <span class="built_in">this</span>.name = name;</span><br><span class="line">      <span class="built_in">this</span>.address = address;</span><br><span class="line">      <span class="built_in">this</span>.number = number;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">computePay</span><span class="params">()</span></span><br><span class="line">   &#123;</span><br><span class="line">     System.out.println(<span class="string">&quot;Inside Employee computePay&quot;</span>);</span><br><span class="line">     <span class="keyword">return</span> <span class="number">0.0</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">mailCheck</span><span class="params">()</span></span><br><span class="line">   &#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;Mailing a check to &quot;</span> + <span class="built_in">this</span>.name</span><br><span class="line">       + <span class="string">&quot; &quot;</span> + <span class="built_in">this</span>.address);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span></span><br><span class="line">   &#123;</span><br><span class="line">      <span class="keyword">return</span> name + <span class="string">&quot; &quot;</span> + address + <span class="string">&quot; &quot;</span> + number;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span></span><br><span class="line">   &#123;</span><br><span class="line">      <span class="keyword">return</span> name;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">public</span> String <span class="title function_">getAddress</span><span class="params">()</span></span><br><span class="line">   &#123;</span><br><span class="line">      <span class="keyword">return</span> address;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAddress</span><span class="params">(String newAddress)</span></span><br><span class="line">   &#123;</span><br><span class="line">      address = newAddress;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getNumber</span><span class="params">()</span></span><br><span class="line">   &#123;</span><br><span class="line">     <span class="keyword">return</span> number;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="抽象方法"><a href="#抽象方法" class="headerlink" title="抽象方法"></a>抽象方法</h2><p>如果你想设计这样一个类，该类包含一个特别的成员方法，该方法的具体实现由它的子类确定，那么你可以在父类中声明该方法为抽象方法。</p>
<p>Abstract 关键字同样可以用来声明抽象方法，抽象方法只包含一个方法名，而没有方法体。</p>
<p>抽象方法没有定义，方法名后面直接跟一个分号，而不是花括号。</p>
<p>声明抽象方法会造成以下两个结果：</p>
<ul>
<li>如果一个类包含抽象方法，那么该类必须是抽象类。</li>
<li>任何子类必须重写父类的抽象方法，或者声明自身为抽象类。</li>
</ul>
<p>继承抽象方法的子类必须重写该方法。否则，该子类也必须声明为抽象类。最终，必须有子类实现该抽象方法，否则，从最初的父类到最终的子类都不能用来实例化对象。</p>
<h2 id="抽象类总结规定"><a href="#抽象类总结规定" class="headerlink" title="抽象类总结规定"></a>抽象类总结规定</h2><ul>
<li>\1. 抽象类不能被实例化(初学者很容易犯的错)，如果被实例化，就会报错，编译无法通过。只有抽象类的非抽象子类可以创建对象。</li>
<li>\2. 抽象类中不一定包含抽象方法，但是有抽象方法的类必定是抽象类。</li>
<li>\3. 抽象类中的抽象方法只是声明，不包含方法体，就是不给出方法的具体实现也就是方法的具体功能。</li>
<li>\4. 构造方法，类方法（用 static 修饰的方法）不能声明为抽象方法。</li>
<li>\5. 抽象类的子类必须给出抽象类中的抽象方法的具体实现，除非该子类也是抽象类。</li>
</ul>
<h1 id="Java-封装"><a href="#Java-封装" class="headerlink" title="Java 封装"></a>Java 封装</h1><hr>
<p>在面向对象程式设计方法中，封装（英语：Encapsulation）是指一种将抽象性函式接口的实现细节部分包装、隐藏起来的方法。</p>
<p>封装可以被认为是一个保护屏障，防止该类的代码和数据被外部类定义的代码随机访问。</p>
<p>要访问该类的代码和数据，必须通过严格的接口控制。</p>
<p>封装最主要的功能在于我们能修改自己的实现代码，而不用修改那些调用我们代码的程序片段。</p>
<p>适当的封装可以让程式码更容易理解与维护，也加强了程式码的安全性。</p>
<h3 id="封装的优点"><a href="#封装的优点" class="headerlink" title="封装的优点"></a>封装的优点</h3><ul>
<li>\1. 良好的封装能够减少耦合。</li>
<li>\2. 类内部的结构可以自由修改。</li>
<li>\3. 可以对成员变量进行更精确的控制。</li>
<li>\4. 隐藏信息，实现细节。</li>
</ul>
<h1 id="Java-接口"><a href="#Java-接口" class="headerlink" title="Java 接口"></a>Java 接口</h1><p>接口（英文：Interface），在JAVA编程语言中是一个抽象类型，是抽象方法的集合，接口通常以interface来声明。一个类通过继承接口的方式，从而来继承接口的抽象方法。</p>
<p>接口并不是类，编写接口的方式和类很相似，但是它们属于不同的概念。类描述对象的属性和方法。接口则包含类要实现的方法。</p>
<p>除非实现接口的类是抽象类，否则该类要定义接口中的所有方法。</p>
<p>接口无法被实例化，但是可以被实现。一个实现接口的类，必须实现接口内所描述的所有方法，否则就必须声明为抽象类。另外，在 Java 中，接口类型可用来声明一个变量，他们可以成为一个空指针，或是被绑定在一个以此接口实现的对象。</p>
<h3 id="接口与类相似点："><a href="#接口与类相似点：" class="headerlink" title="接口与类相似点："></a>接口与类相似点：</h3><ul>
<li>一个接口可以有多个方法。</li>
<li>接口文件保存在 .java 结尾的文件中，文件名使用接口名。</li>
<li>接口的字节码文件保存在 .class 结尾的文件中。</li>
<li>接口相应的字节码文件必须在与包名称相匹配的目录结构中。</li>
</ul>
<h3 id="接口与类的区别："><a href="#接口与类的区别：" class="headerlink" title="接口与类的区别："></a>接口与类的区别：</h3><ul>
<li>接口不能用于实例化对象。</li>
<li>接口没有构造方法。</li>
<li>接口中所有的方法必须是抽象方法，Java 8 之后 接口中可以使用 default 关键字修饰的非抽象方法。</li>
<li>接口不能包含成员变量，除了 static 和 final 变量。</li>
<li>接口不是被类继承了，而是要被类实现。</li>
<li>接口支持多继承。</li>
</ul>
<h3 id="接口特性"><a href="#接口特性" class="headerlink" title="接口特性"></a>接口特性</h3><ul>
<li>接口中每一个方法也是隐式抽象的,接口中的方法会被隐式的指定为 <strong>public abstract</strong>（只能是 public abstract，其他修饰符都会报错）。</li>
<li>接口中可以含有变量，但是接口中的变量会被隐式的指定为 <strong>public static final</strong> 变量（并且只能是 public，用 private 修饰会报编译错误）。</li>
<li>接口中的方法是不能在接口中实现的，只能由实现接口的类来实现接口中的方法。</li>
</ul>
<h3 id="抽象类和接口的区别"><a href="#抽象类和接口的区别" class="headerlink" title="抽象类和接口的区别"></a>抽象类和接口的区别</h3><ul>
<li>\1. 抽象类中的方法可以有方法体，就是能实现方法的具体功能，但是接口中的方法不行。</li>
<li>\2. 抽象类中的成员变量可以是各种类型的，而接口中的成员变量只能是 <strong>public static final</strong> 类型的。</li>
<li>\3. 接口中不能含有静态代码块以及静态方法(用 static 修饰的方法)，而抽象类是可以有静态代码块和静态方法。</li>
<li>\4. 一个类只能继承一个抽象类，而一个类却可以实现多个接口。</li>
</ul>
<blockquote>
<p><strong>注</strong>：JDK 1.8 以后，接口里可以有静态方法和方法体了。</p>
<p><strong>注</strong>：JDK 1.8 以后，接口允许包含具体实现的方法，该方法称为”默认方法”，默认方法使用 default 关键字修饰。更多内容可参考 <a target="_blank" rel="noopener" href="https://www.runoob.com/java/java8-default-methods.html">Java 8 默认方法</a>。</p>
<p><strong>注</strong>：JDK 1.9 以后，允许将方法定义为 private，使得某些复用的代码不会把方法暴露出去。更多内容可参考 <a target="_blank" rel="noopener" href="https://www.runoob.com/java/java9-private-interface-methods.html">Java 9 私有接口方法</a>。</p>
</blockquote>
<p>接口有以下特性：</p>
<ul>
<li>接口是隐式抽象的，当声明一个接口的时候，不必使用<strong>abstract</strong>关键字。</li>
<li>接口中每一个方法也是隐式抽象的，声明时同样不需要<strong>abstract</strong>关键字。</li>
<li>接口中的方法都是公有的。</li>
</ul>
<p>重写接口中声明的方法时，需要注意以下规则：</p>
<ul>
<li>类在实现接口的方法时，不能抛出强制性异常，只能在接口中，或者继承接口的抽象类中抛出该强制性异常。</li>
<li>类在重写方法时要保持一致的方法名，并且应该保持相同或者相兼容的返回值类型。</li>
<li>如果实现接口的类是抽象类，那么就没必要实现该接口的方法。</li>
</ul>
<p>在实现接口的时候，也要注意一些规则：</p>
<ul>
<li>一个类可以同时实现多个接口。</li>
<li>一个类只能继承一个类，但是能实现多个接口。</li>
<li>一个接口能继承另一个接口，这和类之间的继承比较相似。</li>
</ul>
<h2 id="标记接口"><a href="#标记接口" class="headerlink" title="标记接口"></a>标记接口</h2><p>最常用的继承接口是没有包含任何方法的接口。</p>
<p>标记接口是没有任何方法和属性的接口.它仅仅表明它的类属于一个特定的类型,供其他代码来测试允许做一些事情。</p>
<p>标记接口作用：简单形象的说就是给某个对象打个标（盖个戳），使对象拥有某个或某些特权。</p>
<p>例如：java.awt.event 包中的 MouseListener 接口继承的 java.util.EventListener 接口定义如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package java.util; public interface EventListener &#123;&#125;</span><br></pre></td></tr></table></figure>

<p>没有任何方法的接口被称为标记接口。标记接口主要用于以下两种目的：</p>
<ul>
<li><p>建立一个公共的父接口：</p>
<p>正如EventListener接口，这是由几十个其他接口扩展的Java API，你可以使用一个标记接口来建立一组接口的父接口。例如：当一个接口继承了EventListener接口，Java虚拟机(JVM)就知道该接口将要被用于一个事件的代理方案。</p>
</li>
<li><p>向一个类添加数据类型：</p>
<p>这种情况是标记接口最初的目的，实现标记接口的类不需要定义任何接口方法(因为标记接口根本就没有方法)，但是该类通过多态性变成一个接口类型。</p>
</li>
</ul>
<h1 id="Java-枚举-enum"><a href="#Java-枚举-enum" class="headerlink" title="Java 枚举(enum)"></a>Java 枚举(enum)</h1><p>Java 枚举是一个特殊的类，一般表示一组常量，比如一年的 4 个季节，一年的 12 个月份，一个星期的 7 天，方向有东南西北等。</p>
<p>Java 枚举类使用 enum 关键字来定义，各个常量使用逗号 <strong>,</strong> 来分割。</p>
<p>例如定义一个颜色的枚举类。</p>
<p>enum Color<br>{<br>    RED, GREEN, BLUE;<br>} </p>
<h3 id="values-ordinal-和-valueOf-方法"><a href="#values-ordinal-和-valueOf-方法" class="headerlink" title="values(), ordinal() 和 valueOf() 方法"></a>values(), ordinal() 和 valueOf() 方法</h3><p>enum 定义的枚举类默认继承了 java.lang.Enum 类，并实现了 java.lang.Serializable 和 java.lang.Comparable 两个接口。</p>
<p>values(), ordinal() 和 valueOf() 方法位于 java.lang.Enum 类中：</p>
<ul>
<li>values() 返回枚举类中所有的值。</li>
<li>ordinal()方法可以找到每个枚举常量的索引，就像数组索引一样。</li>
<li>valueOf()方法返回指定字符串值的枚举常量。</li>
</ul>
<h1 id="Java-包-package"><a href="#Java-包-package" class="headerlink" title="Java 包(package)"></a>Java 包(package)</h1><p>为了更好地组织类，Java 提供了包机制，用于区别类名的命名空间。</p>
<h3 id="包的作用"><a href="#包的作用" class="headerlink" title="包的作用"></a>包的作用</h3><ul>
<li>1、把功能相似或相关的类或接口组织在同一个包中，方便类的查找和使用。</li>
<li>2、如同文件夹一样，包也采用了树形目录的存储方式。同一个包中的类名字是不同的，不同的包中的类的名字是可以相同的，当同时调用两个不同包中相同类名的类时，应该加上包名加以区别。因此，包可以避免名字冲突。</li>
<li>3、包也限定了访问权限，拥有包访问权限的类才能访问某个包中的类。</li>
</ul>
<p>Java 使用包（package）这种机制是为了防止命名冲突，访问控制，提供搜索和定位类（class）、接口、枚举（enumerations）和注释（annotation）等。</p>
<p>一个包（package）可以定义为一组相互联系的类型（类、接口、枚举和注释），为这些类型提供访问保护和命名空间管理的功能。</p>
<p>以下是一些 Java 中的包：</p>
<ul>
<li><strong>java.lang</strong>-打包基础的类</li>
<li><strong>java.io</strong>-包含输入输出功能的函数</li>
</ul>
<p>开发者可以自己把一组类和接口等打包，并定义自己的包。而且在实际开发中这样做是值得提倡的，当你自己完成类的实现之后，将相关的类分组，可以让其他的编程者更容易地确定哪些类、接口、枚举和注释等是相关的。</p>
<p>由于包创建了新的命名空间（namespace），所以不会跟其他包中的任何名字产生命名冲突。使用包这种机制，更容易实现访问控制，并且让定位相关类更加简单。</p>
<h2 id="创建包"><a href="#创建包" class="headerlink" title="创建包"></a>创建包</h2><p>创建包的时候，你需要为这个包取一个合适的名字。之后，如果其他的一个源文件包含了这个包提供的类、接口、枚举或者注释类型的时候，都必须将这个包的声明放在这个源文件的开头。</p>
<p>包声明应该在源文件的第一行，每个源文件只能有一个包声明，这个文件中的每个类型都应用于它。</p>
<p>如果一个源文件中没有使用包声明，那么其中的类，函数，枚举，注释等将被放在一个无名的包（unnamed package）中。</p>
<h2 id="import-关键字"><a href="#import-关键字" class="headerlink" title="import 关键字"></a>import 关键字</h2><p>为了能够使用某一个包的成员，我们需要在 Java 程序中明确导入该包。</p>
<p>在 Java 中，<strong>import</strong> 关键字用于导入其他类或包中定义的类型，以便在当前源文件中使用这些类型。</p>
<p><strong>import</strong> 关键字用于引入其他包中的类、接口或静态成员，它允许你在代码中直接使用其他包中的类，而不需要完整地指定类的包名。</p>
<h1 id="Java-集合框架"><a href="#Java-集合框架" class="headerlink" title="Java 集合框架"></a>Java 集合框架</h1><p>早在 Java 2 中之前，Java 就提供了特设类。比如：Dictionary, Vector, Stack, 和 Properties 这些类用来存储和操作对象组。</p>
<p>虽然这些类都非常有用，但是它们缺少一个核心的，统一的主题。由于这个原因，使用 Vector 类的方式和使用 Properties 类的方式有着很大不同。</p>
<p>集合框架被设计成要满足以下几个目标。</p>
<ul>
<li>该框架必须是高性能的。基本集合（动态数组，链表，树，哈希表）的实现也必须是高效的。</li>
<li>该框架允许不同类型的集合，以类似的方式工作，具有高度的互操作性。</li>
<li>对一个集合的扩展和适应必须是简单的。</li>
</ul>
<p>为此，整个集合框架就围绕一组标准接口而设计。你可以直接使用这些接口的标准实现，诸如： <strong>LinkedList</strong>, <strong>HashSet</strong>, 和 <strong>TreeSet</strong> 等,除此之外你也可以通过这些接口实现自己的集合。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://www.runoob.com/wp-content/uploads/2014/01/2243690-9cd9c896e0d512ed.gif" alt="img"></p>
<p>从上面的集合框架图可以看到，Java 集合框架主要包括两种类型的容器，一种是集合（Collection），存储一个元素集合，另一种是图（Map），存储键&#x2F;值对映射。Collection 接口又有 3 种子类型，List、Set 和 Queue，再下面是一些抽象类，最后是具体实现类，常用的有 <a target="_blank" rel="noopener" href="https://www.runoob.com/java/java-arraylist.html">ArrayList</a>、<a target="_blank" rel="noopener" href="https://www.runoob.com/java/java-linkedlist.html">LinkedList</a>、<a target="_blank" rel="noopener" href="https://www.runoob.com/java/java-hashset.html">HashSet</a>、LinkedHashSet、<a target="_blank" rel="noopener" href="https://www.runoob.com/java/java-hashmap.html">HashMap</a>、LinkedHashMap 等等。</p>
<p>集合框架是一个用来代表和操纵集合的统一架构。所有的集合框架都包含如下内容：</p>
<p>- </p>
<p>  <strong>接口：</strong>是代表集合的抽象数据类型。例如 Collection、List、Set、Map 等。之所以定义多个接口，是为了以不同的方式操作集合对象</p>
<ul>
<li><p><strong>实现（类）：</strong>是集合接口的具体实现。从本质上讲，它们是可重复使用的数据结构，例如：ArrayList、LinkedList、HashSet、HashMap。</p>
</li>
<li><p><strong>算法：</strong>是实现集合接口的对象里的方法执行的一些有用的计算，例如：搜索和排序，这些算法实现了多态，那是因为相同的方法可以在相似的接口上有着不同的实现。</p>
</li>
</ul>
<p>除了集合，该框架也定义了几个 Map 接口和类。Map 里存储的是键&#x2F;值对。尽管 Map 不是集合，但是它们完全整合在集合中。</p>
<h2 id="集合接口"><a href="#集合接口" class="headerlink" title="集合接口"></a>集合接口</h2><p>集合框架定义了一些接口。本节提供了每个接口的概述：</p>
<table>
<thead>
<tr>
<th align="left">序号</th>
<th align="left">接口描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">1</td>
<td align="left">Collection 接口 Collection 是最基本的集合接口，一个 Collection 代表一组 Object，即 Collection 的元素, Java不提供直接继承自Collection的类，只提供继承于的子接口(如List和set)。Collection 接口存储一组不唯一，无序的对象。</td>
</tr>
<tr>
<td align="left">2</td>
<td align="left">List 接口 List接口是一个有序的 Collection，使用此接口能够精确的控制每个元素插入的位置，能够通过索引(元素在List中位置，类似于数组的下标)来访问List中的元素，第一个元素的索引为 0，而且允许有相同的元素。List 接口存储一组不唯一，有序（插入顺序）的对象。</td>
</tr>
<tr>
<td align="left">3</td>
<td align="left">Set Set 具有与 Collection 完全一样的接口，只是行为上不同，Set 不保存重复的元素。Set 接口存储一组唯一，无序的对象。</td>
</tr>
<tr>
<td align="left">4</td>
<td align="left">SortedSet 继承于Set保存有序的集合。</td>
</tr>
<tr>
<td align="left">5</td>
<td align="left">Map Map 接口存储一组键值对象，提供key（键）到value（值）的映射。</td>
</tr>
<tr>
<td align="left">6</td>
<td align="left">Map.Entry 描述在一个Map中的一个元素（键&#x2F;值对）。是一个 Map 的内部接口。</td>
</tr>
<tr>
<td align="left">7</td>
<td align="left">SortedMap 继承于 Map，使 Key 保持在升序排列。</td>
</tr>
<tr>
<td align="left">8</td>
<td align="left">Enumeration 这是一个传统的接口和定义的方法，通过它可以枚举（一次获得一个）对象集合中的元素。这个传统接口已被迭代器取代。</td>
</tr>
</tbody></table>
<h3 id="Set和List的区别"><a href="#Set和List的区别" class="headerlink" title="Set和List的区别"></a>Set和List的区别</h3><ul>
<li>\1. Set 接口实例存储的是无序的，不重复的数据。List 接口实例存储的是有序的，可以重复的元素。</li>
<li>\2. Set 检索效率低下，删除和插入效率高，插入和删除不会引起元素位置改变 **&lt;实现类有HashSet,TreeSet&gt;**。</li>
<li>\3. List 和数组类似，可以动态增长，根据实际存储的数据的长度自动增长 List 的长度。查找元素效率高，插入删除效率低，因为会引起其他元素位置改变 <strong>&lt;实现类有ArrayList,LinkedList,Vector&gt;</strong> 。</li>
</ul>
<h2 id="如何使用迭代器"><a href="#如何使用迭代器" class="headerlink" title="如何使用迭代器"></a>如何使用迭代器</h2><p>通常情况下，你会希望遍历一个集合中的元素。例如，显示集合中的每个元素。</p>
<p>一般遍历数组都是采用for循环或者增强for，这两个方法也可以用在集合框架，但是还有一种方法是采用迭代器遍历集合框架，它是一个对象，实现了<a target="_blank" rel="noopener" href="https://www.runoob.com/java/java-iterator.html">Iterator</a> 接口或 ListIterator接口。</p>
<p>迭代器，使你能够通过循环来得到或删除集合的元素。ListIterator 继承了 Iterator，以允许双向遍历列表和修改元素。</p>
<table>
<thead>
<tr>
<th align="left">序号</th>
<th align="left">迭代器方法描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">1</td>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/java/java-iterator.html">使用 Java Iterator</a> 这里通过实例列出 Iterator 和 ListIterator 接口提供的所有方法</td>
</tr>
</tbody></table>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">     List&lt;String&gt; list=<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();</span><br><span class="line">     list.add(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">     list.add(<span class="string">&quot;World&quot;</span>);</span><br><span class="line">     list.add(<span class="string">&quot;HAHAHAHA&quot;</span>);</span><br><span class="line">     <span class="comment">//第一种遍历方法使用 For-Each 遍历 List</span></span><br><span class="line">     <span class="keyword">for</span> (String str : list) &#123;            <span class="comment">//也可以改写 for(int i=0;i&lt;list.size();i++) 这种形式</span></span><br><span class="line">        System.out.println(str);</span><br><span class="line">     &#125;</span><br><span class="line"> </span><br><span class="line">     <span class="comment">//第二种遍历，把链表变为数组相关的内容进行遍历</span></span><br><span class="line">     String[] strArray=<span class="keyword">new</span> <span class="title class_">String</span>[list.size()];</span><br><span class="line">     list.toArray(strArray);</span><br><span class="line">     <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;strArray.length;i++) <span class="comment">//这里也可以改写为  for(String str:strArray) 这种形式</span></span><br><span class="line">     &#123;</span><br><span class="line">        System.out.println(strArray[i]);</span><br><span class="line">     &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="comment">//第三种遍历 使用迭代器进行相关遍历</span></span><br><span class="line">     </span><br><span class="line">     Iterator&lt;String&gt; ite=list.iterator();</span><br><span class="line">     <span class="keyword">while</span>(ite.hasNext())<span class="comment">//判断下一个元素之后有值</span></span><br><span class="line">     &#123;</span><br><span class="line">         System.out.println(ite.next());</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">      Map&lt;String, String&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;String, String&gt;();</span><br><span class="line">      map.put(<span class="string">&quot;1&quot;</span>, <span class="string">&quot;value1&quot;</span>);</span><br><span class="line">      map.put(<span class="string">&quot;2&quot;</span>, <span class="string">&quot;value2&quot;</span>);</span><br><span class="line">      map.put(<span class="string">&quot;3&quot;</span>, <span class="string">&quot;value3&quot;</span>);</span><br><span class="line">      </span><br><span class="line">      <span class="comment">//第一种：普遍使用，二次取值</span></span><br><span class="line">      System.out.println(<span class="string">&quot;通过Map.keySet遍历key和value：&quot;</span>);</span><br><span class="line">      <span class="keyword">for</span> (String key : map.keySet()) &#123;</span><br><span class="line">       System.out.println(<span class="string">&quot;key= &quot;</span>+ key + <span class="string">&quot; and value= &quot;</span> + map.get(key));</span><br><span class="line">      &#125;</span><br><span class="line">      </span><br><span class="line">      <span class="comment">//第二种</span></span><br><span class="line">      System.out.println(<span class="string">&quot;通过Map.entrySet使用iterator遍历key和value：&quot;</span>);</span><br><span class="line">      Iterator&lt;Map.Entry&lt;String, String&gt;&gt; it = map.entrySet().iterator();</span><br><span class="line">      <span class="keyword">while</span> (it.hasNext()) &#123;</span><br><span class="line">       Map.Entry&lt;String, String&gt; entry = it.next();</span><br><span class="line">       System.out.println(<span class="string">&quot;key= &quot;</span> + entry.getKey() + <span class="string">&quot; and value= &quot;</span> + entry.getValue());</span><br><span class="line">      &#125;</span><br><span class="line">      </span><br><span class="line">      <span class="comment">//第三种：推荐，尤其是容量大时</span></span><br><span class="line">      System.out.println(<span class="string">&quot;通过Map.entrySet遍历key和value&quot;</span>);</span><br><span class="line">      <span class="keyword">for</span> (Map.Entry&lt;String, String&gt; entry : map.entrySet()) &#123;</span><br><span class="line">       System.out.println(<span class="string">&quot;key= &quot;</span> + entry.getKey() + <span class="string">&quot; and value= &quot;</span> + entry.getValue());</span><br><span class="line">      &#125;</span><br><span class="line">    </span><br><span class="line">      <span class="comment">//第四种</span></span><br><span class="line">      System.out.println(<span class="string">&quot;通过Map.values()遍历所有的value，但不能遍历key&quot;</span>);</span><br><span class="line">      <span class="keyword">for</span> (String v : map.values()) &#123;</span><br><span class="line">       System.out.println(<span class="string">&quot;value= &quot;</span> + v);</span><br><span class="line">      &#125;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h2><p>Java集合框架为程序员提供了预先包装的数据结构和算法来操纵他们。</p>
<p>集合是一个对象，可容纳其他对象的引用。集合接口声明对每一种类型的集合可以执行的操作。</p>
<p>集合框架的类和接口均在java.util包中。</p>
<p>任何对象加入集合类后，自动转变为Object类型，所以在取出的时候，需要进行强制类型转换。</p>
<h1 id="Java-ArrayList"><a href="#Java-ArrayList" class="headerlink" title="Java ArrayList"></a>Java ArrayList</h1><h2 id="Java-ArrayList-方法"><a href="#Java-ArrayList-方法" class="headerlink" title="Java ArrayList 方法"></a>Java ArrayList 方法</h2><p>Java ArrayList 常用方法列表如下：</p>
<table>
<thead>
<tr>
<th align="left">方法</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/java/java-arraylist-add.html">add()</a></td>
<td align="left">将元素插入到指定位置的 arraylist 中</td>
</tr>
<tr>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/java/java-arraylist-addall.html">addAll()</a></td>
<td align="left">添加集合中的所有元素到 arraylist 中</td>
</tr>
<tr>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/java/java-arraylist-clear.html">clear()</a></td>
<td align="left">删除 arraylist 中的所有元素</td>
</tr>
<tr>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/java/java-arraylist-clone.html">clone()</a></td>
<td align="left">复制一份 arraylist</td>
</tr>
<tr>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/java/java-arraylist-contains.html">contains()</a></td>
<td align="left">判断元素是否在 arraylist</td>
</tr>
<tr>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/java/java-arraylist-get.html">get()</a></td>
<td align="left">通过索引值获取 arraylist 中的元素</td>
</tr>
<tr>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/java/java-arraylist-indexof.html">indexOf()</a></td>
<td align="left">返回 arraylist 中元素的索引值</td>
</tr>
<tr>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/java/java-arraylist-removeall.html">removeAll()</a></td>
<td align="left">删除存在于指定集合中的 arraylist 里的所有元素</td>
</tr>
<tr>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/java/java-arraylist-remove.html">remove()</a></td>
<td align="left">删除 arraylist 里的单个元素</td>
</tr>
<tr>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/java/java-arraylist-size.html">size()</a></td>
<td align="left">返回 arraylist 里元素数量</td>
</tr>
<tr>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/java/java-arraylist-isempty.html">isEmpty()</a></td>
<td align="left">判断 arraylist 是否为空</td>
</tr>
<tr>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/java/java-arraylist-sublist.html">subList()</a></td>
<td align="left">截取部分 arraylist 的元素</td>
</tr>
<tr>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/java/java-arraylist-set.html">set()</a></td>
<td align="left">替换 arraylist 中指定索引的元素</td>
</tr>
<tr>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/java/java-arraylist-sort.html">sort()</a></td>
<td align="left">对 arraylist 元素进行排序</td>
</tr>
<tr>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/java/java-arraylist-toarray.html">toArray()</a></td>
<td align="left">将 arraylist 转换为数组</td>
</tr>
<tr>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/java/java-arraylist-tostring.html">toString()</a></td>
<td align="left">将 arraylist 转换为字符串</td>
</tr>
<tr>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/java/java-arraylist-surecapacity.html">ensureCapacity</a>()</td>
<td align="left">设置指定容量大小的 arraylist</td>
</tr>
<tr>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/java/java-arraylist-lastindexof.html">lastIndexOf()</a></td>
<td align="left">返回指定元素在 arraylist 中最后一次出现的位置</td>
</tr>
<tr>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/java/java-arraylist-retainall.html">retainAll()</a></td>
<td align="left">保留 arraylist 中在指定集合中也存在的那些元素</td>
</tr>
<tr>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/java/java-arraylist-containsall.html">containsAll()</a></td>
<td align="left">查看 arraylist 是否包含指定集合中的所有元素</td>
</tr>
<tr>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/java/java-arraylist-trimtosize.html">trimToSize()</a></td>
<td align="left">将 arraylist 中的容量调整为数组中的元素个数</td>
</tr>
<tr>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/java/java-arraylist-removerange.html">removeRange()</a></td>
<td align="left">删除 arraylist 中指定索引之间存在的元素</td>
</tr>
<tr>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/java/java-arraylist-replaceall.html">replaceAll()</a></td>
<td align="left">将给定的操作内容替换掉数组中每一个元素</td>
</tr>
<tr>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/java/java-arraylist-removeif.html">removeIf()</a></td>
<td align="left">删除所有满足特定条件的 arraylist 元素</td>
</tr>
<tr>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/java/java-arraylist-foreach.html">forEach()</a></td>
<td align="left">遍历 arraylist 中每一个元素并执行特定操作</td>
</tr>
</tbody></table>
<h1 id="Java-LinkedList"><a href="#Java-LinkedList" class="headerlink" title="Java LinkedList"></a>Java LinkedList</h1><p>链表（Linked list）是一种常见的基础数据结构，是一种线性表，但是并不会按线性的顺序存储数据，而是在每一个节点里存到下一个节点的地址。</p>
<p>链表可分为单向链表和双向链表。</p>
<p>一个单向链表包含两个值: 当前节点的值和一个指向下一个节点的链接。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://www.runoob.com/wp-content/uploads/2020/06/408px-Singly-linked-list.svg_.png" alt="img"></p>
<p>一个双向链表有三个整数值: 数值、向后的节点链接、向前的节点链接。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://www.runoob.com/wp-content/uploads/2020/06/610px-Doubly-linked-list.svg_.png" alt="img"></p>
<p>Java LinkedList（链表） 类似于 ArrayList，是一种常用的数据容器。</p>
<p>与 ArrayList 相比，LinkedList 的增加和删除的操作效率更高，而查找和修改的操作效率较低。</p>
<p><strong>以下情况使用 ArrayList :</strong></p>
<ul>
<li>频繁访问列表中的某一个元素。</li>
<li>只需要在列表末尾进行添加和删除元素操作。</li>
</ul>
<p><strong>以下情况使用 LinkedList :</strong></p>
<ul>
<li>你需要通过循环迭代来访问列表中的某些元素。</li>
<li>需要频繁的在列表开头、中间、末尾等位置进行添加和删除元素操作。</li>
</ul>
<p>LinkedList 继承了 AbstractSequentialList 类。</p>
<p>LinkedList 实现了 Queue 接口，可作为队列使用。</p>
<p>LinkedList 实现了 List 接口，可进行列表的相关操作。</p>
<p>LinkedList 实现了 Deque 接口，可作为队列使用。</p>
<p>LinkedList 实现了 Cloneable 接口，可实现克隆。</p>
<p>LinkedList 实现了 java.io.Serializable 接口，即可支持序列化，能通过序列化去传输。</p>
<h3 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h3><table>
<thead>
<tr>
<th align="left">方法</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">public boolean add(E e)</td>
<td align="left">链表末尾添加元素，返回是否成功，成功为 true，失败为 false。</td>
</tr>
<tr>
<td align="left">public void add(int index, E element)</td>
<td align="left">向指定位置插入元素。</td>
</tr>
<tr>
<td align="left">public boolean addAll(Collection c)</td>
<td align="left">将一个集合的所有元素添加到链表后面，返回是否成功，成功为 true，失败为 false。</td>
</tr>
<tr>
<td align="left">public boolean addAll(int index, Collection c)</td>
<td align="left">将一个集合的所有元素添加到链表的指定位置后面，返回是否成功，成功为 true，失败为 false。</td>
</tr>
<tr>
<td align="left">public void addFirst(E e)</td>
<td align="left">元素添加到头部。</td>
</tr>
<tr>
<td align="left">public void addLast(E e)</td>
<td align="left">元素添加到尾部。</td>
</tr>
<tr>
<td align="left">public boolean offer(E e)</td>
<td align="left">向链表末尾添加元素，返回是否成功，成功为 true，失败为 false。</td>
</tr>
<tr>
<td align="left">public boolean offerFirst(E e)</td>
<td align="left">头部插入元素，返回是否成功，成功为 true，失败为 false。</td>
</tr>
<tr>
<td align="left">public boolean offerLast(E e)</td>
<td align="left">尾部插入元素，返回是否成功，成功为 true，失败为 false。</td>
</tr>
<tr>
<td align="left">public void clear()</td>
<td align="left">清空链表。</td>
</tr>
<tr>
<td align="left">public E removeFirst()</td>
<td align="left">删除并返回第一个元素。</td>
</tr>
<tr>
<td align="left">public E removeLast()</td>
<td align="left">删除并返回最后一个元素。</td>
</tr>
<tr>
<td align="left">public boolean remove(Object o)</td>
<td align="left">删除某一元素，返回是否成功，成功为 true，失败为 false。</td>
</tr>
<tr>
<td align="left">public E remove(int index)</td>
<td align="left">删除指定位置的元素。</td>
</tr>
<tr>
<td align="left">public E poll()</td>
<td align="left">删除并返回第一个元素。</td>
</tr>
<tr>
<td align="left">public E remove()</td>
<td align="left">删除并返回第一个元素。</td>
</tr>
<tr>
<td align="left">public boolean contains(Object o)</td>
<td align="left">判断是否含有某一元素。</td>
</tr>
<tr>
<td align="left">public E get(int index)</td>
<td align="left">返回指定位置的元素。</td>
</tr>
<tr>
<td align="left">public E getFirst()</td>
<td align="left">返回第一个元素。</td>
</tr>
<tr>
<td align="left">public E getLast()</td>
<td align="left">返回最后一个元素。</td>
</tr>
<tr>
<td align="left">public int indexOf(Object o)</td>
<td align="left">查找指定元素从前往后第一次出现的索引。</td>
</tr>
<tr>
<td align="left">public int lastIndexOf(Object o)</td>
<td align="left">查找指定元素最后一次出现的索引。</td>
</tr>
<tr>
<td align="left">public E peek()</td>
<td align="left">返回第一个元素。</td>
</tr>
<tr>
<td align="left">public E element()</td>
<td align="left">返回第一个元素。</td>
</tr>
<tr>
<td align="left">public E peekFirst()</td>
<td align="left">返回头部元素。</td>
</tr>
<tr>
<td align="left">public E peekLast()</td>
<td align="left">返回尾部元素。</td>
</tr>
<tr>
<td align="left">public E set(int index, E element)</td>
<td align="left">设置指定位置的元素。</td>
</tr>
<tr>
<td align="left">public Object clone()</td>
<td align="left">克隆该列表。</td>
</tr>
<tr>
<td align="left">public Iterator descendingIterator()</td>
<td align="left">返回倒序迭代器。</td>
</tr>
<tr>
<td align="left">public int size()</td>
<td align="left">返回链表元素个数。</td>
</tr>
<tr>
<td align="left">public ListIterator listIterator(int index)</td>
<td align="left">返回从指定位置开始到末尾的迭代器。</td>
</tr>
<tr>
<td align="left">public Object[] toArray()</td>
<td align="left">返回一个由链表元素组成的数组。</td>
</tr>
<tr>
<td align="left">public T[] toArray(T[] a)</td>
<td align="left">返回一个由链表元素转换类型而成的数组</td>
</tr>
</tbody></table>
<h1 id="Java-HashSet"><a href="#Java-HashSet" class="headerlink" title="Java HashSet"></a>Java HashSet</h1><p>HashSet 基于 HashMap 来实现的，是一个不允许有重复元素的集合。</p>
<p>HashSet 允许有 null 值。</p>
<p>HashSet 是无序的，即不会记录插入的顺序。</p>
<p>HashSet 不是线程安全的， 如果多个线程尝试同时修改 HashSet，则最终结果是不确定的。 您必须在多线程访问时显式同步对 HashSet 的并发访问。</p>
<p>HashSet 实现了 Set 接口。</p>
<h1 id="Java-HashMap"><a href="#Java-HashMap" class="headerlink" title="Java HashMap"></a>Java HashMap</h1><p>HashMap 是一个散列表，它存储的内容是键值对(key-value)映射。</p>
<p>HashMap 实现了 Map 接口，根据键的 HashCode 值存储数据，具有很快的访问速度，最多允许一条记录的键为 null，不支持线程同步。</p>
<p>HashMap 是无序的，即不会记录插入的顺序。</p>
<p>HashMap 继承于AbstractMap，实现了 Map、Cloneable、java.io.Serializable 接口。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://www.runoob.com/wp-content/uploads/2020/07/WV9wXLl.png" alt="img"></p>
<h2 id="Java-HashMap-方法"><a href="#Java-HashMap-方法" class="headerlink" title="Java HashMap 方法"></a>Java HashMap 方法</h2><p>hashmap</p>
<p>Java HashMap 常用方法列表如下：</p>
<table>
<thead>
<tr>
<th align="left">方法</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/java/java-hashmap-clear.html">clear()</a></td>
<td align="left">删除 hashMap 中的所有键&#x2F;值对</td>
</tr>
<tr>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/java/java-hashmap-clone.html">clone()</a></td>
<td align="left">复制一份 hashMap</td>
</tr>
<tr>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/java/java-hashmap-isempty.html">isEmpty()</a></td>
<td align="left">判断 hashMap 是否为空</td>
</tr>
<tr>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/java/java-hashmap-size.html">size()</a></td>
<td align="left">计算 hashMap 中键&#x2F;值对的数量</td>
</tr>
<tr>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/java/java-hashmap-put.html">put()</a></td>
<td align="left">将键&#x2F;值对添加到 hashMap 中</td>
</tr>
<tr>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/java/java-hashmap-putall.html">putAll()</a></td>
<td align="left">将所有键&#x2F;值对添加到 hashMap 中</td>
</tr>
<tr>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/java/java-hashmap-putifabsent.html">putIfAbsent()</a></td>
<td align="left">如果 hashMap 中不存在指定的键，则将指定的键&#x2F;值对插入到 hashMap 中。</td>
</tr>
<tr>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/java/java-hashmap-remove.html">remove()</a></td>
<td align="left">删除 hashMap 中指定键 key 的映射关系</td>
</tr>
<tr>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/java/java-hashmap-containskey.html">containsKey()</a></td>
<td align="left">检查 hashMap 中是否存在指定的 key 对应的映射关系。</td>
</tr>
<tr>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/java/java-hashmap-containsvalue.html">containsValue()</a></td>
<td align="left">检查 hashMap 中是否存在指定的 value 对应的映射关系。</td>
</tr>
<tr>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/java/java-hashmap-replace.html">replace()</a></td>
<td align="left">替换 hashMap 中是指定的 key 对应的 value。</td>
</tr>
<tr>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/java/java-hashmap-replaceall.html">replaceAll()</a></td>
<td align="left">将 hashMap 中的所有映射关系替换成给定的函数所执行的结果。</td>
</tr>
<tr>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/java/java-hashmap-get.html">get()</a></td>
<td align="left">获取指定 key 对应对 value</td>
</tr>
<tr>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/java/java-hashmap-getordefault.html">getOrDefault()</a></td>
<td align="left">获取指定 key 对应对 value，如果找不到 key ，则返回设置的默认值</td>
</tr>
<tr>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/java/java-hashmap-foreach.html">forEach()</a></td>
<td align="left">对 hashMap 中的每个映射执行指定的操作。</td>
</tr>
<tr>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/java/java-hashmap-entryset.html">entrySet()</a></td>
<td align="left">返回 hashMap 中所有映射项的集合集合视图。</td>
</tr>
<tr>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/java/java-hashmap-keyset.html">keySet</a>()</td>
<td align="left">返回 hashMap 中所有 key 组成的集合视图。</td>
</tr>
<tr>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/java/java-hashmap-values.html">values()</a></td>
<td align="left">返回 hashMap 中存在的所有 value 值。</td>
</tr>
<tr>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/java/java-hashmap-merge.html">merge()</a></td>
<td align="left">添加键值对到 hashMap 中</td>
</tr>
<tr>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/java/java-hashmap-compute.html">compute()</a></td>
<td align="left">对 hashMap 中指定 key 的值进行重新计算</td>
</tr>
<tr>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/java/java-hashmap-computeifabsent.html">computeIfAbsent()</a></td>
<td align="left">对 hashMap 中指定 key 的值进行重新计算，如果不存在这个 key，则添加到 hasMap 中</td>
</tr>
<tr>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/java/java-hashmap-computeifpresent.html">computeIfPresent()</a></td>
<td align="left">对 hashMap 中指定 key 的值进行重新计算，前提是该 key 存在于 hashMap 中。</td>
</tr>
</tbody></table>
<h1 id="Java-Iterator（迭代器）"><a href="#Java-Iterator（迭代器）" class="headerlink" title="Java Iterator（迭代器）"></a>Java Iterator（迭代器）</h1><p>Java迭代器（Iterator）是 Java 集合框架中的一种机制，是一种用于遍历集合（如列表、集合和映射等）的接口。</p>
<p>它提供了一种统一的方式来访问集合中的元素，而不需要了解底层集合的具体实现细节。</p>
<p>Java Iterator（迭代器）不是一个集合，它是一种用于访问集合的方法，可用于迭代 <a target="_blank" rel="noopener" href="https://www.runoob.com/java/java-arraylist.html">ArrayList</a> 和 <a target="_blank" rel="noopener" href="https://www.runoob.com/java/java-hashset.html">HashSet</a> 等集合。</p>
<p>Iterator 是 Java 迭代器最简单的实现，ListIterator 是 Collection API 中的接口， 它扩展了 Iterator 接口。</p>
<p>迭代器接口定义了几个方法，最常用的是以下三个：</p>
<ul>
<li><strong>next()</strong> - 返回迭代器的下一个元素，并将迭代器的指针移到下一个位置。</li>
<li><strong>hasNext()</strong> - 用于判断集合中是否还有下一个元素可以访问。</li>
<li><strong>remove()</strong> - 从集合中删除迭代器最后访问的元素（可选操作）。</li>
</ul>
<h3 id="获取一个迭代器"><a href="#获取一个迭代器" class="headerlink" title="获取一个迭代器"></a>获取一个迭代器</h3><p>集合想获取一个迭代器可以使用 iterator() 方法:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 引入 ArrayList 和 Iterator 类</span></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RunoobTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建集合</span></span><br><span class="line">        ArrayList&lt;String&gt; sites = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();</span><br><span class="line">        sites.add(<span class="string">&quot;Google&quot;</span>);</span><br><span class="line">        sites.add(<span class="string">&quot;Runoob&quot;</span>);</span><br><span class="line">        sites.add(<span class="string">&quot;Taobao&quot;</span>);</span><br><span class="line">        sites.add(<span class="string">&quot;Zhihu&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取迭代器</span></span><br><span class="line">        Iterator&lt;String&gt; it = sites.iterator();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 输出集合中的第一个元素</span></span><br><span class="line">        System.out.println(it.next());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 引入 ArrayList 和 Iterator 类</span></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RunoobTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建集合</span></span><br><span class="line">        ArrayList&lt;String&gt; sites = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();</span><br><span class="line">        sites.add(<span class="string">&quot;Google&quot;</span>);</span><br><span class="line">        sites.add(<span class="string">&quot;Runoob&quot;</span>);</span><br><span class="line">        sites.add(<span class="string">&quot;Taobao&quot;</span>);</span><br><span class="line">        sites.add(<span class="string">&quot;Zhihu&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取迭代器</span></span><br><span class="line">        Iterator&lt;String&gt; it = sites.iterator();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 输出集合中的所有元素</span></span><br><span class="line">        <span class="keyword">while</span>(it.hasNext()) &#123;</span><br><span class="line">            System.out.println(it.next());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Java-Object-类"><a href="#Java-Object-类" class="headerlink" title="Java Object 类"></a>Java Object 类</h1><p>Java Object 类是所有类的父类，也就是说 Java 的所有类都继承了 Object，<strong>子类可以使用 Object 的所有方法</strong>。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://www.runoob.com/wp-content/uploads/2020/10/classes-object.gif" alt="img"></p>
<p>Object 类位于 java.lang 包中，编译时会自动导入，我们创建一个类时，如果没有明确继承一个父类，那么它就会自动继承 Object，成为 Object 的子类。</p>
<p>Object 类可以显式继承，也可以隐式继承，以下两种方式是一样的：</p>
<p>显式继承:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class Runoob extends Object&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>隐式继承:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class Runoob &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="类的构造函数"><a href="#类的构造函数" class="headerlink" title="类的构造函数"></a>类的构造函数</h3><table>
<thead>
<tr>
<th align="left">序号</th>
<th align="center">构造方法 &amp; 描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">1</td>
<td align="center">**Object()**构造一个新对象。</td>
</tr>
</tbody></table>
<h3 id="类的方法"><a href="#类的方法" class="headerlink" title="类的方法"></a>类的方法</h3><table>
<thead>
<tr>
<th align="left">序号</th>
<th align="left">方法 &amp; 描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">1</td>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/java/java-object-clone.html">protected Object clone()</a>创建并返回一个对象的拷贝</td>
</tr>
<tr>
<td align="left">2</td>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/java/java-object-equals.html">boolean equals(Object obj)</a>比较两个对象是否相等</td>
</tr>
<tr>
<td align="left">3</td>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/java/java-object-finalize.html">protected void finalize()</a>当 GC (垃圾回收器)确定不存在对该对象的有更多引用时，由对象的垃圾回收器调用此方法。</td>
</tr>
<tr>
<td align="left">4</td>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/java/java-object-getclass.html">Class getClass()</a>获取对象的运行时对象的类</td>
</tr>
<tr>
<td align="left">5</td>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/java/java-object-hashcode.html">int hashCode()</a>获取对象的 hash 值</td>
</tr>
<tr>
<td align="left">6</td>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/java/java-object-notify.html">void notify()</a>唤醒在该对象上等待的某个线程</td>
</tr>
<tr>
<td align="left">7</td>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/java/java-object-notifyall.html">void notifyAll()</a>唤醒在该对象上等待的所有线程</td>
</tr>
<tr>
<td align="left">8</td>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/java/java-object-tostring.html">String toString()</a>返回对象的字符串表示形式</td>
</tr>
<tr>
<td align="left">9</td>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/java/java-object-wait.html">void wait()</a>让当前线程进入等待状态。直到其他线程调用此对象的 notify() 方法或 notifyAll() 方法。</td>
</tr>
<tr>
<td align="left">10</td>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/java/java-object-wait-timeout.html">void wait(long timeout)</a>让当前线程处于等待(阻塞)状态，直到其他线程调用此对象的 notify() 方法或 notifyAll() 方法，或者超过参数设置的timeout超时时间。</td>
</tr>
<tr>
<td align="left">11</td>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/java/java-object-wait-nanos.html">void wait(long timeout, int nanos)</a>与 wait(long timeout) 方法类似，多了一个 nanos 参数，这个参数表示额外时间（以纳秒为单位，范围是 0-999999）。 所以超时的时间还需要加上 nanos 纳秒。。</td>
</tr>
</tbody></table>
<h1 id="Java-泛型"><a href="#Java-泛型" class="headerlink" title="Java 泛型"></a>Java 泛型</h1><p>Java 泛型（generics）是 JDK 5 中引入的一个新特性, 泛型提供了编译时类型安全检测机制，该机制允许程序员在编译时检测到非法的类型。</p>
<p>泛型的本质是参数化类型，也就是说所操作的数据类型被指定为一个参数。</p>
<blockquote>
<p>假定我们有这样一个需求：写一个排序方法，能够对整型数组、字符串数组甚至其他任何类型的数组进行排序，该如何实现？</p>
<p>答案是可以使用 <strong>Java 泛型</strong>。</p>
<p>使用 Java 泛型的概念，我们可以写一个泛型方法来对一个对象数组排序。然后，调用该泛型方法来对整型数组、浮点数数组、字符串数组等进行排序。</p>
</blockquote>
<h2 id="泛型方法"><a href="#泛型方法" class="headerlink" title="泛型方法"></a>泛型方法</h2><p>你可以写一个泛型方法，该方法在调用时可以接收不同类型的参数。根据传递给泛型方法的参数类型，编译器适当地处理每一个方法调用。</p>
<p>下面是定义泛型方法的规则：</p>
<ul>
<li>所有泛型方法声明都有一个类型参数声明部分（由尖括号分隔），该类型参数声明部分在方法返回类型之前（在下面例子中的 **<E>**）。</li>
<li>每一个类型参数声明部分包含一个或多个类型参数，参数间用逗号隔开。一个泛型参数，也被称为一个类型变量，是用于指定一个泛型类型名称的标识符。</li>
<li>类型参数能被用来声明返回值类型，并且能作为泛型方法得到的实际参数类型的占位符。</li>
<li>泛型方法体的声明和其他方法一样。注意类型参数只能代表引用型类型，不能是原始类型（像 <strong>int、double、char</strong> 等）。</li>
</ul>
<p><strong>java 中泛型标记符：</strong></p>
<ul>
<li><strong>E</strong> - Element (在集合中使用，因为集合中存放的是元素)</li>
<li><strong>T</strong> - Type（Java 类）</li>
<li><strong>K</strong> - Key（键）</li>
<li><strong>V</strong> - Value（值）</li>
<li><strong>N</strong> - Number（数值类型）</li>
<li><strong>？</strong> - 表示不确定的 java 类型</li>
</ul>
<p>下面的例子演示了如何使用泛型方法打印不同类型的数组元素：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GenericMethodTest</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="comment">// 泛型方法 printArray                         </span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> &lt; E &gt; <span class="keyword">void</span> <span class="title function_">printArray</span><span class="params">( E[] inputArray )</span></span><br><span class="line">   &#123;</span><br><span class="line">      <span class="comment">// 输出数组元素            </span></span><br><span class="line">         <span class="keyword">for</span> ( E element : inputArray )&#123;        </span><br><span class="line">            System.out.printf( <span class="string">&quot;%s &quot;</span>, element );</span><br><span class="line">         &#125;</span><br><span class="line">         System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">( String args[] )</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 创建不同类型数组： Integer, Double 和 Character</span></span><br><span class="line">        Integer[] intArray = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span> &#125;;</span><br><span class="line">        Double[] doubleArray = &#123; <span class="number">1.1</span>, <span class="number">2.2</span>, <span class="number">3.3</span>, <span class="number">4.4</span> &#125;;</span><br><span class="line">        Character[] charArray = &#123; <span class="string">&#x27;H&#x27;</span>, <span class="string">&#x27;E&#x27;</span>, <span class="string">&#x27;L&#x27;</span>, <span class="string">&#x27;L&#x27;</span>, <span class="string">&#x27;O&#x27;</span> &#125;;</span><br><span class="line"> </span><br><span class="line">        System.out.println( <span class="string">&quot;整型数组元素为:&quot;</span> );</span><br><span class="line">        printArray( intArray  ); <span class="comment">// 传递一个整型数组</span></span><br><span class="line"> </span><br><span class="line">        System.out.println( <span class="string">&quot;\n双精度型数组元素为:&quot;</span> );</span><br><span class="line">        printArray( doubleArray ); <span class="comment">// 传递一个双精度型数组</span></span><br><span class="line"> </span><br><span class="line">        System.out.println( <span class="string">&quot;\n字符型数组元素为:&quot;</span> );</span><br><span class="line">        printArray( charArray ); <span class="comment">// 传递一个字符型数组</span></span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="泛型类"><a href="#泛型类" class="headerlink" title="泛型类"></a>泛型类</h2><p>泛型类的声明和非泛型类的声明类似，除了在类名后面添加了类型参数声明部分。</p>
<p>和泛型方法一样，泛型类的类型参数声明部分也包含一个或多个类型参数，参数间用逗号隔开。一个泛型参数，也被称为一个类型变量，是用于指定一个泛型类型名称的标识符。因为他们接受一个或多个参数，这些类被称为参数化的类或参数化的类型。</p>
<h3 id="实例-7"><a href="#实例-7" class="headerlink" title="实例"></a>实例</h3><p>如下实例演示了我们如何定义一个泛型类:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Box</span>&lt;T&gt; &#123;</span><br><span class="line">   </span><br><span class="line">  <span class="keyword">private</span> T t;</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(T t)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.t = t;</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">public</span> T <span class="title function_">get</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> t;</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    Box&lt;Integer&gt; integerBox = <span class="keyword">new</span> <span class="title class_">Box</span>&lt;Integer&gt;();</span><br><span class="line">    Box&lt;String&gt; stringBox = <span class="keyword">new</span> <span class="title class_">Box</span>&lt;String&gt;();</span><br><span class="line"> </span><br><span class="line">    integerBox.add(<span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">10</span>));</span><br><span class="line">    stringBox.add(<span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;菜鸟教程&quot;</span>));</span><br><span class="line"> </span><br><span class="line">    System.out.printf(<span class="string">&quot;整型值为 :%d\n\n&quot;</span>, integerBox.get());</span><br><span class="line">    System.out.printf(<span class="string">&quot;字符串为 :%s\n&quot;</span>, stringBox.get());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="类型通配符"><a href="#类型通配符" class="headerlink" title="类型通配符"></a>类型通配符</h2><p>1、类型通配符一般是使用 <strong>?</strong> 代替具体的类型参数。例如 <strong>List&lt;?&gt;</strong> 在逻辑上是 <strong>List<String>,List<Integer></strong> 等所有 <strong>List&lt;具体类型实参&gt;</strong> 的父类。</p>
<p>2、类型通配符上限通过形如List来定义，如此定义就是通配符泛型值接受Number及其下层子类类型。</p>
<p>3、类型通配符下限通过形如 <strong>List&lt;? super Number&gt;</strong> 来定义，表示类型只能接受 <strong>Number</strong> 及其上层父类类型，如 <strong>Object</strong> 类型的实例。</p>
<h1 id="Java-序列化"><a href="#Java-序列化" class="headerlink" title="Java 序列化"></a>Java 序列化</h1><p>Java 序列化是一种将对象转换为字节流的过程，以便可以将对象保存到磁盘上，将其传输到网络上，或者将其存储在内存中，以后再进行反序列化，将字节流重新转换为对象。</p>
<p>序列化在 Java 中是通过 <strong>java.io.Serializable</strong> 接口来实现的，该接口没有任何方法，只是一个标记接口，用于标识类可以被序列化。</p>
<p>当你序列化对象时，你把它包装成一个特殊文件，可以保存、传输或存储。反序列化则是打开这个文件，读取序列化的数据，然后将其还原为对象，以便在程序中使用。</p>
<p>序列化是一种用于保存、传输和还原对象的方法，它使得对象可以在不同的计算机之间移动和共享，这对于分布式系统、数据存储和跨平台通信非常有用。</p>
<p>以下是 Java 序列化的基本概念和用法：</p>
<p>实现 Serializable 接口： 要使一个类可序列化，需要让该类实现 java.io.Serializable 接口，这告诉 Java 编译器这个类可以被序列化，例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.Serializable;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyClass</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line">    <span class="comment">// 类的成员和方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Java-网络编程"><a href="#Java-网络编程" class="headerlink" title="Java 网络编程"></a>Java 网络编程</h1><p>网络编程是指编写运行在多个设备（计算机）的程序，这些设备都通过网络连接起来。</p>
<p>java.net 包中 J2SE 的 API 包含有类和接口，它们提供低层次的通信细节。你可以直接使用这些类和接口，来专注于解决问题，而不用关注通信细节。</p>
<p>java.net 包中提供了两种常见的网络协议的支持：</p>
<ul>
<li><strong>TCP</strong>：TCP（英语：Transmission Control Protocol，传输控制协议） 是一种面向连接的、可靠的、基于字节流的传输层通信协议，TCP 层是位于 IP 层之上，应用层之下的中间层。TCP 保障了两个应用程序之间的可靠通信。通常用于互联网协议，被称 TCP &#x2F; IP。</li>
<li><strong>UDP</strong>：UDP （英语：User Datagram Protocol，用户数据报协议），位于 OSI 模型的传输层。一个无连接的协议。提供了应用程序之间要发送数据的数据报。由于UDP缺乏可靠性且属于无连接协议，所以应用程序通常必须容许一些丢失、错误或重复的数据包。</li>
</ul>
<p>本教程主要讲解以下两个主题。</p>
<ul>
<li><strong>Socket 编程</strong>：这是使用最广泛的网络概念，它已被解释地非常详细。</li>
<li><strong>URL 处理</strong>：这部分会在另外的篇幅里讲，点击这里更详细地了解在 <a target="_blank" rel="noopener" href="https://www.runoob.com/java/java-url-processing.html">Java 语言中的 URL 处理</a>。</li>
</ul>
<h2 id="Socket-编程"><a href="#Socket-编程" class="headerlink" title="Socket 编程"></a>Socket 编程</h2><p>套接字使用TCP提供了两台计算机之间的通信机制。 客户端程序创建一个套接字，并尝试连接服务器的套接字。</p>
<p>当连接建立时，服务器会创建一个 Socket 对象。客户端和服务器现在可以通过对 Socket 对象的写入和读取来进行通信。</p>
<p>java.net.Socket 类代表一个套接字，并且 java.net.ServerSocket 类为服务器程序提供了一种来监听客户端，并与他们建立连接的机制。</p>
<p>以下步骤在两台计算机之间使用套接字建立TCP连接时会出现：</p>
<ul>
<li>服务器实例化一个 ServerSocket 对象，表示通过服务器上的端口通信。</li>
<li>服务器调用 ServerSocket 类的 accept() 方法，该方法将一直等待，直到客户端连接到服务器上给定的端口。</li>
<li>服务器正在等待时，一个客户端实例化一个 Socket 对象，指定服务器名称和端口号来请求连接。</li>
<li>Socket 类的构造函数试图将客户端连接到指定的服务器和端口号。如果通信被建立，则在客户端创建一个 Socket 对象能够与服务器进行通信。</li>
<li>在服务器端，accept() 方法返回服务器上一个新的 socket 引用，该 socket 连接到客户端的 socket。</li>
</ul>
<p>连接建立后，通过使用 I&#x2F;O 流在进行通信，每一个socket都有一个输出流和一个输入流，客户端的输出流连接到服务器端的输入流，而客户端的输入流连接到服务器端的输出流。</p>
<p>TCP 是一个双向的通信协议，因此数据可以通过两个数据流在同一时间发送。以下是一些类提供的一套完整的有用的方法来实现 socket。</p>
<h2 id="Socket-类的方法"><a href="#Socket-类的方法" class="headerlink" title="Socket 类的方法"></a>Socket 类的方法</h2><p>java.net.Socket 类代表客户端和服务器都用来互相沟通的套接字。客户端要获取一个 Socket 对象通过实例化 ，而 服务器获得一个 Socket 对象则通过 accept() 方法的返回值。</p>
<p>Socket 类有五个构造方法.</p>
<table>
<thead>
<tr>
<th><strong>序号</strong></th>
<th><strong>方法描述</strong></th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td><strong>public Socket(String host, int port) throws UnknownHostException, IOException.</strong> 创建一个流套接字并将其连接到指定主机上的指定端口号。</td>
</tr>
<tr>
<td>2</td>
<td><strong>public Socket(InetAddress host, int port) throws IOException</strong> 创建一个流套接字并将其连接到指定 IP 地址的指定端口号。</td>
</tr>
<tr>
<td>3</td>
<td><strong>public Socket(String host, int port, InetAddress localAddress, int localPort) throws IOException.</strong> 创建一个套接字并将其连接到指定远程主机上的指定远程端口。</td>
</tr>
<tr>
<td>4</td>
<td><strong>public Socket(InetAddress host, int port, InetAddress localAddress, int localPort) throws IOException.</strong> 创建一个套接字并将其连接到指定远程地址上的指定远程端口。</td>
</tr>
<tr>
<td>5</td>
<td><strong>public Socket()</strong> 通过系统默认类型的 SocketImpl 创建未连接套接字</td>
</tr>
</tbody></table>
<h2 id="Socket-客户端实例"><a href="#Socket-客户端实例" class="headerlink" title="Socket 客户端实例"></a>Socket 客户端实例</h2><p>如下的 GreetingClient 是一个客户端程序，该程序通过 socket 连接到服务器并发送一个请求，然后等待一个响应。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 文件名 GreetingClient.java</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> java.net.*;</span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GreetingClient</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String [] args)</span></span><br><span class="line">   &#123;</span><br><span class="line">      <span class="type">String</span> <span class="variable">serverName</span> <span class="operator">=</span> args[<span class="number">0</span>];</span><br><span class="line">      <span class="type">int</span> <span class="variable">port</span> <span class="operator">=</span> Integer.parseInt(args[<span class="number">1</span>]);</span><br><span class="line">      <span class="keyword">try</span></span><br><span class="line">      &#123;</span><br><span class="line">         System.out.println(<span class="string">&quot;连接到主机：&quot;</span> + serverName + <span class="string">&quot; ，端口号：&quot;</span> + port);</span><br><span class="line">         <span class="type">Socket</span> <span class="variable">client</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Socket</span>(serverName, port);</span><br><span class="line">         System.out.println(<span class="string">&quot;远程主机地址：&quot;</span> + client.getRemoteSocketAddress());</span><br><span class="line">         <span class="type">OutputStream</span> <span class="variable">outToServer</span> <span class="operator">=</span> client.getOutputStream();</span><br><span class="line">         <span class="type">DataOutputStream</span> <span class="variable">out</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DataOutputStream</span>(outToServer);</span><br><span class="line"> </span><br><span class="line">         out.writeUTF(<span class="string">&quot;Hello from &quot;</span> + client.getLocalSocketAddress());</span><br><span class="line">         <span class="type">InputStream</span> <span class="variable">inFromServer</span> <span class="operator">=</span> client.getInputStream();</span><br><span class="line">         <span class="type">DataInputStream</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DataInputStream</span>(inFromServer);</span><br><span class="line">         System.out.println(<span class="string">&quot;服务器响应： &quot;</span> + in.readUTF());</span><br><span class="line">         client.close();</span><br><span class="line">      &#125;<span class="keyword">catch</span>(IOException e)</span><br><span class="line">      &#123;</span><br><span class="line">         e.printStackTrace();</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Socket-服务端实例"><a href="#Socket-服务端实例" class="headerlink" title="Socket 服务端实例"></a>Socket 服务端实例</h2><p>如下的GreetingServer 程序是一个服务器端应用程序，使用 Socket 来监听一个指定的端口。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 文件名 GreetingServer.java</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> java.net.*;</span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GreetingServer</span> <span class="keyword">extends</span> <span class="title class_">Thread</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="keyword">private</span> ServerSocket serverSocket;</span><br><span class="line">   </span><br><span class="line">   <span class="keyword">public</span> <span class="title function_">GreetingServer</span><span class="params">(<span class="type">int</span> port)</span> <span class="keyword">throws</span> IOException</span><br><span class="line">   &#123;</span><br><span class="line">      serverSocket = <span class="keyword">new</span> <span class="title class_">ServerSocket</span>(port);</span><br><span class="line">      serverSocket.setSoTimeout(<span class="number">10000</span>);</span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span></span><br><span class="line">   &#123;</span><br><span class="line">      <span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">      &#123;</span><br><span class="line">         <span class="keyword">try</span></span><br><span class="line">         &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;等待远程连接，端口号为：&quot;</span> + serverSocket.getLocalPort() + <span class="string">&quot;...&quot;</span>);</span><br><span class="line">            <span class="type">Socket</span> <span class="variable">server</span> <span class="operator">=</span> serverSocket.accept();</span><br><span class="line">            System.out.println(<span class="string">&quot;远程主机地址：&quot;</span> + server.getRemoteSocketAddress());</span><br><span class="line">            <span class="type">DataInputStream</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DataInputStream</span>(server.getInputStream());</span><br><span class="line">            System.out.println(in.readUTF());</span><br><span class="line">            <span class="type">DataOutputStream</span> <span class="variable">out</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DataOutputStream</span>(server.getOutputStream());</span><br><span class="line">            out.writeUTF(<span class="string">&quot;谢谢连接我：&quot;</span> + server.getLocalSocketAddress() + <span class="string">&quot;\nGoodbye!&quot;</span>);</span><br><span class="line">            server.close();</span><br><span class="line">         &#125;<span class="keyword">catch</span>(SocketTimeoutException s)</span><br><span class="line">         &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Socket timed out!&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">         &#125;<span class="keyword">catch</span>(IOException e)</span><br><span class="line">         &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String [] args)</span></span><br><span class="line">   &#123;</span><br><span class="line">      <span class="type">int</span> <span class="variable">port</span> <span class="operator">=</span> Integer.parseInt(args[<span class="number">0</span>]);</span><br><span class="line">      <span class="keyword">try</span></span><br><span class="line">      &#123;</span><br><span class="line">         <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GreetingServer</span>(port);</span><br><span class="line">         t.run();</span><br><span class="line">      &#125;<span class="keyword">catch</span>(IOException e)</span><br><span class="line">      &#123;</span><br><span class="line">         e.printStackTrace();</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Java-多线程编程"><a href="#Java-多线程编程" class="headerlink" title="Java 多线程编程"></a>Java 多线程编程</h1><p>Java 给多线程编程提供了内置的支持。 一条线程指的是进程中一个单一顺序的控制流，一个进程中可以并发多个线程，每条线程并行执行不同的任务。</p>
<p>多线程是多任务的一种特别的形式，但多线程使用了更小的资源开销。</p>
<p>这里定义和线程相关的另一个术语 - 进程：一个进程包括由操作系统分配的内存空间，包含一个或多个线程。一个线程不能独立的存在，它必须是进程的一部分。一个进程一直运行，直到所有的非守护线程都结束运行后才能结束。</p>
<p>多线程能满足程序员编写高效率的程序来达到充分利用 CPU 的目的。</p>
<hr>
<h2 id="一个线程的生命周期"><a href="#一个线程的生命周期" class="headerlink" title="一个线程的生命周期"></a>一个线程的生命周期</h2><p>线程是一个动态执行的过程，它也有一个从产生到死亡的过程。</p>
<p>下图显示了一个线程完整的生命周期。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://www.runoob.com/wp-content/uploads/2014/01/java-thread.jpg" alt="img"></p>
<ul>
<li><p>新建状态:</p>
<p>使用 <strong>new</strong> 关键字和 <strong>Thread</strong> 类或其子类建立一个线程对象后，该线程对象就处于新建状态。它保持这个状态直到程序 <strong>start()</strong> 这个线程。</p>
</li>
<li><p>就绪状态:</p>
<p>当线程对象调用了start()方法之后，该线程就进入就绪状态。就绪状态的线程处于就绪队列中，要等待JVM里线程调度器的调度。</p>
</li>
<li><p>运行状态:</p>
<p>如果就绪状态的线程获取 CPU 资源，就可以执行 **run()**，此时线程便处于运行状态。处于运行状态的线程最为复杂，它可以变为阻塞状态、就绪状态和死亡状态。</p>
</li>
<li><p>阻塞状态:</p>
<p>如果一个线程执行了sleep（睡眠）、suspend（挂起）等方法，失去所占用资源之后，该线程就从运行状态进入阻塞状态。在睡眠时间已到或获得设备资源后可以重新进入就绪状态。可以分为三种：</p>
<ul>
<li>等待阻塞：运行状态中的线程执行 wait() 方法，使线程进入到等待阻塞状态。</li>
<li>同步阻塞：线程在获取 synchronized 同步锁失败(因为同步锁被其他线程占用)。</li>
<li>其他阻塞：通过调用线程的 sleep() 或 join() 发出了 I&#x2F;O 请求时，线程就会进入到阻塞状态。当sleep() 状态超时，join() 等待线程终止或超时，或者 I&#x2F;O 处理完毕，线程重新转入就绪状态。</li>
</ul>
</li>
<li><p>死亡状态:</p>
<p>一个运行状态的线程完成任务或者其他终止条件发生时，该线程就切换到终止状态。</p>
</li>
</ul>
<hr>
<h2 id="线程的优先级"><a href="#线程的优先级" class="headerlink" title="线程的优先级"></a>线程的优先级</h2><p>每一个 Java 线程都有一个优先级，这样有助于操作系统确定线程的调度顺序。</p>
<p>Java 线程的优先级是一个整数，其取值范围是 1 （Thread.MIN_PRIORITY ） - 10 （Thread.MAX_PRIORITY ）。</p>
<p>默认情况下，每一个线程都会分配一个优先级 NORM_PRIORITY（5）。</p>
<p>具有较高优先级的线程对程序更重要，并且应该在低优先级的线程之前分配处理器资源。但是，线程优先级不能保证线程执行的顺序，而且非常依赖于平台。</p>
<hr>
<h2 id="创建一个线程"><a href="#创建一个线程" class="headerlink" title="创建一个线程"></a>创建一个线程</h2><p>Java 提供了三种创建线程的方法：</p>
<ul>
<li>通过实现 Runnable 接口；</li>
<li>通过继承 Thread 类本身；</li>
<li>通过 Callable 和 Future 创建线程。</li>
</ul>
<h2 id="通过-Callable-和-Future-创建线程"><a href="#通过-Callable-和-Future-创建线程" class="headerlink" title="通过 Callable 和 Future 创建线程"></a>通过 Callable 和 Future 创建线程</h2><ul>
<li>\1. 创建 Callable 接口的实现类，并实现 call() 方法，该 call() 方法将作为线程执行体，并且有返回值。</li>
<li>\2. 创建 Callable 实现类的实例，使用 FutureTask 类来包装 Callable 对象，该 FutureTask 对象封装了该 Callable 对象的 call() 方法的返回值。</li>
<li>\3. 使用 FutureTask 对象作为 Thread 对象的 target 创建并启动新线程。</li>
<li>\4. 调用 FutureTask 对象的 get() 方法来获得子线程执行结束后的返回值。</li>
</ul>
<h2 id="创建线程的三种方式的对比"><a href="#创建线程的三种方式的对比" class="headerlink" title="创建线程的三种方式的对比"></a>创建线程的三种方式的对比</h2><ul>
<li>\1. 采用实现 Runnable、Callable 接口的方式创建多线程时，线程类只是实现了 Runnable 接口或 Callable 接口，还可以继承其他类。</li>
<li>\2. 使用继承 Thread 类的方式创建多线程时，编写简单，如果需要访问当前线程，则无需使用 Thread.currentThread() 方法，直接使用 this 即可获得当前线程。</li>
</ul>
<hr>
<h2 id="线程的几个主要概念"><a href="#线程的几个主要概念" class="headerlink" title="线程的几个主要概念"></a>线程的几个主要概念</h2><p>在多线程编程时，你需要了解以下几个概念：</p>
<ul>
<li>线程同步</li>
<li>线程间通信</li>
<li>线程死锁</li>
<li>线程控制：挂起、停止和恢复</li>
</ul>
<hr>
<h2 id="多线程的使用"><a href="#多线程的使用" class="headerlink" title="多线程的使用"></a>多线程的使用</h2><p>有效利用多线程的关键是理解程序是并发执行而不是串行执行的。例如：程序中有两个子系统需要并发执行，这时候就需要利用多线程编程。</p>
<p>通过对多线程的使用，可以编写出非常高效的程序。不过请注意，如果你创建太多的线程，程序执行的效率实际上是降低了，而不是提升了。</p>
<p>请记住，上下文的切换开销也很重要，如果你创建了太多的线程，CPU 花费在上下文的切换的时间将多于执行程序的时间！</p>
<h1 id="Java-文档注释"><a href="#Java-文档注释" class="headerlink" title="Java 文档注释"></a>Java 文档注释</h1><p>Java 支持三种注释方式。前两种分别是 <strong>&#x2F;&#x2F;</strong> 和 **&#x2F;* *&#x2F;*<em>，第三种被称作说明注释，它以 <strong>&#x2F;*</strong></em> 开始，以 ***&#x2F;**结束。</p>
<p>说明注释允许你在程序中嵌入关于程序的信息。你可以使用 javadoc 工具软件来生成信息，并输出到HTML文件中。</p>
<p>说明注释，使你更加方便的记录你的程序信息。</p>
<h2 id="javadoc-标签"><a href="#javadoc-标签" class="headerlink" title="javadoc 标签"></a>javadoc 标签</h2><p>javadoc 工具软件识别以下标签：</p>
<table>
<thead>
<tr>
<th align="left"><strong>标签</strong></th>
<th align="center"><strong>描述</strong></th>
<th align="center"><strong>示例</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="left">@author</td>
<td align="center">标识一个类的作者</td>
<td align="center">@author description</td>
</tr>
<tr>
<td align="left">@deprecated</td>
<td align="center">指名一个过期的类或成员</td>
<td align="center">@deprecated description</td>
</tr>
<tr>
<td align="left">{@docRoot}</td>
<td align="center">指明当前文档根目录的路径</td>
<td align="center">Directory Path</td>
</tr>
<tr>
<td align="left">@exception</td>
<td align="center">标志一个类抛出的异常</td>
<td align="center">@exception exception-name explanation</td>
</tr>
<tr>
<td align="left">{@inheritDoc}</td>
<td align="center">从直接父类继承的注释</td>
<td align="center">Inherits a comment from the immediate surperclass.</td>
</tr>
<tr>
<td align="left">{@link}</td>
<td align="center">插入一个到另一个主题的链接</td>
<td align="center">{@link name text}</td>
</tr>
<tr>
<td align="left">{@linkplain}</td>
<td align="center">插入一个到另一个主题的链接，但是该链接显示纯文本字体</td>
<td align="center">Inserts an in-line link to another topic.</td>
</tr>
<tr>
<td align="left">@param</td>
<td align="center">说明一个方法的参数</td>
<td align="center">@param parameter-name explanation</td>
</tr>
<tr>
<td align="left">@return</td>
<td align="center">说明返回值类型</td>
<td align="center">@return explanation</td>
</tr>
<tr>
<td align="left">@see</td>
<td align="center">指定一个到另一个主题的链接</td>
<td align="center">@see anchor</td>
</tr>
<tr>
<td align="left">@serial</td>
<td align="center">说明一个序列化属性</td>
<td align="center">@serial description</td>
</tr>
<tr>
<td align="left">@serialData</td>
<td align="center">说明通过writeObject( ) 和 writeExternal( )方法写的数据</td>
<td align="center">@serialData description</td>
</tr>
<tr>
<td align="left">@serialField</td>
<td align="center">说明一个ObjectStreamField组件</td>
<td align="center">@serialField name type description</td>
</tr>
<tr>
<td align="left">@since</td>
<td align="center">标记当引入一个特定的变化时</td>
<td align="center">@since release</td>
</tr>
<tr>
<td align="left">@throws</td>
<td align="center">和 @exception标签一样.</td>
<td align="center">The @throws tag has the same meaning as the @exception tag.</td>
</tr>
<tr>
<td align="left">{@value}</td>
<td align="center">显示常量的值，该常量必须是static属性。</td>
<td align="center">Displays the value of a constant, which must be a static field.</td>
</tr>
<tr>
<td align="left">@version</td>
<td align="center">指定类的版本</td>
<td align="center">@version info</td>
</tr>
</tbody></table>
</article><div class="post-copyright"><div class="copyright-cc-box"><i class="anzhiyufont anzhiyu-icon-copyright"></i></div><div class="post-copyright__author_box"><a class="post-copyright__author_img" href="/" title="头像"><img class="post-copyright__author_img_back" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://s2.loli.net/2022/11/07/QVWvrnAsuGxelbS.jpg" title="头像" alt="头像"><img class="post-copyright__author_img_front" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://s2.loli.net/2022/11/07/QVWvrnAsuGxelbS.jpg" title="头像" alt="头像"></a><div class="post-copyright__author_name">Wsk</div><div class="post-copyright__author_desc">Believe in yourself</div></div><div class="post-copyright__post__info"><a class="post-copyright__original" title="该文章为原创文章，注意版权协议" href="https://wsk0404.github.io/posts/8003e2d3.html">原创</a><a class="post-copyright-title"><span onclick="rm.copyPageUrl('https://wsk0404.github.io/posts/8003e2d3.html')">java教程</span></a></div><div class="post-tools" id="post-tools"><div class="post-tools-left"><div class="rewardLeftButton"><div class="post-reward" onclick="anzhiyu.addRewardMask()"><div class="reward-button button--animated" title="赞赏作者"><i class="anzhiyufont anzhiyu-icon-hand-heart-fill"></i>打赏作者</div><div class="reward-main"><div class="reward-all"><span class="reward-title">感谢你赐予我前进的力量</span><ul class="reward-group"><li class="reward-item"><a href="/./img/wechat.jpg" target="_blank"><img class="post-qr-code-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/./img/wechat.jpg" alt="微信"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="/./img/alipay.jpg" target="_blank"><img class="post-qr-code-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/./img/alipay.jpg" alt="支付宝"/></a><div class="post-qr-code-desc">支付宝</div></li></ul><a class="reward-main-btn" href="/about/#about-reward" target="_blank"><div class="reward-text">赞赏者名单</div><div class="reward-dec">因为你们的支持让我意识到写文章的价值🙏</div></a></div></div></div><div id="quit-box" onclick="anzhiyu.removeRewardMask()" style="display: none"></div><div class="reward-link mode"><a class="reward-link-button" href="/wecaht/"><i class="anzhiyufont anzhiyu-icon-plant-fill"></i>运营模式与责任</a></div></div><div class="shareRight"><div class="share-link mobile"><div class="share-qrcode"><div class="share-button" title="使用手机访问这篇文章"><i class="anzhiyufont anzhiyu-icon-qrcode"></i></div><div class="share-main"><div class="share-main-all"><div id="qrcode" title="https://wsk0404.github.io/posts/8003e2d3.html"></div><div class="reward-dec">使用手机访问这篇文章</div></div></div></div></div><div class="share-link weibo"><a class="share-button" target="_blank" href="https://service.weibo.com/share/share.php?title=java教程&amp;url=https://wsk0404.github.io/posts/8003e2d3.html&amp;pic=https://s2.loli.net/2025/10/23/wfbr2eNcL1VvXIn.png?_r_=204c01e8-b178-e5d6-c5d9-a8b8857b2e3a" rel="external nofollow noreferrer noopener"><i class="anzhiyufont anzhiyu-icon-weibo"></i></a></div><div class="share-link copyurl"><div class="share-button" id="post-share-url" title="复制链接" onclick="rm.copyPageUrl()"><i class="anzhiyufont anzhiyu-icon-link"></i></div></div></div></div></div><div class="post-copyright__notice"><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://wsk0404.github.io" target="_blank">Wsk Blog</a>！</span></div></div><div class="post-tools-right"><div class="tag_share"><div class="post-meta__box"><div class="post-meta__box__tag-list"><a class="post-meta__box__tags" href="/tags/java%E6%95%99%E7%A8%8B/"><span class="tags-punctuation"> <i class="anzhiyufont anzhiyu-icon-tag"></i></span>java教程<span class="tagsPageCount">1</span></a></div></div></div><div class="post_share"><div class="social-share" data-image="https://s2.loli.net/2025/10/23/w3ErpsQhncfDed2.jpg?_r_=7a487ade-a613-3f8f-d549-a793e3c2aa17" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.cbd.int/butterfly-extsrc@1.1.3/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"/><script src="https://cdn.cbd.int/butterfly-extsrc@1.1.3/sharejs/dist/js/social-share.min.js" defer="defer"></script></div></div><nav class="pagination-post" id="pagination"><div class="next-post pull-full"><a href="/posts/bc08a054.html"><img class="next-cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://s2.loli.net/2025/10/23/wfbr2eNcL1VvXIn.png?_r_=29c887af-4766-c428-ecf4-8ee349c780a8" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">心灵鸡汤</div></div></a></div></nav><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="anzhiyufont anzhiyu-icon-comments"></i><span> 评论</span></div><div class="comment-randomInfo"><a onclick="anzhiyu.addRandomCommentInfo()" href="javascript:void(0)">匿名评论</a><a href="/privacy" style="margin-left: 4px">隐私政策</a></div></div><div class="comment-wrap"><div><div class="vcomment" id="vcomment"></div></div></div></div><div class="comment-barrage"></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="card-content"><div class="author-info__sayhi" id="author-info__sayhi" onclick="anzhiyu.changeSayHelloText()"></div><div class="author-info-avatar"><img class="avatar-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://s2.loli.net/2022/11/07/QVWvrnAsuGxelbS.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/><div class="author-status"><img class="g-status" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/zc998800/cdn/face/gif/m17.gif" ait="status"/></div></div><div class="author-info__description">路慢其修远兮 吾将上下而求索</div><div class="author-info__bottom-group"><a class="author-info__bottom-group-left" href="/"><h1 class="author-info__name">Wsk</h1><div class="author-info__desc">Believe in yourself</div></a><div class="card-info-social-icons is-center"><a class="social-icon faa-parent animated-hover" href="https://github.com/gukeyang" target="_blank" title="Github"><i class="anzhiyufont anzhiyu-icon-github"></i></a><a class="social-icon faa-parent animated-hover" href="https://space.bilibili.com/1542898061" target="_blank" title="BiliBili"><i class="anzhiyufont anzhiyu-icon-bilibili"></i></a></div></div></div></div><div class="card-widget anzhiyu-right-widget" id="card-wechat" onclick="null"><div id="flip-wrapper"><div id="flip-content"><div class="face" style="background: url(https://bu.dusays.com/2023/01/13/63c02edf44033.png) center center / 100% no-repeat"></div><div class="back face" style="background: url(https://s2.loli.net/2023/10/19/vNio4QGBSX9x5lO.png) center center / 100% no-repeat"></div></div></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-bars"></i><span>文章目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Java%E6%95%99%E7%A8%8B"><span class="toc-number">1.</span> <span class="toc-text">Java教程</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Java-%E7%AE%80%E4%BB%8B"><span class="toc-number">1.1.</span> <span class="toc-text">Java 简介</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%BB%E8%A6%81%E7%89%B9%E6%80%A7"><span class="toc-number">1.2.</span> <span class="toc-text">主要特性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%91%E5%B1%95%E5%8E%86%E5%8F%B2-%E7%AE%80%E7%95%A5%E7%89%88"><span class="toc-number">1.3.</span> <span class="toc-text">发展历史(简略版)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Java-%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7"><span class="toc-number">1.4.</span> <span class="toc-text">Java 开发工具</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Java-%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE"><span class="toc-number">2.</span> <span class="toc-text">Java 开发环境配置</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#window%E7%B3%BB%E7%BB%9F%E5%AE%89%E8%A3%85java"><span class="toc-number">2.1.</span> <span class="toc-text">window系统安装java</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%8B%E8%BD%BDJDK"><span class="toc-number">2.1.1.</span> <span class="toc-text">下载JDK</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%85%8D%E7%BD%AE%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F"><span class="toc-number">2.1.2.</span> <span class="toc-text">配置环境变量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B5%8B%E8%AF%95JDK%E6%98%AF%E5%90%A6%E5%AE%89%E8%A3%85%E6%88%90%E5%8A%9F"><span class="toc-number">2.1.3.</span> <span class="toc-text">测试JDK是否安装成功</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B5%81%E8%A1%8C-Java-%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7"><span class="toc-number">2.2.</span> <span class="toc-text">流行 Java 开发工具</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Java-%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95"><span class="toc-number">3.</span> <span class="toc-text">Java 基础语法</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E4%B8%80%E4%B8%AAJava%E7%A8%8B%E5%BA%8F"><span class="toc-number">3.1.</span> <span class="toc-text">第一个Java程序</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95"><span class="toc-number">3.2.</span> <span class="toc-text">基本语法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Java-%E6%A0%87%E8%AF%86%E7%AC%A6"><span class="toc-number">3.3.</span> <span class="toc-text">Java 标识符</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Java%E4%BF%AE%E9%A5%B0%E7%AC%A6"><span class="toc-number">3.4.</span> <span class="toc-text">Java修饰符</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Java-%E5%8F%98%E9%87%8F"><span class="toc-number">3.5.</span> <span class="toc-text">Java 变量</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Java-%E6%95%B0%E7%BB%84"><span class="toc-number">3.6.</span> <span class="toc-text">Java 数组</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Java-%E6%9E%9A%E4%B8%BE"><span class="toc-number">3.7.</span> <span class="toc-text">Java 枚举</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Java-%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-number">3.8.</span> <span class="toc-text">Java 关键字</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Java%E6%B3%A8%E9%87%8A"><span class="toc-number">3.9.</span> <span class="toc-text">Java注释</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%A7%E6%89%BF"><span class="toc-number">3.10.</span> <span class="toc-text">继承</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8E%A5%E5%8F%A3"><span class="toc-number">3.11.</span> <span class="toc-text">接口</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Java-%E5%AF%B9%E8%B1%A1%E5%92%8C%E7%B1%BB"><span class="toc-number">4.</span> <span class="toc-text">Java 对象和类</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Java%E4%B8%AD%E7%9A%84%E5%AF%B9%E8%B1%A1"><span class="toc-number">4.1.</span> <span class="toc-text">Java中的对象</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Java-%E4%B8%AD%E7%9A%84%E7%B1%BB"><span class="toc-number">4.2.</span> <span class="toc-text">Java 中的类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95"><span class="toc-number">4.3.</span> <span class="toc-text">构造方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1"><span class="toc-number">4.4.</span> <span class="toc-text">创建对象</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AE%BF%E9%97%AE%E5%AE%9E%E4%BE%8B%E5%8F%98%E9%87%8F%E5%92%8C%E6%96%B9%E6%B3%95"><span class="toc-number">4.5.</span> <span class="toc-text">访问实例变量和方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9E%E4%BE%8B"><span class="toc-number">4.6.</span> <span class="toc-text">实例</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%BA%90%E6%96%87%E4%BB%B6%E5%A3%B0%E6%98%8E%E8%A7%84%E5%88%99"><span class="toc-number">4.7.</span> <span class="toc-text">源文件声明规则</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#import-%E8%AF%AD%E5%8F%A5"><span class="toc-number">4.8.</span> <span class="toc-text">import 语句</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84%E4%BE%8B%E5%AD%90"><span class="toc-number">4.9.</span> <span class="toc-text">一个简单的例子</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Java-%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-number">5.</span> <span class="toc-text">Java 基本数据类型</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%85%E7%BD%AE%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-number">5.1.</span> <span class="toc-text">内置数据类型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E4%BE%8B-1"><span class="toc-number">5.1.1.</span> <span class="toc-text">实例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E5%9E%8B%E9%BB%98%E8%AE%A4%E5%80%BC"><span class="toc-number">5.1.2.</span> <span class="toc-text">类型默认值</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B"><span class="toc-number">5.2.</span> <span class="toc-text">引用类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%87%AA%E5%8A%A8%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="toc-number">5.3.</span> <span class="toc-text">自动类型转换</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%AA%E5%8A%A8%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2-1"><span class="toc-number">5.3.1.</span> <span class="toc-text">自动类型转换</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%BA%E5%88%B6%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="toc-number">5.3.2.</span> <span class="toc-text">强制类型转换</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9A%90%E5%90%AB%E5%BC%BA%E5%88%B6%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="toc-number">5.3.3.</span> <span class="toc-text">隐含强制类型转换</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Java-%E5%8F%98%E9%87%8F%E7%B1%BB%E5%9E%8B"><span class="toc-number">6.</span> <span class="toc-text">Java 变量类型</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Java-%E5%8F%82%E6%95%B0%E5%8F%98%E9%87%8F"><span class="toc-number">6.1.</span> <span class="toc-text">Java 参数变量</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Java-%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F"><span class="toc-number">6.2.</span> <span class="toc-text">Java 局部变量</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F%EF%BC%88%E5%AE%9E%E4%BE%8B%E5%8F%98%E9%87%8F%EF%BC%89"><span class="toc-number">6.3.</span> <span class="toc-text">成员变量（实例变量）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B1%BB%E5%8F%98%E9%87%8F%EF%BC%88%E9%9D%99%E6%80%81%E5%8F%98%E9%87%8F%EF%BC%89"><span class="toc-number">6.4.</span> <span class="toc-text">类变量（静态变量）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89%E6%96%B9%E5%BC%8F"><span class="toc-number">6.4.1.</span> <span class="toc-text">定义方式</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9E%E4%BE%8B-2"><span class="toc-number">6.5.</span> <span class="toc-text">实例</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%BF%E9%97%AE%E6%96%B9%E5%BC%8F"><span class="toc-number">6.5.1.</span> <span class="toc-text">访问方式</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9E%E4%BE%8B-3"><span class="toc-number">6.6.</span> <span class="toc-text">实例</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="toc-number">6.6.1.</span> <span class="toc-text">生命周期</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96%E6%97%B6%E6%9C%BA"><span class="toc-number">6.6.2.</span> <span class="toc-text">初始化时机</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9E%E4%BE%8B-4"><span class="toc-number">6.7.</span> <span class="toc-text">实例</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E9%87%8F%E5%92%8C%E9%9D%99%E6%80%81%E5%8F%98%E9%87%8F%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">6.7.1.</span> <span class="toc-text">常量和静态变量的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E5%8F%98%E9%87%8F%E7%9A%84%E8%AE%BF%E9%97%AE%E4%BF%AE%E9%A5%B0%E7%AC%A6"><span class="toc-number">6.7.2.</span> <span class="toc-text">静态变量的访问修饰符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E5%8F%98%E9%87%8F%E7%9A%84%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E6%80%A7"><span class="toc-number">6.7.3.</span> <span class="toc-text">静态变量的线程安全性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E5%8F%98%E9%87%8F%E7%9A%84%E5%91%BD%E5%90%8D%E8%A7%84%E8%8C%83"><span class="toc-number">6.7.4.</span> <span class="toc-text">静态变量的命名规范</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9E%E4%BE%8B-5"><span class="toc-number">6.8.</span> <span class="toc-text">实例</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E5%8F%98%E9%87%8F%E7%9A%84%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">6.8.1.</span> <span class="toc-text">静态变量的使用场景</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Java-%E4%BF%AE%E9%A5%B0%E7%AC%A6"><span class="toc-number">7.</span> <span class="toc-text">Java 修饰符</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6%E4%BF%AE%E9%A5%B0%E7%AC%A6"><span class="toc-number">7.1.</span> <span class="toc-text">访问控制修饰符</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%BB%98%E8%AE%A4%E8%AE%BF%E9%97%AE%E4%BF%AE%E9%A5%B0%E7%AC%A6-%E4%B8%8D%E4%BD%BF%E7%94%A8%E4%BB%BB%E4%BD%95%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-number">7.1.1.</span> <span class="toc-text">默认访问修饰符-不使用任何关键字</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A7%81%E6%9C%89%E8%AE%BF%E9%97%AE%E4%BF%AE%E9%A5%B0%E7%AC%A6-private"><span class="toc-number">7.1.2.</span> <span class="toc-text">私有访问修饰符-private</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%AC%E6%9C%89%E8%AE%BF%E9%97%AE%E4%BF%AE%E9%A5%B0%E7%AC%A6-public"><span class="toc-number">7.1.3.</span> <span class="toc-text">公有访问修饰符-public</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%97%E4%BF%9D%E6%8A%A4%E7%9A%84%E8%AE%BF%E9%97%AE%E4%BF%AE%E9%A5%B0%E7%AC%A6-protected"><span class="toc-number">7.1.4.</span> <span class="toc-text">受保护的访问修饰符-protected</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6%E5%92%8C%E7%BB%A7%E6%89%BF"><span class="toc-number">7.1.5.</span> <span class="toc-text">访问控制和继承</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9D%9E%E8%AE%BF%E9%97%AE%E4%BF%AE%E9%A5%B0%E7%AC%A6"><span class="toc-number">7.2.</span> <span class="toc-text">非访问修饰符</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#static-%E4%BF%AE%E9%A5%B0%E7%AC%A6"><span class="toc-number">7.2.1.</span> <span class="toc-text">static 修饰符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#final-%E4%BF%AE%E9%A5%B0%E7%AC%A6"><span class="toc-number">7.2.2.</span> <span class="toc-text">final 修饰符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#abstract-%E4%BF%AE%E9%A5%B0%E7%AC%A6"><span class="toc-number">7.2.3.</span> <span class="toc-text">abstract 修饰符</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Java-%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">8.</span> <span class="toc-text">Java 运算符</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AE%97%E6%9C%AF%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">8.1.</span> <span class="toc-text">算术运算符</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%B3%E7%B3%BB%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">8.2.</span> <span class="toc-text">关系运算符</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%8D%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">8.3.</span> <span class="toc-text">位运算符</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%80%BB%E8%BE%91%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">8.4.</span> <span class="toc-text">逻辑运算符</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9F%AD%E8%B7%AF%E9%80%BB%E8%BE%91%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">8.4.1.</span> <span class="toc-text">短路逻辑运算符</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B5%8B%E5%80%BC%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">8.5.</span> <span class="toc-text">赋值运算符</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9D%A1%E4%BB%B6%E8%BF%90%E7%AE%97%E7%AC%A6%EF%BC%88-%EF%BC%89"><span class="toc-number">8.6.</span> <span class="toc-text">条件运算符（?:）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#instanceof-%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">8.7.</span> <span class="toc-text">instanceof 运算符</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Java%E8%BF%90%E7%AE%97%E7%AC%A6%E4%BC%98%E5%85%88%E7%BA%A7"><span class="toc-number">8.8.</span> <span class="toc-text">Java运算符优先级</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Java-%E5%BE%AA%E7%8E%AF%E7%BB%93%E6%9E%84-for-while-%E5%8F%8A-do%E2%80%A6while"><span class="toc-number">9.</span> <span class="toc-text">Java 循环结构 - for, while 及 do…while</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#while-%E5%BE%AA%E7%8E%AF"><span class="toc-number">9.1.</span> <span class="toc-text">while 循环</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#do%E2%80%A6while-%E5%BE%AA%E7%8E%AF"><span class="toc-number">9.2.</span> <span class="toc-text">do…while 循环</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#for%E5%BE%AA%E7%8E%AF"><span class="toc-number">9.3.</span> <span class="toc-text">for循环</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Java-%E5%A2%9E%E5%BC%BA-for-%E5%BE%AA%E7%8E%AF"><span class="toc-number">9.4.</span> <span class="toc-text">Java 增强 for 循环</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E4%BE%8B-6"><span class="toc-number">9.4.1.</span> <span class="toc-text">实例</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Test-java-%E6%96%87%E4%BB%B6%E4%BB%A3%E7%A0%81%EF%BC%9A"><span class="toc-number">9.5.</span> <span class="toc-text">Test.java 文件代码：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#break-%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-number">9.6.</span> <span class="toc-text">break 关键字</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#continue-%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-number">9.7.</span> <span class="toc-text">continue 关键字</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Java-%E6%9D%A1%E4%BB%B6%E8%AF%AD%E5%8F%A5-if%E2%80%A6else"><span class="toc-number">10.</span> <span class="toc-text">Java 条件语句 - if…else</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#if%E2%80%A6else%E8%AF%AD%E5%8F%A5"><span class="toc-number">10.1.</span> <span class="toc-text">if…else语句</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%AD%E6%B3%95"><span class="toc-number">10.1.1.</span> <span class="toc-text">语法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#if%E2%80%A6else-if%E2%80%A6else-%E8%AF%AD%E5%8F%A5"><span class="toc-number">10.2.</span> <span class="toc-text">if…else if…else 语句</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B5%8C%E5%A5%97%E7%9A%84-if%E2%80%A6else-%E8%AF%AD%E5%8F%A5"><span class="toc-number">10.3.</span> <span class="toc-text">嵌套的 if…else 语句</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%AD%E6%B3%95-1"><span class="toc-number">10.3.1.</span> <span class="toc-text">语法</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Java-switch-case-%E8%AF%AD%E5%8F%A5"><span class="toc-number">11.</span> <span class="toc-text">Java switch case 语句</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%AD%E6%B3%95-2"><span class="toc-number">11.0.1.</span> <span class="toc-text">语法</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Java-Number-Math-%E7%B1%BB"><span class="toc-number">12.</span> <span class="toc-text">Java Number &amp; Math 类</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Java-Math-%E7%B1%BB"><span class="toc-number">12.1.</span> <span class="toc-text">Java Math 类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Number-Math-%E7%B1%BB%E6%96%B9%E6%B3%95"><span class="toc-number">12.2.</span> <span class="toc-text">Number &amp; Math 类方法</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Java-Character-%E7%B1%BB"><span class="toc-number">13.</span> <span class="toc-text">Java Character 类</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BD%AC%E4%B9%89%E5%BA%8F%E5%88%97"><span class="toc-number">13.1.</span> <span class="toc-text">转义序列</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Character-%E6%96%B9%E6%B3%95"><span class="toc-number">13.2.</span> <span class="toc-text">Character 方法</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Java-String-%E7%B1%BB"><span class="toc-number">14.</span> <span class="toc-text">Java String 类</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-number">14.1.</span> <span class="toc-text">创建字符串</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#String-%E6%96%B9%E6%B3%95"><span class="toc-number">14.2.</span> <span class="toc-text">String 方法</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Java-StringBuffer-%E5%92%8C-StringBuilder-%E7%B1%BB"><span class="toc-number">15.</span> <span class="toc-text">Java StringBuffer 和 StringBuilder 类</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#StringBuffer-%E6%96%B9%E6%B3%95"><span class="toc-number">15.1.</span> <span class="toc-text">StringBuffer 方法</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Java-%E6%95%B0%E7%BB%84-1"><span class="toc-number">16.</span> <span class="toc-text">Java 数组</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A3%B0%E6%98%8E%E6%95%B0%E7%BB%84%E5%8F%98%E9%87%8F"><span class="toc-number">16.1.</span> <span class="toc-text">声明数组变量</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E6%95%B0%E7%BB%84"><span class="toc-number">16.2.</span> <span class="toc-text">创建数组</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%84%E7%90%86%E6%95%B0%E7%BB%84"><span class="toc-number">16.3.</span> <span class="toc-text">处理数组</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#For-Each-%E5%BE%AA%E7%8E%AF"><span class="toc-number">16.4.</span> <span class="toc-text">For-Each 循环</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%9A%E7%BB%B4%E6%95%B0%E7%BB%84"><span class="toc-number">16.5.</span> <span class="toc-text">多维数组</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E7%BB%B4%E6%95%B0%E7%BB%84%E7%9A%84%E5%8A%A8%E6%80%81%E5%88%9D%E5%A7%8B%E5%8C%96%EF%BC%88%E4%BB%A5%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E4%B8%BA%E4%BE%8B%EF%BC%89"><span class="toc-number">16.5.1.</span> <span class="toc-text">多维数组的动态初始化（以二维数组为例）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Arrays-%E7%B1%BB"><span class="toc-number">16.6.</span> <span class="toc-text">Arrays 类</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Java-%E6%97%A5%E6%9C%9F%E6%97%B6%E9%97%B4"><span class="toc-number">17.</span> <span class="toc-text">Java 日期时间</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96%E5%BD%93%E5%89%8D%E6%97%A5%E6%9C%9F%E6%97%B6%E9%97%B4"><span class="toc-number">17.1.</span> <span class="toc-text">获取当前日期时间</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%97%A5%E6%9C%9F%E6%AF%94%E8%BE%83"><span class="toc-number">17.2.</span> <span class="toc-text">日期比较</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8-SimpleDateFormat-%E6%A0%BC%E5%BC%8F%E5%8C%96%E6%97%A5%E6%9C%9F"><span class="toc-number">17.3.</span> <span class="toc-text">使用 SimpleDateFormat 格式化日期</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8printf%E6%A0%BC%E5%BC%8F%E5%8C%96%E6%97%A5%E6%9C%9F"><span class="toc-number">17.4.</span> <span class="toc-text">使用printf格式化日期</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Java-%E4%BC%91%E7%9C%A0-sleep"><span class="toc-number">17.5.</span> <span class="toc-text">Java 休眠(sleep)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Calendar%E7%B1%BB"><span class="toc-number">17.6.</span> <span class="toc-text">Calendar类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E4%BB%A3%E8%A1%A8%E7%B3%BB%E7%BB%9F%E5%BD%93%E5%89%8D%E6%97%A5%E6%9C%9F%E7%9A%84Calendar%E5%AF%B9%E8%B1%A1"><span class="toc-number">17.6.1.</span> <span class="toc-text">创建一个代表系统当前日期的Calendar对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E6%8C%87%E5%AE%9A%E6%97%A5%E6%9C%9F%E7%9A%84Calendar%E5%AF%B9%E8%B1%A1"><span class="toc-number">17.6.2.</span> <span class="toc-text">创建一个指定日期的Calendar对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Calendar%E7%B1%BB%E5%AF%B9%E8%B1%A1%E5%AD%97%E6%AE%B5%E7%B1%BB%E5%9E%8B"><span class="toc-number">17.6.3.</span> <span class="toc-text">Calendar类对象字段类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Calendar%E7%B1%BB%E5%AF%B9%E8%B1%A1%E4%BF%A1%E6%81%AF%E7%9A%84%E8%8E%B7%E5%BE%97"><span class="toc-number">17.6.4.</span> <span class="toc-text">Calendar类对象信息的获得</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Java-%E6%96%B9%E6%B3%95"><span class="toc-number">18.</span> <span class="toc-text">Java 方法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%82%A3%E4%B9%88%E4%BB%80%E4%B9%88%E6%98%AF%E6%96%B9%E6%B3%95%E5%91%A2%EF%BC%9F"><span class="toc-number">18.0.1.</span> <span class="toc-text">那么什么是方法呢？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E7%9A%84%E4%BC%98%E7%82%B9"><span class="toc-number">18.0.2.</span> <span class="toc-text">方法的优点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E7%9A%84%E5%91%BD%E5%90%8D%E8%A7%84%E5%88%99"><span class="toc-number">18.0.3.</span> <span class="toc-text">方法的命名规则</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="toc-number">18.1.</span> <span class="toc-text">方法的定义</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E7%9A%84%E9%87%8D%E8%BD%BD"><span class="toc-number">18.2.</span> <span class="toc-text">方法的重载</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95-1"><span class="toc-number">18.3.</span> <span class="toc-text">构造方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#finalize-%E6%96%B9%E6%B3%95"><span class="toc-number">18.4.</span> <span class="toc-text">finalize() 方法</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Java-%E6%B5%81-Stream-%E3%80%81%E6%96%87%E4%BB%B6-File-%E5%92%8CIO"><span class="toc-number">19.</span> <span class="toc-text">Java 流(Stream)、文件(File)和IO</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AF%BB%E5%8F%96%E6%8E%A7%E5%88%B6%E5%8F%B0%E8%BE%93%E5%85%A5"><span class="toc-number">19.1.</span> <span class="toc-text">读取控制台输入</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%8E%E6%8E%A7%E5%88%B6%E5%8F%B0%E8%AF%BB%E5%8F%96%E5%A4%9A%E5%AD%97%E7%AC%A6%E8%BE%93%E5%85%A5"><span class="toc-number">19.2.</span> <span class="toc-text">从控制台读取多字符输入</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%8E%E6%8E%A7%E5%88%B6%E5%8F%B0%E8%AF%BB%E5%8F%96%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-number">19.3.</span> <span class="toc-text">从控制台读取字符串</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8E%A7%E5%88%B6%E5%8F%B0%E8%BE%93%E5%87%BA"><span class="toc-number">19.4.</span> <span class="toc-text">控制台输出</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#FileInputStream"><span class="toc-number">19.5.</span> <span class="toc-text">FileInputStream</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#FileOutputStream"><span class="toc-number">19.6.</span> <span class="toc-text">FileOutputStream</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E5%92%8CI-O"><span class="toc-number">19.7.</span> <span class="toc-text">文件和I&#x2F;O</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Java%E4%B8%AD%E7%9A%84%E7%9B%AE%E5%BD%95"><span class="toc-number">19.8.</span> <span class="toc-text">Java中的目录</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E7%9B%AE%E5%BD%95%EF%BC%9A"><span class="toc-number">19.8.1.</span> <span class="toc-text">创建目录：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AF%BB%E5%8F%96%E7%9B%AE%E5%BD%95"><span class="toc-number">19.9.</span> <span class="toc-text">读取目录</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%A0%E9%99%A4%E7%9B%AE%E5%BD%95%E6%88%96%E6%96%87%E4%BB%B6"><span class="toc-number">19.10.</span> <span class="toc-text">删除目录或文件</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Java-Scanner-%E7%B1%BB"><span class="toc-number">20.</span> <span class="toc-text">Java Scanner 类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8-next-%E6%96%B9%E6%B3%95%EF%BC%9A"><span class="toc-number">20.0.1.</span> <span class="toc-text">使用 next 方法：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8-nextLine-%E6%96%B9%E6%B3%95%EF%BC%9A"><span class="toc-number">20.0.2.</span> <span class="toc-text">使用 nextLine 方法：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#next-%E4%B8%8E-nextLine-%E5%8C%BA%E5%88%AB"><span class="toc-number">20.0.3.</span> <span class="toc-text">next() 与 nextLine() 区别</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Java-%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86"><span class="toc-number">21.</span> <span class="toc-text">Java 异常处理</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Exception-%E7%B1%BB%E7%9A%84%E5%B1%82%E6%AC%A1"><span class="toc-number">21.1.</span> <span class="toc-text">Exception 类的层次</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8D%95%E8%8E%B7%E5%BC%82%E5%B8%B8"><span class="toc-number">21.2.</span> <span class="toc-text">捕获异常</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#throws-throw-%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-number">21.3.</span> <span class="toc-text">throws&#x2F;throw 关键字</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#throw-%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-number">21.3.1.</span> <span class="toc-text">throw 关键字</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#throws-%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-number">21.3.2.</span> <span class="toc-text">throws 关键字</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#finally%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-number">21.4.</span> <span class="toc-text">finally关键字</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#try-with-resources"><span class="toc-number">21.5.</span> <span class="toc-text">try-with-resources</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A3%B0%E6%98%8E%E8%87%AA%E5%AE%9A%E4%B9%89%E5%BC%82%E5%B8%B8"><span class="toc-number">21.6.</span> <span class="toc-text">声明自定义异常</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Java-%E7%BB%A7%E6%89%BF"><span class="toc-number">22.</span> <span class="toc-text">Java 继承</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%A7%E6%89%BF%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="toc-number">22.1.</span> <span class="toc-text">继承的概念</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%94%9F%E6%B4%BB%E4%B8%AD%E7%9A%84%E7%BB%A7%E6%89%BF%EF%BC%9A"><span class="toc-number">22.1.1.</span> <span class="toc-text">生活中的继承：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E7%9A%84%E7%BB%A7%E6%89%BF%E6%A0%BC%E5%BC%8F"><span class="toc-number">22.1.2.</span> <span class="toc-text">类的继承格式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%A7%E6%89%BF%E7%B1%BB%E5%9E%8B"><span class="toc-number">22.1.3.</span> <span class="toc-text">继承类型</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%A7%E6%89%BF%E7%9A%84%E7%89%B9%E6%80%A7"><span class="toc-number">22.2.</span> <span class="toc-text">继承的特性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%A7%E6%89%BF%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-number">22.3.</span> <span class="toc-text">继承关键字</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#extends%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-number">22.3.1.</span> <span class="toc-text">extends关键字</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E5%99%A8"><span class="toc-number">22.4.</span> <span class="toc-text">构造器</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Java-%E9%87%8D%E5%86%99-Override-%E4%B8%8E%E9%87%8D%E8%BD%BD-Overload"><span class="toc-number">23.</span> <span class="toc-text">Java 重写(Override)与重载(Overload)</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%87%8D%E5%86%99-Override"><span class="toc-number">23.1.</span> <span class="toc-text">重写(Override)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E7%9A%84%E9%87%8D%E5%86%99%E8%A7%84%E5%88%99"><span class="toc-number">23.2.</span> <span class="toc-text">方法的重写规则</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%87%8D%E8%BD%BD-Overload"><span class="toc-number">23.3.</span> <span class="toc-text">重载(Overload)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%87%8D%E5%86%99%E4%B8%8E%E9%87%8D%E8%BD%BD%E4%B9%8B%E9%97%B4%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">23.4.</span> <span class="toc-text">重写与重载之间的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">23.5.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Java-%E5%A4%9A%E6%80%81"><span class="toc-number">24.</span> <span class="toc-text">Java 多态</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E6%80%81%E7%9A%84%E4%BC%98%E7%82%B9"><span class="toc-number">24.0.1.</span> <span class="toc-text">多态的优点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E6%80%81%E5%AD%98%E5%9C%A8%E7%9A%84%E4%B8%89%E4%B8%AA%E5%BF%85%E8%A6%81%E6%9D%A1%E4%BB%B6"><span class="toc-number">24.0.2.</span> <span class="toc-text">多态存在的三个必要条件</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%9A%E6%80%81%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F"><span class="toc-number">24.1.</span> <span class="toc-text">多态的实现方式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B9%E5%BC%8F%E4%B8%80%EF%BC%9A%E9%87%8D%E5%86%99%EF%BC%9A"><span class="toc-number">24.1.1.</span> <span class="toc-text">方式一：重写：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B9%E5%BC%8F%E4%BA%8C%EF%BC%9A%E6%8E%A5%E5%8F%A3"><span class="toc-number">24.1.2.</span> <span class="toc-text">方式二：接口</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B9%E5%BC%8F%E4%B8%89%EF%BC%9A%E6%8A%BD%E8%B1%A1%E7%B1%BB%E5%92%8C%E6%8A%BD%E8%B1%A1%E6%96%B9%E6%B3%95"><span class="toc-number">24.1.3.</span> <span class="toc-text">方式三：抽象类和抽象方法</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Java-%E6%8A%BD%E8%B1%A1%E7%B1%BB"><span class="toc-number">25.</span> <span class="toc-text">Java 抽象类</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8A%BD%E8%B1%A1%E7%B1%BB"><span class="toc-number">25.1.</span> <span class="toc-text">抽象类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8A%BD%E8%B1%A1%E6%96%B9%E6%B3%95"><span class="toc-number">25.2.</span> <span class="toc-text">抽象方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8A%BD%E8%B1%A1%E7%B1%BB%E6%80%BB%E7%BB%93%E8%A7%84%E5%AE%9A"><span class="toc-number">25.3.</span> <span class="toc-text">抽象类总结规定</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Java-%E5%B0%81%E8%A3%85"><span class="toc-number">26.</span> <span class="toc-text">Java 封装</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B0%81%E8%A3%85%E7%9A%84%E4%BC%98%E7%82%B9"><span class="toc-number">26.0.1.</span> <span class="toc-text">封装的优点</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Java-%E6%8E%A5%E5%8F%A3"><span class="toc-number">27.</span> <span class="toc-text">Java 接口</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8E%A5%E5%8F%A3%E4%B8%8E%E7%B1%BB%E7%9B%B8%E4%BC%BC%E7%82%B9%EF%BC%9A"><span class="toc-number">27.0.1.</span> <span class="toc-text">接口与类相似点：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8E%A5%E5%8F%A3%E4%B8%8E%E7%B1%BB%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9A"><span class="toc-number">27.0.2.</span> <span class="toc-text">接口与类的区别：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8E%A5%E5%8F%A3%E7%89%B9%E6%80%A7"><span class="toc-number">27.0.3.</span> <span class="toc-text">接口特性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8A%BD%E8%B1%A1%E7%B1%BB%E5%92%8C%E6%8E%A5%E5%8F%A3%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">27.0.4.</span> <span class="toc-text">抽象类和接口的区别</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%87%E8%AE%B0%E6%8E%A5%E5%8F%A3"><span class="toc-number">27.1.</span> <span class="toc-text">标记接口</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Java-%E6%9E%9A%E4%B8%BE-enum"><span class="toc-number">28.</span> <span class="toc-text">Java 枚举(enum)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#values-ordinal-%E5%92%8C-valueOf-%E6%96%B9%E6%B3%95"><span class="toc-number">28.0.1.</span> <span class="toc-text">values(), ordinal() 和 valueOf() 方法</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Java-%E5%8C%85-package"><span class="toc-number">29.</span> <span class="toc-text">Java 包(package)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8C%85%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="toc-number">29.0.1.</span> <span class="toc-text">包的作用</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E5%8C%85"><span class="toc-number">29.1.</span> <span class="toc-text">创建包</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#import-%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-number">29.2.</span> <span class="toc-text">import 关键字</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Java-%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6"><span class="toc-number">30.</span> <span class="toc-text">Java 集合框架</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9B%86%E5%90%88%E6%8E%A5%E5%8F%A3"><span class="toc-number">30.1.</span> <span class="toc-text">集合接口</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Set%E5%92%8CList%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">30.1.1.</span> <span class="toc-text">Set和List的区别</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8%E8%BF%AD%E4%BB%A3%E5%99%A8"><span class="toc-number">30.2.</span> <span class="toc-text">如何使用迭代器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-1"><span class="toc-number">30.3.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Java-ArrayList"><span class="toc-number">31.</span> <span class="toc-text">Java ArrayList</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Java-ArrayList-%E6%96%B9%E6%B3%95"><span class="toc-number">31.1.</span> <span class="toc-text">Java ArrayList 方法</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Java-LinkedList"><span class="toc-number">32.</span> <span class="toc-text">Java LinkedList</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95"><span class="toc-number">32.0.1.</span> <span class="toc-text">常用方法</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Java-HashSet"><span class="toc-number">33.</span> <span class="toc-text">Java HashSet</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Java-HashMap"><span class="toc-number">34.</span> <span class="toc-text">Java HashMap</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Java-HashMap-%E6%96%B9%E6%B3%95"><span class="toc-number">34.1.</span> <span class="toc-text">Java HashMap 方法</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Java-Iterator%EF%BC%88%E8%BF%AD%E4%BB%A3%E5%99%A8%EF%BC%89"><span class="toc-number">35.</span> <span class="toc-text">Java Iterator（迭代器）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96%E4%B8%80%E4%B8%AA%E8%BF%AD%E4%BB%A3%E5%99%A8"><span class="toc-number">35.0.1.</span> <span class="toc-text">获取一个迭代器</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Java-Object-%E7%B1%BB"><span class="toc-number">36.</span> <span class="toc-text">Java Object 类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E7%9A%84%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="toc-number">36.0.1.</span> <span class="toc-text">类的构造函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E7%9A%84%E6%96%B9%E6%B3%95"><span class="toc-number">36.0.2.</span> <span class="toc-text">类的方法</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Java-%E6%B3%9B%E5%9E%8B"><span class="toc-number">37.</span> <span class="toc-text">Java 泛型</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B3%9B%E5%9E%8B%E6%96%B9%E6%B3%95"><span class="toc-number">37.1.</span> <span class="toc-text">泛型方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B3%9B%E5%9E%8B%E7%B1%BB"><span class="toc-number">37.2.</span> <span class="toc-text">泛型类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E4%BE%8B-7"><span class="toc-number">37.2.1.</span> <span class="toc-text">实例</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B1%BB%E5%9E%8B%E9%80%9A%E9%85%8D%E7%AC%A6"><span class="toc-number">37.3.</span> <span class="toc-text">类型通配符</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Java-%E5%BA%8F%E5%88%97%E5%8C%96"><span class="toc-number">38.</span> <span class="toc-text">Java 序列化</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Java-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B"><span class="toc-number">39.</span> <span class="toc-text">Java 网络编程</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Socket-%E7%BC%96%E7%A8%8B"><span class="toc-number">39.1.</span> <span class="toc-text">Socket 编程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Socket-%E7%B1%BB%E7%9A%84%E6%96%B9%E6%B3%95"><span class="toc-number">39.2.</span> <span class="toc-text">Socket 类的方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Socket-%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%AE%9E%E4%BE%8B"><span class="toc-number">39.3.</span> <span class="toc-text">Socket 客户端实例</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Socket-%E6%9C%8D%E5%8A%A1%E7%AB%AF%E5%AE%9E%E4%BE%8B"><span class="toc-number">39.4.</span> <span class="toc-text">Socket 服务端实例</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Java-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B"><span class="toc-number">40.</span> <span class="toc-text">Java 多线程编程</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E4%B8%AA%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="toc-number">40.1.</span> <span class="toc-text">一个线程的生命周期</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E7%9A%84%E4%BC%98%E5%85%88%E7%BA%A7"><span class="toc-number">40.2.</span> <span class="toc-text">线程的优先级</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E7%BA%BF%E7%A8%8B"><span class="toc-number">40.3.</span> <span class="toc-text">创建一个线程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%80%9A%E8%BF%87-Callable-%E5%92%8C-Future-%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B"><span class="toc-number">40.4.</span> <span class="toc-text">通过 Callable 和 Future 创建线程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B%E7%9A%84%E4%B8%89%E7%A7%8D%E6%96%B9%E5%BC%8F%E7%9A%84%E5%AF%B9%E6%AF%94"><span class="toc-number">40.5.</span> <span class="toc-text">创建线程的三种方式的对比</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%87%A0%E4%B8%AA%E4%B8%BB%E8%A6%81%E6%A6%82%E5%BF%B5"><span class="toc-number">40.6.</span> <span class="toc-text">线程的几个主要概念</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-number">40.7.</span> <span class="toc-text">多线程的使用</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Java-%E6%96%87%E6%A1%A3%E6%B3%A8%E9%87%8A"><span class="toc-number">41.</span> <span class="toc-text">Java 文档注释</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#javadoc-%E6%A0%87%E7%AD%BE"><span class="toc-number">41.1.</span> <span class="toc-text">javadoc 标签</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-history"></i><span>最近发布</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/posts/c45230cb.html" title="mysql面试题"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://s2.loli.net/2025/10/23/w3ErpsQhncfDed2.jpg?_r_=7a487ade-a613-3f8f-d549-a793e3c2aa17" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="mysql面试题"/></a><div class="content"><a class="title" href="/posts/c45230cb.html" title="mysql面试题">mysql面试题</a><time datetime="2025-10-27T03:31:36.000Z" title="发表于 2025-10-27 11:31:36">2025-10-27</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/66c016fb.html" title="JVM"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://s2.loli.net/2025/10/23/w3ErpsQhncfDed2.jpg?_r_=073fb3c1-1ed6-85dc-4b49-6bade417019f" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="JVM"/></a><div class="content"><a class="title" href="/posts/66c016fb.html" title="JVM">JVM</a><time datetime="2025-10-24T15:31:36.000Z" title="发表于 2025-10-24 23:31:36">2025-10-24</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/498cfd8e.html" title="并发编程"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://s2.loli.net/2025/10/23/w3ErpsQhncfDed2.jpg?_r_=e93610d2-afe5-62c9-ffac-34bc6ede57ce" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="并发编程"/></a><div class="content"><a class="title" href="/posts/498cfd8e.html" title="并发编程">并发编程</a><time datetime="2025-10-23T15:51:36.000Z" title="发表于 2025-10-23 23:51:36">2025-10-23</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/7edb9ee1.html" title="集合框架"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://s2.loli.net/2025/10/23/g4UkwyDri9BWZtE.jpg?_r_=15bc3fef-3044-c8b4-4d1c-cc585f957842" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="集合框架"/></a><div class="content"><a class="title" href="/posts/7edb9ee1.html" title="集合框架">集合框架</a><time datetime="2025-10-23T08:48:49.330Z" title="发表于 2025-10-23 16:48:49">2025-10-23</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/aff6963e.html" title="如何解决高并发下的库存抢购超卖少买问题？"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://s2.loli.net/2025/10/23/YUHOf5MZEItlGd3.jpg?_r_=1d335fd2-520a-5de8-b607-f2b3e5a780fa" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="如何解决高并发下的库存抢购超卖少买问题？"/></a><div class="content"><a class="title" href="/posts/aff6963e.html" title="如何解决高并发下的库存抢购超卖少买问题？">如何解决高并发下的库存抢购超卖少买问题？</a><time datetime="2025-10-23T04:24:36.000Z" title="发表于 2025-10-23 12:24:36">2025-10-23</time></div></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div id="workboard"><img class="workSituationImg boardsign" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://npm.elemecdn.com/anzhiyu-blog@2.0.4/img/badge/安知鱼-上班摸鱼中.svg" alt="距离月入25k也就还差一个大佬带我~" title="距离月入25k也就还差一个大佬带我~"/><div id="runtimeTextTip"></div></div><p id="ghbdages"><a class="github-badge" target="_blank" href="https://hexo.io/" style="margin-inline:5px" data-title="博客框架为Hexo_v5.4.0" title="博客框架为Hexo_v5.4.0"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://npm.elemecdn.com/anzhiyu-blog@2.1.5/img/badge/Frame-Hexo.svg" alt="博客框架为Hexo_v5.4.0"/></a><a class="github-badge" target="_blank" href="https://blog.anheyu.com/" style="margin-inline:5px" data-title="本站使用AnZhiYu主题" title="本站使用AnZhiYu主题"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://npm.elemecdn.com/anzhiyu-theme-static@1.0.9/img/Theme-AnZhiYu-2E67D3.svg" alt="本站使用AnZhiYu主题"/></a><a class="github-badge" target="_blank" href="https://www.dogecloud.com/" style="margin-inline:5px" data-title="本站使用多吉云为静态资源提供CDN加速" title="本站使用多吉云为静态资源提供CDN加速"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://npm.elemecdn.com/anzhiyu-blog@2.2.0/img/badge/CDN-多吉云-3693F3.svg" alt="本站使用多吉云为静态资源提供CDN加速"/></a><a class="github-badge" target="_blank" href="https://github.com/" style="margin-inline:5px" data-title="本站项目由Github托管" title="本站项目由Github托管"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://npm.elemecdn.com/anzhiyu-blog@2.1.5/img/badge/Source-Github.svg" alt="本站项目由Github托管"/></a><a class="github-badge" target="_blank" href="http://creativecommons.org/licenses/by-nc-sa/4.0/" style="margin-inline:5px" data-title="本站采用知识共享署名-非商业性使用-相同方式共享4.0国际许可协议进行许可" title="本站采用知识共享署名-非商业性使用-相同方式共享4.0国际许可协议进行许可"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://npm.elemecdn.com/anzhiyu-blog@2.2.0/img/badge/Copyright-BY-NC-SA.svg" alt="本站采用知识共享署名-非商业性使用-相同方式共享4.0国际许可协议进行许可"/></a></p></div><div id="footer-bar"><div class="footer-bar-links"><div class="footer-bar-left"><div id="footer-bar-tips"><div class="copyright">&copy;2020 - 2025 By <a class="footer-bar-link" href="/" title="Wsk" target="_blank">Wsk</a></div></div><div id="footer-type-tips"></div></div><div class="footer-bar-right"><a class="footer-bar-link" target="_blank" rel="noopener" href="https://github.com/anzhiyu-c/hexo-theme-anzhiyu" title="主题">主题</a></div></div></div></footer></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="sidebar-site-data site-data is-center"><a href="/archives/" title="archive"><div class="headline">文章</div><div class="length-num">16</div></a><a href="/tags/" title="tag"><div class="headline">标签</div><div class="length-num">18</div></a><a href="/categories/" title="category"><div class="headline">分类</div><div class="length-num">5</div></a></div><span class="sidebar-menu-item-title">功能</span><div class="sidebar-menu-item"><a class="darkmode_switchbutton menu-child" href="javascript:void(0);" title="显示模式"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i><span>显示模式</span></a></div><div class="back-menu-list-groups"><div class="back-menu-list-group"><div class="back-menu-list-title">网页</div><div class="back-menu-list"><a class="back-menu-item" target="_blank" rel="noopener" href="https://blog.anheyu.com/" title="博客"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/favicon.png" alt="博客"/><span class="back-menu-item-text">博客</span></a></div></div></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 文章</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/archives/"><i class="anzhiyufont anzhiyu-icon-box-archive faa-tada" style="font-size: 0.9em;"></i><span> 隧道</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/categories/"><i class="anzhiyufont anzhiyu-icon-shapes faa-tada" style="font-size: 0.9em;"></i><span> 分类</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/tags/"><i class="anzhiyufont anzhiyu-icon-tags faa-tada" style="font-size: 0.9em;"></i><span> 标签</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 友链</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/link/"><i class="anzhiyufont anzhiyu-icon-link faa-tada" style="font-size: 0.9em;"></i><span> 友人帐</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/fcircle/"><i class="anzhiyufont anzhiyu-icon-artstation faa-tada" style="font-size: 0.9em;"></i><span> 朋友圈</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/comments/"><i class="anzhiyufont anzhiyu-icon-envelope faa-tada" style="font-size: 0.9em;"></i><span> 留言板</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 我的</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/music/?id=2898229193&amp;server=netease"><i class="anzhiyufont anzhiyu-icon-music faa-tada" style="font-size: 0.9em;"></i><span> 音乐馆</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/album/"><i class="anzhiyufont anzhiyu-icon-images faa-tada" style="font-size: 0.9em;"></i><span> 相册集</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/air-conditioner/"><i class="anzhiyufont anzhiyu-icon-fan faa-tada" style="font-size: 0.9em;"></i><span> 小空调</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 关于</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/about/"><i class="anzhiyufont anzhiyu-icon-paper-plane faa-tada" style="font-size: 0.9em;"></i><span> 关于本人</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/essay/"><i class="anzhiyufont anzhiyu-icon-lightbulb faa-tada" style="font-size: 0.9em;"></i><span> 闲言碎语</span></a></li></ul></div></div><span class="sidebar-menu-item-title">标签</span><div class="card-tags"><div class="item-headline"></div><div class="card-tag-cloud"><a href="/tags/JVM%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/" style="font-size: 0.88rem;">JVM内存模型<sup>1</sup></a><a href="/tags/JVM%E8%B0%83%E4%BC%98/" style="font-size: 0.88rem;">JVM调优<sup>1</sup></a><a href="/tags/java%E6%95%99%E7%A8%8B/" style="font-size: 0.88rem;">java教程<sup>1</sup></a><a href="/tags/mysql/" style="font-size: 0.88rem;">mysql<sup>1</sup></a><a href="/tags/%E5%87%BD%E6%95%B0/" style="font-size: 0.88rem;">函数<sup>1</sup></a><a href="/tags/%E5%8F%8D%E5%B0%84/" style="font-size: 0.88rem;">反射<sup>1</sup></a><a href="/tags/%E5%A4%8D%E4%B9%A0/" style="font-size: 0.88rem;">复习<sup>1</sup></a><a href="/tags/%E5%A4%8D%E4%B9%A0-%E5%8F%98%E9%87%8F/" style="font-size: 0.88rem;">复习 变量<sup>1</sup></a><a href="/tags/%E5%B7%A5%E5%85%B7/" style="font-size: 0.88rem;">工具<sup>1</sup></a><a href="/tags/%E5%B9%B6%E5%8F%91/" style="font-size: 0.88rem;">并发<sup>1</sup></a><a href="/tags/%E6%83%85%E6%84%9F/" style="font-size: 0.88rem;">情感<sup>1</sup></a><a href="/tags/%E6%8A%BD%E8%B1%A1%E7%B1%BB-%E6%8E%A5%E5%8F%A3/" style="font-size: 0.88rem;">抽象类 接口<sup>1</sup></a><a href="/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/" style="font-size: 0.88rem;">数据库<sup>1</sup></a><a href="/tags/%E6%AF%8F%E6%97%A5%E9%9D%A2%E8%AF%95/" style="font-size: 0.88rem;">每日面试<sup>2</sup></a><a href="/tags/%E7%94%B5%E5%95%86-%E8%AE%A2%E5%8D%95/" style="font-size: 0.88rem;">电商,订单<sup>1</sup></a><a href="/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" style="font-size: 0.88rem;">设计模式<sup>1</sup></a><a href="/tags/%E8%B6%85%E5%8D%96-%E5%BA%93%E5%AD%98/" style="font-size: 0.88rem;">超卖 , 库存<sup>1</sup></a><a href="/tags/%E9%9B%86%E5%90%88/" style="font-size: 0.88rem;">集合<sup>1</sup></a></div></div><hr/></div></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="anzhiyufont anzhiyu-icon-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">简</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="anzhiyufont anzhiyu-icon-arrows-left-right"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="anzhiyufont anzhiyu-icon-gear"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="anzhiyufont anzhiyu-icon-list-ul"></i></button><button id="chat-btn" type="button" title="聊天"><i class="anzhiyufont anzhiyu-icon-comment-sms"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="anzhiyufont anzhiyu-icon-comments"></i></a><a id="switch-commentBarrage" href="javascript:anzhiyu.switchCommentBarrage();" title="开关弹幕"><i class="anzhiyufont anzhiyu-icon-danmu"></i></a><button id="go-up" type="button" title="回到顶部"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></button></div></div><div id="nav-music"><a id="nav-music-hoverTips" onclick="anzhiyu.musicToggle()" accesskey="m">播放音乐</a><div id="console-music-bg"></div><meting-js id="8152976493" server="netease" type="playlist" mutex="true" preload="none" theme="var(--anzhiyu-main)" data-lrctype="0" order="random"></meting-js></div><div id="rightMenu"><div class="rightMenu-group rightMenu-small"><div class="rightMenu-item" id="menu-backward"><i class="anzhiyufont anzhiyu-icon-arrow-left"></i></div><div class="rightMenu-item" id="menu-forward"><i class="anzhiyufont anzhiyu-icon-arrow-right"></i></div><div class="rightMenu-item" id="menu-refresh"><i class="anzhiyufont anzhiyu-icon-arrow-rotate-right" style="font-size: 1rem;"></i></div><div class="rightMenu-item" id="menu-top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></div></div><div class="rightMenu-group rightMenu-line rightMenuPlugin"><div class="rightMenu-item" id="menu-copytext"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制选中文本</span></div><div class="rightMenu-item" id="menu-pastetext"><i class="anzhiyufont anzhiyu-icon-paste"></i><span>粘贴文本</span></div><a class="rightMenu-item" id="menu-commenttext"><i class="anzhiyufont anzhiyu-icon-comment-medical"></i><span>引用到评论</span></a><div class="rightMenu-item" id="menu-newwindow"><i class="anzhiyufont anzhiyu-icon-window-restore"></i><span>新窗口打开</span></div><div class="rightMenu-item" id="menu-copylink"><i class="anzhiyufont anzhiyu-icon-link"></i><span>复制链接地址</span></div><div class="rightMenu-item" id="menu-copyimg"><i class="anzhiyufont anzhiyu-icon-images"></i><span>复制此图片</span></div><div class="rightMenu-item" id="menu-downloadimg"><i class="anzhiyufont anzhiyu-icon-download"></i><span>下载此图片</span></div><div class="rightMenu-item" id="menu-newwindowimg"><i class="anzhiyufont anzhiyu-icon-window-restore"></i><span>新窗口打开图片</span></div><div class="rightMenu-item" id="menu-search"><i class="anzhiyufont anzhiyu-icon-magnifying-glass"></i><span>站内搜索</span></div><div class="rightMenu-item" id="menu-searchBaidu"><i class="anzhiyufont anzhiyu-icon-magnifying-glass"></i><span>百度搜索</span></div><div class="rightMenu-item" id="menu-music-toggle"><i class="anzhiyufont anzhiyu-icon-play"></i><span>播放音乐</span></div><div class="rightMenu-item" id="menu-music-back"><i class="anzhiyufont anzhiyu-icon-backward"></i><span>切换到上一首</span></div><div class="rightMenu-item" id="menu-music-forward"><i class="anzhiyufont anzhiyu-icon-forward"></i><span>切换到下一首</span></div><div class="rightMenu-item" id="menu-music-playlist" onclick="window.open(&quot;https://y.qq.com/n/ryqq/playlist/8152976493&quot;, &quot;_blank&quot;);" style="display: none;"><i class="anzhiyufont anzhiyu-icon-radio"></i><span>查看所有歌曲</span></div><div class="rightMenu-item" id="menu-music-copyMusicName"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制歌名</span></div></div><div class="rightMenu-group rightMenu-line rightMenuOther"><a class="rightMenu-item menu-link" id="menu-randomPost"><i class="anzhiyufont anzhiyu-icon-shuffle"></i><span>随便逛逛</span></a><a class="rightMenu-item menu-link" href="/categories/"><i class="anzhiyufont anzhiyu-icon-cube"></i><span>博客分类</span></a><a class="rightMenu-item menu-link" href="/tags/"><i class="anzhiyufont anzhiyu-icon-tags"></i><span>文章标签</span></a></div><div class="rightMenu-group rightMenu-line rightMenuOther"><a class="rightMenu-item" id="menu-copy" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制地址</span></a><a class="rightMenu-item" id="menu-commentBarrage" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-message"></i><span class="menu-commentBarrage-text">关闭热评</span></a><a class="rightMenu-item" id="menu-darkmode" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i><span class="menu-darkmode-text">深色模式</span></a><a class="rightMenu-item" id="menu-translate" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-language"></i><span>轉為繁體</span></a></div></div><div id="rightmenu-mask"></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.cbd.int/@fancyapps/ui@5.0.20/dist/fancybox/fancybox.umd.js"></script><script src="https://cdn.cbd.int/instant.page@5.2.0/instantpage.js" type="module"></script><script src="https://cdn.cbd.int/vanilla-lazyload@17.8.4/dist/lazyload.iife.min.js"></script><script src="https://cdn.cbd.int/node-snackbar@0.1.16/dist/snackbar.min.js"></script><canvas id="universe"></canvas><script async src="https://npm.elemecdn.com/anzhiyu-theme-static@1.0.0/dark/dark.js"></script><script>// 消除控制台打印
var HoldLog = console.log;
console.log = function () {};
let now1 = new Date();
queueMicrotask(() => {
  const Log = function () {
    HoldLog.apply(console, arguments);
  }; //在恢复前输出日志
  const grt = new Date("04/01/2023 00:00:00"); //此处修改你的建站时间或者网站上线时间
  now1.setTime(now1.getTime() + 250);
  const days = (now1 - grt) / 1000 / 60 / 60 / 24;
  const dnum = Math.floor(days);
  const ascll = [
    `欢迎使用安知鱼!`,
    `生活明朗, 万物可爱`,
    `
        
       █████╗ ███╗   ██╗███████╗██╗  ██╗██╗██╗   ██╗██╗   ██╗
      ██╔══██╗████╗  ██║╚══███╔╝██║  ██║██║╚██╗ ██╔╝██║   ██║
      ███████║██╔██╗ ██║  ███╔╝ ███████║██║ ╚████╔╝ ██║   ██║
      ██╔══██║██║╚██╗██║ ███╔╝  ██╔══██║██║  ╚██╔╝  ██║   ██║
      ██║  ██║██║ ╚████║███████╗██║  ██║██║   ██║   ╚██████╔╝
      ╚═╝  ╚═╝╚═╝  ╚═══╝╚══════╝╚═╝  ╚═╝╚═╝   ╚═╝    ╚═════╝
        
        `,
    "已上线",
    dnum,
    "天",
    "©2020 By 安知鱼 V1.6.8",
  ];
  const ascll2 = [`NCC2-036`, `调用前置摄像头拍照成功，识别为【小笨蛋】.`, `Photo captured: `, `🤪`];

  setTimeout(
    Log.bind(
      console,
      `\n%c${ascll[0]} %c ${ascll[1]} %c ${ascll[2]} %c${ascll[3]}%c ${ascll[4]}%c ${ascll[5]}\n\n%c ${ascll[6]}\n`,
      "color:#425AEF",
      "",
      "color:#425AEF",
      "color:#425AEF",
      "",
      "color:#425AEF",
      ""
    )
  );
  setTimeout(
    Log.bind(
      console,
      `%c ${ascll2[0]} %c ${ascll2[1]} %c \n${ascll2[2]} %c\n${ascll2[3]}\n`,
      "color:white; background-color:#4fd953",
      "",
      "",
      'background:url("https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/tinggge.gif") no-repeat;font-size:450%'
    )
  );

  setTimeout(Log.bind(console, "%c WELCOME %c 你好，小笨蛋.", "color:white; background-color:#4f90d9", ""));

  setTimeout(
    console.warn.bind(
      console,
      "%c ⚡ Powered by 安知鱼 %c 你正在访问 Wsk 的博客.",
      "color:white; background-color:#f0ad4e",
      ""
    )
  );

  setTimeout(Log.bind(console, "%c W23-12 %c 你已打开控制台.", "color:white; background-color:#4f90d9", ""));

  setTimeout(
    console.warn.bind(console, "%c S013-782 %c 你现在正处于监控中.", "color:white; background-color:#d9534f", "")
  );
});</script><script async src="/anzhiyu/random.js"></script><script async="async">(function () {
  var grt = new Date("04/01/2023 00:00:00"); //设置网站上线时间
  var now = new Date();
  var dnum;
  var hnum;
  var mnum;
  var snum;
  var nowHour;

  // 计算并更新天数、小时数、分钟数和秒数
  function updateTime() {
    now = new Date(); // 更新 now 的值
    nowHour = now.getHours(); // 更新 nowHour 的值
    var days = (now - grt) / 1000 / 60 / 60 / 24;
    dnum = Math.floor(days);
    var hours = (now - grt) / 1000 / 60 / 60 - 24 * dnum;
    hnum = Math.floor(hours);
    if (String(hnum).length == 1) {
      hnum = "0" + hnum;
    }
    var minutes = (now - grt) / 1000 / 60 - 24 * 60 * dnum - 60 * hnum;
    mnum = Math.floor(minutes);
    if (String(mnum).length == 1) {
      mnum = "0" + mnum;
    }
    var seconds = (now - grt) / 1000 - 24 * 60 * 60 * dnum - 60 * 60 * hnum - 60 * mnum;
    snum = Math.round(seconds);
    if (String(snum).length == 1) {
      snum = "0" + snum;
    }
  }

  // 更新网页中显示的网站运行时间
  function updateHtml() {
    const footer = document.getElementById("footer");
    if (!footer) return
    let currentTimeHtml = "";
    if (nowHour < 18 && nowHour >= 9) {
      // 如果是上班时间，默认就是"安知鱼-上班摸鱼中.svg"图片，不需要更改
      currentTimeHtml = `本站居然运行了 ${dnum} 天<span id='runtime'> ${hnum} 小时 ${mnum} 分 ${snum} 秒 </span><i class='anzhiyufont anzhiyu-icon-heartbeat' style='color:red'></i>`;
    } else {
      // 如果是下班时间，插入"安知鱼-下班啦.svg"图片
      let img = document.querySelector("#workboard .workSituationImg");
      img.src = "";
      img.title = "";
      img.alt = "";

      currentTimeHtml = `本站居然运行了 ${dnum} 天<span id='runtime'> ${hnum} 小时 ${mnum} 分 ${snum} 秒 </span><i class='anzhiyufont anzhiyu-icon-heartbeat' style='color:red'></i>`;
    }

    if (document.getElementById("runtimeTextTip")) {
      document.getElementById("runtimeTextTip").innerHTML = currentTimeHtml;
    }
  }

  setInterval(() => {
    updateTime();
    updateHtml();
  }, 1000);
})();</script><div class="js-pjax"><script>(() => {
  const initValine = () => {
    const valine = new Valine(Object.assign({
      el: '#vcomment',
      appId: '4GK2IcRZ0PX28gP4kGsW08qs-gzGzoHsz',
      appKey: 'TjKeHNK7GJrGTYuKYzGzh8yg',
      avatar: 'mp',
      serverURLs: '',
      emojiMaps: {"tv_doge":"6ea59c827c414b4a2955fe79e0f6fd3dcd515e24.png","tv_亲亲":"a8111ad55953ef5e3be3327ef94eb4a39d535d06.png","tv_偷笑":"bb690d4107620f1c15cff29509db529a73aee261.png","tv_再见":"180129b8ea851044ce71caf55cc8ce44bd4a4fc8.png","tv_冷漠":"b9cbc755c2b3ee43be07ca13de84e5b699a3f101.png","tv_发怒":"34ba3cd204d5b05fec70ce08fa9fa0dd612409ff.png","tv_发财":"34db290afd2963723c6eb3c4560667db7253a21a.png","tv_可爱":"9e55fd9b500ac4b96613539f1ce2f9499e314ed9.png","tv_吐血":"09dd16a7aa59b77baa1155d47484409624470c77.png","tv_呆":"fe1179ebaa191569b0d31cecafe7a2cd1c951c9d.png","tv_呕吐":"9f996894a39e282ccf5e66856af49483f81870f3.png","tv_困":"241ee304e44c0af029adceb294399391e4737ef2.png","tv_坏笑":"1f0b87f731a671079842116e0991c91c2c88645a.png","tv_大佬":"093c1e2c490161aca397afc45573c877cdead616.png","tv_大哭":"23269aeb35f99daee28dda129676f6e9ea87934f.png","tv_委屈":"d04dba7b5465779e9755d2ab6f0a897b9b33bb77.png","tv_害羞":"a37683fb5642fa3ddfc7f4e5525fd13e42a2bdb1.png","tv_尴尬":"7cfa62dafc59798a3d3fb262d421eeeff166cfa4.png","tv_微笑":"70dc5c7b56f93eb61bddba11e28fb1d18fddcd4c.png","tv_思考":"90cf159733e558137ed20aa04d09964436f618a1.png","tv_惊吓":"0d15c7e2ee58e935adc6a7193ee042388adc22af.png"},
      path: window.location.pathname,
      visitor: false
    }, null))
  }

  const loadValine = async () => {
    if (typeof Valine === 'function') initValine()
    else {
      await getScript('https://cdn.cbd.int/valine@1.5.1/dist/Valine.min.js')
      initValine()
    }
  }

  if ('Valine' === 'Valine' || !false) {
    if (false) anzhiyu.loadComment(document.getElementById('vcomment'),loadValine)
    else setTimeout(loadValine, 0)
  } else {
    window.loadOtherComment = loadValine
  }
})()</script><input type="hidden" name="page-type" id="page-type" value="post"></div><script src="https://cdn.cbd.int/blueimp-md5@2.19.0/js/md5.min.js"></script><script>window.addEventListener('load', () => {
  const changeContent = (content) => {
    if (content === '') return content

    content = content.replace(/<img.*?src="(.*?)"?[^\>]+>/ig, '[图片]') // replace image link
    content = content.replace(/<a[^>]+?href=["']?([^"']+)["']?[^>]*>([^<]+)<\/a>/gi, '[链接]') // replace url
    content = content.replace(/<pre><code>.*?<\/pre>/gi, '[代码]') // replace code
    content = content.replace(/<[^>]+>/g,"") // remove html tag

    if (content.length > 150) {
      content = content.substring(0,150) + '...'
    }
    return content
  }

  const getIcon = (icon, mail) => {
    if (icon) return icon
    let defaultIcon = '?d=mp'
    let iconUrl = `https://gravatar.loli.net/avatar/${md5(mail.toLowerCase()) + defaultIcon}`
    return iconUrl
  }

  const generateHtml = array => {
    let result = ''

    if (array.length) {
      for (let i = 0; i < array.length; i++) {
        result += '<div class=\'aside-list-item\'>'

        if (true) {
          const name = 'data-lazy-src'
          result += `<a href='${array[i].url}' class='thumbnail'><img ${name}='${array[i].avatar}' alt='${array[i].nick}'></a>`
        }

        result += `<div class='content'>
        <a class='comment' href='${array[i].url}' title='${array[i].content}'>${array[i].content}</a>
        <div class='name'><span>${array[i].nick} / </span><time datetime="${array[i].date}">${anzhiyu.diffDate(array[i].date, true)}</time></div>
        </div></div>`
      }
    } else {
      result += '没有评论'
    }

    let $dom = document.querySelector('#card-newest-comments .aside-list')
    $dom.innerHTML= result
    window.lazyLoadInstance && window.lazyLoadInstance.update()
    window.pjax && window.pjax.refresh($dom)
  }

  const getComment = () => {
    const serverURL = 'https://4GK2IcRZ.api.lncldglobal.com'

    var settings = {
      "method": "GET",
      "headers": {
        "X-LC-Id": '4GK2IcRZ0PX28gP4kGsW08qs-gzGzoHsz',
        "X-LC-Key": 'TjKeHNK7GJrGTYuKYzGzh8yg',
        "Content-Type": "application/json"
      },
    }

    fetch(`${serverURL}/1.1/classes/Comment?limit=6&order=-createdAt`,settings)
      .then(response => response.json())
      .then(data => {
        const valineArray = data.results.map(function (e) {
          return {
            'avatar': getIcon(e.QQAvatar, e.mail),
            'content': changeContent(e.comment),
            'nick': e.nick,
            'url': e.url + '#' + e.objectId,
            'date': e.updatedAt,
          }
        })
        saveToLocal.set('valine-newest-comments', JSON.stringify(valineArray), 10/(60*24))
        generateHtml(valineArray)
      }).catch(e => {
        const $dom = document.querySelector('#card-newest-comments .aside-list')
        $dom.textContent= "无法获取评论，请确认相关配置是否正确"
      }) 
  }

  const newestCommentInit = () => {
    if (document.querySelector('#card-newest-comments .aside-list')) {
      const data = saveToLocal.get('valine-newest-comments')
      if (data) {
        generateHtml(JSON.parse(data))
      } else {
        getComment()
      }
    }
  }

  newestCommentInit()
  document.addEventListener('pjax:complete', newestCommentInit)
})</script><script>var visitorMail = "visitor@anheyu.com";
</script><script async data-pjax src="https://cdn.cbd.int/anzhiyu-theme-static@1.0.0/waterfall/waterfall.js"></script><script src="https://lf3-cdn-tos.bytecdntp.com/cdn/expire-1-M/qrcodejs/1.0.0/qrcode.min.js"></script><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.1.9/icon/ali_iconfont_css.css"><script src="//code.tidio.co/4nifo6zdbrmyjsngh2yzxwbnlhrvshrf.js" async="async"></script><script>(() => {
  const isChatBtn = true
  const isChatHideShow = true

  if (isChatBtn) {
    let isShow = false
    const close = () => {
      window.tidioChatApi.hide()
      isShow = false
    }
    
    const open = () => {
      window.tidioChatApi.open()
      window.tidioChatApi.show()
      isShow = true
    }

    const onTidioChatApiReady = () => {
      window.tidioChatApi.hide()
      window.tidioChatApi.on("close", close)
    }
    if (window.tidioChatApi) {
      window.tidioChatApi.on("ready", onTidioChatApiReady)
    } else {
      document.addEventListener("tidioChat-ready", onTidioChatApiReady)
    }

    window.chatBtnFn = () => {
      if (!window.tidioChatApi) return
      isShow ? close() : open()
    }
  } else if (isChatHideShow) {
    window.chatBtn = {
      hide: () => {
        window.tidioChatApi && window.tidioChatApi.hide()
      },
      show: () => {
        window.tidioChatApi && window.tidioChatApi.show()
      }
    }
  }
})()</script><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.0.0/aplayer/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.cbd.int/anzhiyu-blog-static@1.0.1/js/APlayer.min.js"></script><script src="https://cdn.cbd.int/hexo-anzhiyu-music@1.0.1/assets/js/Meting2.min.js"></script><script src="https://cdn.cbd.int/pjax@0.2.8/pjax.min.js"></script><script>let pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]
var pjax = new Pjax({
  elements: 'a:not([target="_blank"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {
  // removeEventListener scroll 
  anzhiyu.removeGlobalFnEvent('pjax')
  anzhiyu.removeGlobalFnEvent('themeChange')

  document.getElementById('rightside').classList.remove('rightside-show')
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')
})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()
})

document.addEventListener('pjax:error', e => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script charset="UTF-8" src="https://cdn.cbd.int/anzhiyu-theme-static@1.1.5/accesskey/accesskey.js"></script></div><div id="popup-window"><div class="popup-window-title">通知</div><div class="popup-window-divider"></div><div class="popup-window-content"><div class="popup-tip">你好呀</div><div class="popup-link"><i class="anzhiyufont anzhiyu-icon-arrow-circle-right"></i></div></div></div></body></html>