<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no"><title>1023面试题 | 北川的个人博客</title><meta name="keywords" content="每日面试"><meta name="author" content="北川,1656473414@qq.com"><meta name="copyright" content="北川"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#f7f9fe"><meta name="mobile-web-app-capable" content="yes"><meta name="apple-touch-fullscreen" content="yes"><meta name="apple-mobile-web-app-title" content="1023面试题"><meta name="application-name" content="1023面试题"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="#f7f9fe"><meta property="og:type" content="article"><meta property="og:title" content="1023面试题"><meta property="og:url" content="https://gukeyang.github.io/posts/867c7511.html"><meta property="og:site_name" content="北川的个人博客"><meta property="og:description" content="1.为什么在重写equals方法的时候需要重写hashCode方法equals 用来判断两个对象内容是否相等，而 hashCode 是对象的散列值，主要用于哈希类容器（如 HashMap、HashSet）。 Java 的规范要求：如果两个对象通过 equals 判断相等，它们的 hashCode 必"><meta property="og:locale" content="zh-CN"><meta property="og:image" content="https://s2.loli.net/2025/10/23/wfbr2eNcL1VvXIn.png?_r_=d6c7fb12-5099-f17e-6221-88d93687f7e5"><meta property="article:author" content="北川"><meta property="article:tag" content="博客,笔记,学习"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://s2.loli.net/2025/10/23/wfbr2eNcL1VvXIn.png?_r_=d6c7fb12-5099-f17e-6221-88d93687f7e5"><meta name="description" content="1.为什么在重写equals方法的时候需要重写hashCode方法equals 用来判断两个对象内容是否相等，而 hashCode 是对象的散列值，主要用于哈希类容器（如 HashMap、HashSet）。 Java 的规范要求：如果两个对象通过 equals 判断相等，它们的 hashCode 必"><link rel="shortcut icon" href="/favicon.ico"><link rel="canonical" href="https://gukeyang.github.io/posts/867c7511"><link rel="preconnect" href="//cdn.cbd.int"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><meta name="google-site-verification" content="xxx"/><meta name="baidu-site-verification" content="code-xxx"/><meta name="msvalidate.01" content="xxx"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.cbd.int/node-snackbar@0.1.16/dist/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.cbd.int/@fancyapps/ui@5.0.20/dist/fancybox/fancybox.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://npm.elemecdn.com/anzhiyu-theme-static@1.0.0/swiper/swiper.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  linkPageTop: undefined,
  peoplecanvas: {"enable":true,"img":"https://upload-bbs.miyoushe.com/upload/2023/09/03/125766904/ee23df8517f3c3e3efc4145658269c06_5714860933110284659.png"},
  postHeadAiDescription: undefined,
  diytitle: {"enable":true,"leaveTitle":"w(ﾟДﾟ)w 不要走！再看看嘛！","backTitle":"♪(^∇^*)欢迎肥来！"},
  LA51: undefined,
  greetingBox: {"enable":true,"default":"晚上好👋","list":[{"greeting":"晚安😴","startTime":0,"endTime":5},{"greeting":"早上好鸭👋, 祝你一天好心情！","startTime":6,"endTime":9},{"greeting":"上午好👋, 状态很好，鼓励一下～","startTime":10,"endTime":10},{"greeting":"11点多啦, 在坚持一下就吃饭啦～","startTime":11,"endTime":11},{"greeting":"午安👋, 宝贝","startTime":12,"endTime":14},{"greeting":"🌈充实的一天辛苦啦！","startTime":14,"endTime":18},{"greeting":"19点喽, 奖励一顿丰盛的大餐吧🍔。","startTime":19,"endTime":19},{"greeting":"晚上好👋, 在属于自己的时间好好放松😌~","startTime":20,"endTime":24}]},
  twikooEnvId: '',
  commentBarrageConfig:{"enable":true,"maxBarrage":1,"barrageTime":4000,"accessToken":"","mailMd5":"3932F24FA213E964B6B1B0FD091F88CE"},
  root: '/',
  preloader: {"source":3},
  friends_vue_info: {"apiurl":"https://friends.anheyu.com/"},
  navMusic: true,
  mainTone: {"mode":"both","api":"https://img2color-go.vercel.app/api?img=","cover_change":true},
  authorStatus: {"skills":["🤖️ 数码科技爱好者","🔍 分享与热心帮助","🔨 设计开发一条龙","🏃 脚踏实地行动派"]},
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简","rightMenuMsgToTraditionalChinese":"转为繁体","rightMenuMsgToSimplifiedChinese":"转为简体"},
  noticeOutdate: {"limitDay":365,"position":"top","messagePrev":"It has been","messageNext":"days since the last update, the content of the article may be outdated."},
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":330},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: true,
    simplehomepage: false,
    post: true
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"copy":true,"copyrightEbable":true,"limitCount":50,"languages":{"author":"作者: 北川","link":"链接: ","source":"来源: 北川的个人博客","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。","copySuccess":"复制成功，复制和转载请标注本文地址"}},
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#425AEF","bgDark":"#1f1f1f","position":"top-center"},
  source: {
    justifiedGallery: {
      js: 'https://cdn.cbd.int/flickr-justified-gallery@2.1.2/dist/fjGallery.min.js',
      css: 'https://cdn.cbd.int/flickr-justified-gallery@2.1.2/dist/fjGallery.css'
    }
  },
  isPhotoFigcaption: true,
  islazyload: true,
  isAnchor: false,
  shortcutKey: undefined,
  autoDarkmode: true
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  configTitle: '北川的个人博客',
  title: '1023面试题',
  postAI: '',
  pageFillDescription: '1.为什么在重写equals方法的时候需要重写hashCode方法, 2什么是序列化？什么是反序列化？应用场景？, 3.抽象类和接口的应用场景, 4.java反射机制应用场景, 5.BIONIOAIO有什么区别?, 6.集合框架, 7.简述一下你了解的设计模式, 8.线程锁, 9.如何理解存储引擎, 10.数据库如何优化, 1. SQL 优化, 2. 索引优化, 3. 表结构优化, 4. 缓存优化（减轻数据库读压力）, 5. 分库分表（解决数据量过大问题）, 6. 连接池优化（提升并发效率）, 慢查询日志：定位 慢 SQL, 1. 开启与配置（以 MySQL 为例）, 2. 分析慢查询日志, 二、EXPLAIN：分析 SQL 执行计划, 1. 基本用法, 2. 核心字段解析, 3. 常见场景与优化思路, 三、结合使用：慢查询 + EXPLAIN 实战流程, 11.事务, 四大特性：ACID, 隔离级别, ACID怎么实现的?, MVCC详解, 12.谈谈你对spring的理解, 13.springboot自动配置原理, 14.redis适用场景, 1️⃣ 缓存热点数据, 2️⃣ 分布式 Session 存储, 3️⃣ 计数器 x2F 排行榜 x2F 点赞系统, 4️⃣ 分布式锁, 5️⃣ 限流（Rate Limiter）, 6️⃣ 消息队列 x2F 异步任务, 7️⃣ 地理位置服务（GEO）, 8️⃣ 布隆过滤器（防止缓存穿透）, 15.RabbitMQ工作原理, 工作流程详解, 常见使用场景为什么在重写方法的时候需要重写方法用来判断两个对象内容是否相等而是对象的散列值主要用于哈希类容器如的规范要求如果两个对象通过判断相等它们的必须相同否则哈希容器会认为它们不在同一个桶中导致查找或去重出错容器查找过程根据计算桶位置在桶内通过精确匹配若不一致根本不会调用什么是序列化什么是反序列化应用场景序列化是把对象转为字节流方便网络传输或磁盘持久化反序列化是把字节流还原为对象提供接口使用类中可定义保证版本兼容高级框架常用自定义序列化机制高性能跨语言应用场景网络通信消息队列分布式缓存如存对象对象持久化写入文件数据库抽象类和接口的应用场景维度抽象类接口定义关键字实例化不能实例化不能实例化方法类型可包含抽象方法具体方法前仅抽象方法之后支持默认方法静态方法成员变量可包含普通变量各种访问修饰符只能包含常量默认构造方法有用于子类初始化无继承实现方式子类通过单继承类通过多实现设计目的体现关系继承强调共性体现关系实现强调能力代码复用可通过具体方法复用代码前无法复用代码之后通过默认方法复用若需要代码复用属性方法实现且类之间是继承关系用抽象类例如作为抽象类是其子类宝马是一种车共享方法的基础实现若仅需定义行为规范且类之间是能力关系无继承用接口例如接口都可实现鱼有游泳能力人有游泳能力反射机制应用场景反射是运行时动态获取类的信息并能操作属性方法构造器基于对象通过等方式操作字节码元信息应用场景依赖注入动态代理自动调用测试方法框架扫描注解如有什么区别模型同步异步阻塞非阻塞特点同步阻塞每个请求一个线程同步非阻塞一个线程可处理多个连接异步非阻塞操作系统通知结果回调机制小型应用阻塞高并发服务器如极高性能需求如异步文件集合框架请简述集合框架的体系结构接口层面接口是集合框架的根接口之一定义了一组操作元素的方法如添加删除查询等它有两个重要的子接口接口有序的集合允许元素重复其实现类如等基于数组实现查询效率高增删操作尤其是在中间位置增删时效率较低基于链表实现增删操作效率高查询效率相对较低接口无序且不允许元素重复的集合常见实现类有等基于哈希表实现查询和添加效率高元素无序基于红黑树实现元素有序并且可以对元素进行排序接口用于存储键值对一个键最多映射到一个值常见实现类有等基于哈希表实现允许键和值查询和插入效率高基于红黑树实现按键的自然顺序或自定义顺序排序是线程安全的哈希表允许多个线程同时读部分线程同时写适用于高并发场景具体实现类层面是最常用的实现类内部使用数组存储元素支持随机访问通过索引访问元素的时间复杂度为但在插入和删除元素时尤其是在中间位置操作需要移动元素时间复杂度为基于双向链表实现在链表头部或尾部插入和删除元素的时间复杂度为但随机访问元素时需要从头或尾开始遍历链表时间复杂度为内部使用来存储元素将元素作为的键值使用一个固定的对象通过哈希表实现快速的插入删除和查找操作时间复杂度通常为但在哈希冲突严重时会退化为基于实现元素按照自然顺序或自定义顺序排序插入删除和查找操作的时间复杂度为因为其底层是红黑树结构使用哈希表存储键值对通过哈希函数计算键的哈希值来确定存储位置在没有哈希冲突的情况下插入删除和查找操作的时间复杂度为但当哈希冲突较多时性能会下降在中当链表长度超过一定阈值默认为时链表会转换为红黑树以提高查询性能基于红黑树实现按键的顺序对键值对进行排序插入删除和查找操作的时间复杂度为适用于需要按键排序的场景在中采用分段锁机制将哈希表分成多个段每个段有独立的锁不同段可以同时进行读写操作提高了并发性能在中采用操作和关键字结合的方式进一步提高了并发性能并且在高并发下的性能优于的版本和有什么区别在什么场景下应该选择哪个区别数据结构基于动态数组实现内部维护一个数组当数组容量不足时会进行扩容基于双向链表实现每个节点包含前驱节点后继节点和数据查询性能支持随机访问通过索引直接定位元素时间复杂度为在查询操作频繁的场景下性能较好随机访问需要从头或尾开始遍历链表时间复杂度为查询性能相对较差插入和删除性能在数组末尾插入或删除元素的时间复杂度为但在中间位置插入或删除元素时需要移动后续元素时间复杂度为在链表头部或尾部插入或删除元素的时间复杂度为在中间位置插入或删除元素时只需修改前后节点的指针时间复杂度也为内存占用由于是数组结构内存占用相对紧凑但在扩容时可能会造成一定的内存浪费每个节点除了存储数据外还需要存储前驱和后继节点的引用内存占用相对较大选择场景适用于查询操作频繁插入和删除操作主要在尾部进行的场景如数据统计报表生成等适用于插入和删除操作频繁尤其是在中间位置进行插入和删除的场景如实现栈队列等数据结构或者需要频繁对数据进行增删操作的场景的工作原理是什么它在和中有哪些主要变化工作原理以为例存储结构使用数组加链表或红黑树的结构来存储键值对数组的每个元素是一个链表或红黑树的头节点哈希计算当插入一个键值对时首先计算键的哈希值通过哈希函数将哈希值映射到数组的索引位置如果该位置没有元素则直接插入如果该位置已有元素说明发生了哈希冲突此时会将新的键值对插入到该位置的链表或红黑树中链表转红黑树当链表长度超过一定阈值默认为且数组长度大于等于时链表会转换为红黑树以提高查询性能当红黑树节点数量小于时会退化为链表扩容机制当中的元素数量达到负载因子默认为与数组容量的乘积时会进行扩容扩容后的容量是原来的倍扩容时会重新计算每个元素的哈希值并重新分配到新的数组位置和的主要变化数据结构采用数组加链表的结构所有的哈希冲突都通过链表解决在链表长度较长时引入了红黑树将链表转换为红黑树以提高查询性能哈希冲突解决方式使用头插法插入新元素到链表在多线程环境下可能会形成环形链表导致死循环使用尾插法插入新元素到链表避免了环形链表的问题扩容机制扩容时需要重新计算每个元素的哈希值并重新分配到新的数组位置性能消耗较大在扩容时对于链表节点根据哈希值与旧容量的关系判断节点是留在原位置还是移动到新位置的对应索引处部分节点不需要重新计算哈希值提高了扩容效率简述一下你了解的设计模式常用模式种中核心种单例保证唯一实例工厂解耦对象创建代理增强功能观察者事件监听策略算法可替换模板方法固定流程装饰器动态增强项目例代理模式动态代理工厂模式线程锁类型内置锁偏向锁轻量级重量级可中断公平锁可超时读写分离乐观读锁底层通过对象头实现锁状态基于请详细阐述锁从偏向锁到轻量级锁再到重量级锁的升级过程偏向锁适用场景在大多数情况下锁不仅不存在多线程竞争而且总是由同一线程多次获得偏向锁的设计就是为了在这种场景下减少不必要的锁竞争开销实现原理当一个线程访问同步块并获取锁时会在对象头的中记录下该线程的之后该线程再次进入同步块时只需检查中的线程是否与自己的一致若一致则无需进行任何同步操作直接进入同步块这大大提高了执行效率偏向锁使用操作来设置对象头中的线程升级条件当有其他线程尝试获取偏向锁时偏向锁就会升级为轻量级锁这是因为此时已经出现了多线程竞争的情况偏向锁无法再满足需求轻量级锁适用场景适用于短时间内有竞争但竞争不太激烈的场景实现原理当偏向锁升级为轻量级锁时线程会在自己的栈帧中创建一个锁记录并将对象头中的复制到锁记录中然后使用操作尝试将对象头中的替换为指向锁记录的指针如果操作成功当前线程就获得了锁如果失败表示有其他线程竞争锁轻量级锁会膨胀为重量级锁自旋机制在轻量级锁竞争过程中为了避免线程被挂起的开销会采用自旋机制即当一个线程获取锁失败时它不会立即被挂起而是在一定次数内尝试自旋等待看持有锁的线程是否会很快释放锁如果自旋一定次数后仍未获取到锁才会将线程挂起重量级锁适用场景适用于竞争激烈的场景实现原理当轻量级锁膨胀为重量级锁后锁的实现依赖于操作系统的互斥量获取锁的线程会进入内核态通过操作系统的调度来管理线程的阻塞和唤醒此时等待锁的线程会被挂起放入等待队列中当持有锁的线程释放锁时会从等待队列中唤醒一个线程来获取锁重量级锁的开销较大因为线程的挂起和唤醒需要操作系统的介入涉及用户态和内核态的切换相较于有哪些优势可中断提供了可中断的获取锁的方法如当一个线程在获取锁的过程中若其他线程调用了该线程的方法当前线程可以响应中断停止等待锁转而处理中断逻辑关键字不支持可中断的锁获取方式一旦线程进入同步块获取锁除非获取到锁或者抛出异常否则不会响应中断公平锁可以通过构造函数来设置是否为公平锁公平锁保证了等待时间最长的线程优先获取锁按照线程等待的先后顺序来分配锁避免了线程饥饿问题但公平锁的实现开销较大会降低系统的吞吐量是非公平锁它在锁可用时并不保证等待时间最长的线程优先获取锁而是随机选择一个等待线程获取锁这种方式可能导致某些线程长时间无法获取锁出现线程饥饿现象可超时提供了带超时的获取锁方法如线程在尝试获取锁时如果在指定的超时时间内没有获取到锁会返回线程可以选择执行其他操作而不是一直等待没有提供直接的超时获取锁机制一旦进入同步块等待锁就会一直等待下去直到获取到锁锁的获取与释放灵活性需要手动调用方法获取锁并且在使用完后要在块中手动调用方法释放锁这种方式提供了更大的灵活性例如可以在不同的代码块中获取和释放锁以满足复杂的业务逻辑需求是基于代码块或方法的锁的获取和释放是自动的当进入同步块或方法时获取锁退出同步块或方法时自动释放锁灵活性相对较差是如何基于实现的基于的实现概述是一个用于构建锁和同步器的框架它提供了一种基于队列来管理线程等待和唤醒的机制内部包含一个继承自的静态内部类通过来实现锁的获取和释放逻辑获取锁过程当线程调用的方法时实际上是调用了的方法对于非公平锁默认是非公平锁首先会尝试使用操作将的状态从设置为表示获取锁成功如果操作失败说明有其他线程已经持有锁此时线程会被封装成一个节点加入到的等待队列中对于公平锁线程会先判断等待队列是否为空以及当前线程是否是等待队列的第一个节点如果不是则直接将线程封装成节点加入等待队列释放锁过程当线程调用的方法时会将的状态减如果状态减为表示当前线程已经完全释放了锁此时会从等待队列中唤醒一个等待的线程如果状态不为说明当前线程还持有锁因为是可重入锁如何理解存储引擎存储引擎是数据库管理系统中负责数据存储检索更新和删除等操作的组件在数据库中常见的存储引擎有等核心引擎默认支持事务行锁外键读多写少内存表日志型区别关键以为例和存储引擎有哪些主要区别各自适用于什么场景主要区别事务支持完全支持事务遵循原则能保证数据的一致性和完整性这使得它适用于对数据一致性要求极高的场景如银行转账电子商务订单处理等业务确保在一系列操作中数据要么全部正确更新要么回滚到初始状态不支持事务这意味着在执行多个操作时如果中途出现错误无法回滚到操作前的状态但由于没有事务管理的开销在简单查询场景下性能较高锁机制支持行级锁和表级锁默认使用行级锁行级锁可以精确锁定正在操作的行减少锁争用提高并发写入性能例如在多用户同时对不同行进行修改时不会相互阻塞适用于高并发的读写操作场景只支持表级锁在对表进行写入操作时会锁定整个表其他读写操作都需要等待锁释放这在高并发写入场景下可能导致性能瓶颈因为同一时间只能有一个写入操作但在读取操作占主导且写入较少的场景下表级锁的开销相对较小索引结构采用聚簇索引数据和主键索引存储在一起这使得基于主键的查询非常快速因为可以直接定位到数据行但如果查询条件不涉及主键可能需要进行回表操作即先通过二级索引找到主键再通过主键找到数据行数据和索引是分开存储的索引文件仅保存数据记录的地址这种结构在非主键查询时可能不需要回表操作但在基于主键的查询性能上相对较弱存储文件有文件用于存储表结构定义文件用于存储数据和索引在开启独立表空间时如果是共享表空间数据和索引都存储在系统表空间文件中有文件存储表结构定义文件存储数据文件存储索引崩溃恢复能力具备崩溃恢复能力它通过日志机制如重做日志回滚日志在数据库发生崩溃后能够恢复到崩溃前的状态保证数据的完整性不具备崩溃自动恢复能力在数据库崩溃后可能需要手动修复数据文件和索引文件适用场景适用于对事务处理要求高数据一致性要求严格高并发读写的场景如电子商务系统金融系统等在这些场景中数据的准确性和并发处理能力至关重要的事务支持和行级锁机制能够满足这些需求适用于以读操作和插入操作为主对事务要求不高的场景如日志记录系统数据仓库的某些查询场景等由于其不支持事务和仅使用表级锁在简单查询场景下性能较高且存储结构相对简单占用空间较小数据库如何优化优化索引有效利用避免索引失效场景如子句中对索引列使用函数计算隐式类型转换字符串列与数字比较使用部分场景失效等优先使用过滤而非减少后续处理数据量减少子查询嵌套子查询尤其是多层嵌套可能导致低效执行计划可改用重写如将改为关联查询利用连接算法优化性能控制返回数据量避免只查询必要字段使用限制分页数据避免全表扫描返回大量结果避免事务过长长事务会锁定更多资源增加并发冲突应拆分事务为短事务减少锁持有时间索引优化联合索引设计遵循最左前缀原则将过滤性高区分度大的字段放在前面如联合索引更高效避免重复索引如已存在无需单独建覆盖索引索引包含查询所需全部字段如建索引可避免回表查数据直接从索引获取结果提升效率删除冗余低效索引频繁更新的列如不适合建索引更新会导致索引维护开销低区分度列如建索引收益低可能反而拖慢写入使用前缀索引对长字符串列如可只对前个字符建索引如减少索引存储空间表结构优化范式与反范式平衡遵循范式减少冗余如拆分大表为小表避免重复字段降低更新异常风险适当反范式如增加冗余字段合并表优化查询减少操作如订单表冗余用户姓名避免查询时关联用户表字段类型优化选择合适字段类型如用存年龄而非用存日期而非字符串减少存储空间和计算开销对长度固定的字段用可变长度用拆分大表将包含大量字段的表拆分为核心表高频访问字段和扩展表低频字段减少单表数据量和压力缓存优化减轻数据库读压力缓存热点数据将高频查询低频更新的数据如商品基本信息用户配置缓存到等内存数据库查询时先查缓存未命中再查数据库并更新缓存缓存策略设计设置合理过期时间避免缓存雪崩大量同时过期采用缓存穿透防护如布隆过滤器过滤无效处理缓存与数据库一致性如更新数据库后同步更新缓存或采用延迟双删读写分离配合缓存主库写入从库读数据并同步到缓存进一步分流主库压力分库分表解决数据量过大问题垂直拆分按业务维度拆分如电商系统拆分为用户库订单库商品库降低单库压力便于独立扩展水平拆分按数据维度拆分大表如订单表按时间范围拆分为或按用户哈希拆分为到减少单表数据量建议单表控制在千万级以内提升查询效率路由策略通过中间件如自动路由请求到目标分库分表简化业务层逻辑连接池优化提升并发效率选择高性能连接池如轻量高效相比有更低的合理配置参数最大连接数根据并发量设置不宜过大避免数据库连接耗尽最小空闲连接数保证基础并发需求避免频繁创建连接连接超时时间避免线程长期阻塞避免连接泄露确保连接使用后正确关闭推荐语法释放资源底层慢查询日志分析执行计划慢查询日志定位慢慢查询日志用于记录执行时间超过指定阈值的语句帮助发现耗时较长的查询开启与配置以为例开启慢查询日志在或中配置开启慢查询日志为开启为关闭日志文件路径慢查询阈值单位秒默认秒建议根据业务设为秒记录未使用索引的查询即使未超阈值可选重启生效或动态生效查看配置分析慢查询日志直接查看日志内容日志会记录执行时间锁等待时间扫描行数等关键信息例如关键指标执行时间超过才记录扫描行数远大于说明低效可能未用索引锁等待时间过长可能存在并发冲突工具分析日志量大时用自带或汇总分析统计最耗时的条二分析执行计划找到慢查询后用或部分数据库支持查看优化器生成的执行计划判断是否高效利用索引是否全表扫描等基本用法在前加例如输出结果包含列核心关注以下字段核心字段解析字段含义与关键值访问类型最重要指标从优到差目标至少达到最好或表示全表扫描需优化实际使用的索引表示未用索引索引使用的长度越长说明使用的索引字段越多需结合联合索引最左前缀原则判断预估扫描行数值越小越好需与实际数据量对比额外信息关键优化依据覆盖索引优秀无需回表用索引过滤并覆盖查询需额外排序未用索引排序低效使用临时表如未用索引低效连接未用索引需优化关联条件常见场景与优化思路场景全表扫描原因条件未命中索引或索引失效如函数操作隐式转换优化添加合适索引或修改避免索引失效如改为并建索引场景原因字段未用索引导致内存磁盘排序优化将排序字段加入联合索引如建索引场景原因未用索引需创建临时表存储中间结果优化将分组字段加入索引如建单列索引或包含的联合索引场景但原因可能使用了索引但未显示极少或条件未命中有效索引优化检查条件如是否可通过索引覆盖调整索引字段顺序三结合使用慢查询实战流程开启慢查询日志收集一段时间如天的慢用工具筛选出高频高耗时的如排序对目标执行分析等字段定位问题如全表扫描未用索引排序低效针对性优化若未用索引添加合适索引联合索引覆盖索引若索引失效修改避免函数隐式转换若排序分组低效优化索引包含排序分组字段验证优化效果重新执行对比执行时间再次用确认执行计划改善事务数据库事务是由一系列数据库操作组成的逻辑单元这些操作要么全部成功执行要么全部不执行是一个不可分割的整体四大特性原子性事务中的所有操作要么全部成功提交要么全部失败回滚一致性事务执行前后数据库的完整性约束如主键约束外键约束数据类型约束等必须保持一致隔离性多个事务并发执行时一个事务的执行不能被其他事务干扰不同事务之间的数据相互隔离每个事务都感觉不到其他事务的存在持久性一旦事务提交成功对数据库所做的更改将永久保存即使系统发生故障如停电系统崩溃等这些更改也不会丢失隔离级别读未提交隔离级别描述在这种隔离级别下一个事务可以读取到另一个未提交事务修改的数据这是最低的隔离级别几乎没有提供任何隔离保护可能产生的并发问题脏读一个事务读取到另一个未提交事务修改的数据例如事务修改了某条数据但还未提交此时事务读取了这条被修改的数据如果事务随后回滚事务读取到的数据就是无效的脏数据这可能导致业务逻辑错误读已提交隔离级别描述一个事务只能读取到另一个已提交事务修改的数据这是大多数数据库的默认隔离级别可能产生的并发问题不可重复读在一个事务内多次读取同一数据时由于其他事务在期间对该数据进行了修改并提交导致每次读取到的数据不一致例如事务在开始时读取了某条数据之后事务修改并提交了这条数据当事务再次读取时得到的数据与第一次读取的不同这可能会影响事务的业务逻辑可重复读隔离级别描述在一个事务内多次读取同一数据时其他事务不能修改该数据直到当前事务结束它保证了在同一事务内多次读取的数据是一致的可能产生的并发问题幻读在一个事务内按照相同的查询条件多次读取数据时由于其他事务插入了符合查询条件的新数据导致每次读取到的数据行数不同例如事务按照某个条件查询数据得到了一定数量的结果集之后事务插入了一些符合该条件的新数据并提交当事务再次按照相同条件查询时得到的结果集行数增加了就好像出现了幻影数据虽然可重复读保证了已读取数据的一致性但无法防止新数据的插入导致结果集的变化串行化隔离级别描述这是最高的隔离级别所有事务依次串行执行即一个事务执行完后另一个事务才能开始执行它通过强制事务排队避免了所有的并发问题优点和缺点优点能够确保数据的高度一致性完全避免了脏读不可重复读和幻读等并发问题缺点由于所有事务是串行执行的性能较低在高并发场景下可能会导致大量事务等待严重影响系统的并发处理能力怎么实现的原子性的实现日志记录数据库使用日志来记录事务执行过程中的所有操作以的存储引擎为例它有重做日志和回滚日志当事务执行时每一个修改操作都会先记录到日志中比如在执行一个插入操作时会记录插入的数据以及相关的元数据到日志如果事务执行过程中出现故障数据库可以根据回滚日志撤销未完成事务对数据的修改确保事务的原子性回滚日志记录了数据修改前的版本通过逆向操作如反向的插入更新或删除将数据恢复到事务开始前的状态事务状态跟踪数据库系统会跟踪事务的状态通常分为活动部分提交失败中止和提交等状态在事务执行期间它处于活动状态当所有操作都成功完成事务进入部分提交状态此时数据库会将日志持久化到存储设备这一步确保即使系统崩溃已完成的操作也不会丢失如果在这之后没有发生故障事务就会提交状态变为提交若在事务执行过程中任何一步出现错误事务进入失败状态然后利用回滚日志进行回滚操作将事务状态变为中止从而保证事务要么全部成功要么全部失败一致性的实现完整性约束数据库通过定义和强制实施各种完整性约束来保证一致性常见的完整性约束包括实体完整性如主键约束确保表中每一行数据的唯一性参照完整性如外键约束保证不同表之间数据的一致性和用户定义完整性如检查约束根据业务规则对数据进行限制例如在一个订单系统中订单表和客户表通过客户建立关联订单表中的客户作为外键参照客户表的主键当插入一条新订单记录时数据库会检查外键约束确保该客户在客户表中存在否则插入操作将失败以此保证数据的一致性事务的正确执行原子性隔离性和持久性是保证一致性的基础原子性确保事务要么全部执行要么全部不执行避免数据处于部分修改的不一致状态隔离性防止并发事务之间的干扰保证每个事务看到的数据是一致的持久性确保已提交事务对数据的修改是永久性的不会因系统故障而丢失只有这几个特性都满足才能保证数据库在事务执行前后处于一致状态例如在银行转账事务中原子性保证了扣款和入账操作要么都成功要么都失败隔离性确保在转账过程中其他并发事务不会干扰该转账操作的数据读取和修改持久性保证了转账成功后账户余额的改变是永久性的从而维持了整个银行账户系统数据的一致性隔离性的实现锁机制数据库使用锁来控制并发事务对数据的访问锁可以分为共享锁锁和排他锁锁共享锁允许多个事务同时读取数据但不允许其他事务对数据进行修改排他锁则阻止其他事务对数据进行任何读写操作例如当一个事务对某条数据获取了排他锁其他事务就不能再获取该数据的任何锁直到排他锁被释放不同的隔离级别对锁的使用策略不同在读未提交隔离级别下几乎不使用锁所以可能会出现脏读在读已提交隔离级别下读取数据时会获取共享锁但数据读完后锁就会释放这可能导致不可重复读在可重复读隔离级别下读取数据时获取的共享锁会保持到事务结束从而避免不可重复读在串行化隔离级别下会对所有操作的数据获取排他锁保证事务串行执行避免所有并发问题多版本并发控制许多数据库系统如的存储引擎采用来实现隔离性通过维护数据的多个版本来避免锁争用提高并发性能当一个事务修改数据时会创建一个新版本的数据并记录旧版本数据的指针读取操作时根据事务的隔离级别和数据版本号来决定读取哪个版本的数据例如在可重复读隔离级别下事务在开始时会获取一个一致性视图在整个事务期间所有的读取操作都基于这个视图读取到的数据版本是事务开始时的数据版本即使其他事务对数据进行了修改也不会影响当前事务的读取结果从而避免了不可重复读和幻读问题持久性的实现日志持久化重做日志在保证持久性方面起着关键作用在事务执行过程中修改操作的日志记录会不断写入重做日志文件当事务提交时数据库会确保重做日志已经持久化到稳定存储设备如磁盘即使系统发生崩溃在重启后数据库可以根据重做日志中的记录重新执行已提交事务的操作将数据恢复到崩溃前的状态例如在中存储引擎通过将重做日志写入磁盘的方式来保证持久性重做日志采用循环写的方式空间使用完后会覆盖旧的日志但在事务提交前会确保相关的日志已经写入到磁盘并且在系统崩溃恢复时会按照日志记录的顺序重新应用这些操作从而保证已提交事务对数据的修改是永久性的检查点机制为了减少系统崩溃恢复的时间数据库引入了检查点机制检查点是数据库系统在某个时刻将内存中已修改的数据页脏页刷新到磁盘的操作在检查点之后重做日志中记录的操作都是在检查点之后发生的当系统崩溃恢复时只需要从检查点开始应用重做日志而不需要从头开始大大缩短了恢复时间例如的存储引擎会定期执行检查点操作将脏页刷新到磁盘同时记录检查点的位置在恢复时从记录的检查点位置开始读取重做日志并应用其中的操作确保数据的持久性详解的基本概念与原理概念多版本并发控制是一种用于数据库管理系统的并发控制机制它允许数据库在高并发环境下不同事务能同时访问和修改数据同时保证数据的一致性的核心思想是通过维护数据的多个版本使得读写操作可以在不同版本的数据上进行减少锁的使用从而提高系统的并发性能原理版本链的维护当数据被修改时数据库会创建数据的新版本并记录旧版本数据的指针从而形成版本链例如在的存储引擎中每行数据除了实际的数据内容外还包含隐藏的列如记录修改该数据的事务和指向回滚段中旧版本数据的指针假设初始数据为事务对其进行修改为此时会记录的旧版本指针事务再对修改为又会记录的旧版本指针这样就形成了一条版本链一致性视图的生成每个事务在启动时会生成一个一致性视图该视图记录了当前系统中活跃的事务列表一致性视图用于确定事务在读取数据时应该看到哪个版本的数据在事务执行过程中它只能看到在一致性视图生成之前提交的事务对数据的修改而看不到在一致性视图生成之后开始的事务对数据的修改谈谈你对的理解是一个开源的轻量级应用框架旨在简化企业级应用的开发核心思想控制反转面向切面编程负责创建和管理对象让程序员不用手动而是由容器统一控制对象的创建与依赖注入负责动态增强行为在不修改源码的前提下对方法进行横切逻辑增强例如日志事务权限监控等原理注解反射创建依赖注入配置阶段通过或注解如扫描定义信息解析阶段将这些配置信息封装成对象描述的结构与依赖关系实例化阶段或根据使用反射创建实例依赖注入阶段通过反射或实现属性注入生命周期管理初始化前后可被拦截例如动态代理就在这里织入原理动态代理增强方法的底层关键在于动态代理机制两种主要方式动态代理基于接口使用在运行时生成代理类适用于有接口的目标类动态代理基于继承利用字节码技术在运行时创建目标类的子类实现方法拦截增强适用于无接口类织入时机在初始化的后置处理阶段判断该是否需要增强如果需要就为其生成代理对象替换原始自动配置原理核心机制加载条件装配注册到容器以下是整个执行过程的关键节点顺序启动容器含有加载自动配置类从或加载候选类条件注解过滤不匹配的配置类解析配置类并注册容器实例化自动配置生效适用场景缓存热点数据场景系统中访问频率高变动少的数据如商品详情页信息用户登录态文章列表页缓存为什么适合内存读写速度极快减少数据库压力结合过期时间自动淘汰冷数据延伸可搭配双写一致性缓存穿透击穿雪崩防护策略分布式存储场景集群部署下共享问题传统存在单点问题保存在内存中多个实例间无法共享解法将数据集中存入所有应用实例都可共享访问可设置过期时间实现自动失效计数器排行榜点赞系统场景文章浏览量点赞量统计实时排行榜如游戏积分榜使用结构原子自增带权重排序优势支持原子操作线程安全通过实现动态实时排行分布式锁场景控制多节点并发访问同一资源例如秒杀系统防止超卖定时任务防止重复执行实现方式使用实现原子加锁仅当不存在时设置过期时间解锁时使用脚本防止误删别人的锁或使用提供的可重入锁机制限流场景防止接口被刷恶意请求控制用户访问频率如秒只能请求次实现方式利用过期时间或使用存时间戳实现滑动窗口算法示例消息队列异步任务场景异步解耦下单发短信发票简易队列任务调度实现结构用实现队列更强的消息流模型对比更轻量运维简单但不保证严格可靠投递非强一致地理位置服务场景附近的人店铺司机匹配限制范围内搜索如公里内实现方式天安门底层原理基于实现布隆过滤器防止缓存穿透场景防止恶意请求访问不存在的数据导致数据库压力过大实现方式用的或用哈希函数快速判断是否可能存在延伸高可用方案主从复制工作原理模型生产者交换机队列消费者交换机类型点对点广播通配符头匹配可靠性消息确认机制持久化死信队列延迟队列工作流程详解建立连接与建立连接后会通过信道进行通信是轻量级的通信通道一个连接上可以复用多个提高性能发送消息将消息交给并指定名称用于路由消息内容以及一些属性如持久化过期时间优先级等消息路由根据自己的类型的规则将消息路由到一个或多个队列消息存储接收到消息后根据配置可能会存入内存默认持久化到磁盘防止宕机丢失延迟投递使用插件或实现消费者订阅订阅队列后会推送消息给消费者可以手动确认也可以自动确认消息确认机制消费者处理成功后告诉可以删除该消息表示消息处理失败可以选择重新入队或丢弃未确认的消息如果断开连接会重新投递常见使用场景异步解耦下单后异步发送短信邮件不影响主流程流量削峰高并发下单场景如秒杀将请求先放入队列后台慢慢处理消息广播通过交换机实现多系统同步通知延迟任务延迟关闭订单延迟发送优惠券等日志收集与监控将分布式日志统一收集异步处理',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2025-10-27 11:55:14',
  postMainColor: '',
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#18171d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#f7f9fe')
        }
      }
      const t = saveToLocal.get('theme')
    
          const isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
          const isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
          const isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
          const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

          if (t === undefined) {
            if (isLightMode) activateLightMode()
            else if (isDarkMode) activateDarkMode()
            else if (isNotSpecified || hasNoSupport) {
              const now = new Date()
              const hour = now.getHours()
              const isNight = hour <= 6 || hour >= 18
              isNight ? activateDarkMode() : activateLightMode()
            }
            window.matchMedia('(prefers-color-scheme: dark)').addListener(e => {
              if (saveToLocal.get('theme') === undefined) {
                e.matches ? activateDarkMode() : activateLightMode()
              }
            })
          } else if (t === 'light') activateLightMode()
          else activateDarkMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.3.0"></head><body data-type="anzhiyu"><div id="web_bg"></div><div id="an_music_bg"></div><div id="loading-box" onclick="document.getElementById(&quot;loading-box&quot;).classList.add(&quot;loaded&quot;)"><div class="loading-bg"><img class="loading-img nolazyload" alt="加载头像" src="https://s2.loli.net/2022/11/07/QVWvrnAsuGxelbS.jpg"/><div class="loading-image-dot"></div></div></div><script>const preloader = {
  endLoading: () => {
    document.getElementById('loading-box').classList.add("loaded");
  },
  initLoading: () => {
    document.getElementById('loading-box').classList.remove("loaded")
  }
}
window.addEventListener('load',()=> { preloader.endLoading() })
setTimeout(function(){preloader.endLoading();},10000)

if (true) {
  document.addEventListener('pjax:send', () => { preloader.initLoading() })
  document.addEventListener('pjax:complete', () => { preloader.endLoading() })
}</script><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.1.10/progress_bar/progress_bar.css"/><script async="async" src="https://cdn.cbd.int/pace-js@1.2.4/pace.min.js" data-pace-options="{ &quot;restartOnRequestAfter&quot;:false,&quot;eventLag&quot;:false}"></script><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><div id="nav-group"><span id="blog_name"><a id="site-name" href="/" accesskey="h"><div class="title">北川的个人博客</div><i class="anzhiyufont anzhiyu-icon-house-chimney"></i></a></span><div class="mask-name-container"><div id="name-container"><a id="page-name" href="javascript:anzhiyu.scrollToDest(0, 500)">PAGE_NAME</a></div></div><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 文章</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/archives/"><i class="anzhiyufont anzhiyu-icon-box-archive faa-tada" style="font-size: 0.9em;"></i><span> 隧道</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/categories/"><i class="anzhiyufont anzhiyu-icon-shapes faa-tada" style="font-size: 0.9em;"></i><span> 分类</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/tags/"><i class="anzhiyufont anzhiyu-icon-tags faa-tada" style="font-size: 0.9em;"></i><span> 标签</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 友链</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/link/"><i class="anzhiyufont anzhiyu-icon-link faa-tada" style="font-size: 0.9em;"></i><span> 友人帐</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/fcircle/"><i class="anzhiyufont anzhiyu-icon-artstation faa-tada" style="font-size: 0.9em;"></i><span> 朋友圈</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/comments/"><i class="anzhiyufont anzhiyu-icon-envelope faa-tada" style="font-size: 0.9em;"></i><span> 留言板</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 我的</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/music/?id=2898229193&amp;server=netease"><i class="anzhiyufont anzhiyu-icon-music faa-tada" style="font-size: 0.9em;"></i><span> 音乐馆</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/album/"><i class="anzhiyufont anzhiyu-icon-images faa-tada" style="font-size: 0.9em;"></i><span> 相册集</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/air-conditioner/"><i class="anzhiyufont anzhiyu-icon-fan faa-tada" style="font-size: 0.9em;"></i><span> 小空调</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 关于</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/about/"><i class="anzhiyufont anzhiyu-icon-paper-plane faa-tada" style="font-size: 0.9em;"></i><span> 关于本人</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/essay/"><i class="anzhiyufont anzhiyu-icon-lightbulb faa-tada" style="font-size: 0.9em;"></i><span> 闲言碎语</span></a></li></ul></div></div></div><div id="nav-right"><div class="nav-button" id="randomPost_button"><a class="site-page" onclick="toRandomPost()" title="随机前往一个文章" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-dice"></i></a></div><input id="center-console" type="checkbox"/><label class="widget" for="center-console" title="中控台" onclick="anzhiyu.switchConsole();"><i class="left"></i><i class="widget center"></i><i class="widget right"></i></label><div id="console"><div class="console-card-group-reward"><ul class="reward-all console-card"><li class="reward-item"><a href="/./img/wechat.jpg" target="_blank"><img class="post-qr-code-img" alt="微信" src="/./img/wechat.jpg"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="/./img/alipay.jpg" target="_blank"><img class="post-qr-code-img" alt="支付宝" src="/./img/alipay.jpg"/></a><div class="post-qr-code-desc">支付宝</div></li></ul></div><div class="console-card-group"><div class="console-card-group-left"><div class="console-card" id="card-newest-comments"><div class="card-content"><div class="author-content-item-tips">互动</div><span class="author-content-item-title"> 最新评论</span></div><div class="aside-list"><span>正在加载中...</span></div></div></div><div class="console-card-group-right"><div class="console-card tags"><div class="card-content"><div class="author-content-item-tips">兴趣点</div><span class="author-content-item-title">寻找你感兴趣的领域</span><div class="card-tags"><div class="item-headline"></div><div class="card-tag-cloud"><a href="/tags/JVM%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/" style="font-size: 1.05rem;">JVM内存模型<sup>1</sup></a><a href="/tags/JVM%E8%B0%83%E4%BC%98/" style="font-size: 1.05rem;">JVM调优<sup>1</sup></a><a href="/tags/java%E6%95%99%E7%A8%8B/" style="font-size: 1.05rem;">java教程<sup>1</sup></a><a href="/tags/mysql/" style="font-size: 1.05rem;">mysql<sup>1</sup></a><a href="/tags/%E5%87%BD%E6%95%B0/" style="font-size: 1.05rem;">函数<sup>1</sup></a><a href="/tags/%E5%8F%8D%E5%B0%84/" style="font-size: 1.05rem;">反射<sup>1</sup></a><a href="/tags/%E5%A4%8D%E4%B9%A0/" style="font-size: 1.05rem;">复习<sup>1</sup></a><a href="/tags/%E5%A4%8D%E4%B9%A0-%E5%8F%98%E9%87%8F/" style="font-size: 1.05rem;">复习 变量<sup>1</sup></a><a href="/tags/%E5%B7%A5%E5%85%B7/" style="font-size: 1.05rem;">工具<sup>1</sup></a><a href="/tags/%E5%B9%B6%E5%8F%91/" style="font-size: 1.05rem;">并发<sup>1</sup></a><a href="/tags/%E6%83%85%E6%84%9F/" style="font-size: 1.05rem;">情感<sup>1</sup></a><a href="/tags/%E6%8A%BD%E8%B1%A1%E7%B1%BB-%E6%8E%A5%E5%8F%A3/" style="font-size: 1.05rem;">抽象类 接口<sup>1</sup></a><a href="/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/" style="font-size: 1.05rem;">数据库<sup>1</sup></a><a href="/tags/%E6%AF%8F%E6%97%A5%E9%9D%A2%E8%AF%95/" style="font-size: 1.05rem;">每日面试<sup>2</sup></a><a href="/tags/%E7%94%B5%E5%95%86-%E8%AE%A2%E5%8D%95/" style="font-size: 1.05rem;">电商,订单<sup>1</sup></a><a href="/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" style="font-size: 1.05rem;">设计模式<sup>1</sup></a><a href="/tags/%E8%B6%85%E5%8D%96-%E5%BA%93%E5%AD%98/" style="font-size: 1.05rem;">超卖 , 库存<sup>1</sup></a><a href="/tags/%E9%9B%86%E5%90%88/" style="font-size: 1.05rem;">集合<sup>1</sup></a></div></div><hr/></div></div><div class="console-card history"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-box-archiv"></i><span>文章</span></div><div class="card-archives"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-archive"></i><span>归档</span></div><ul class="card-archive-list"><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2025/10/"><span class="card-archive-list-date">十月 2025</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">9</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2025/04/"><span class="card-archive-list-date">四月 2025</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">4</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2023/10/"><span class="card-archive-list-date">十月 2023</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">3</span><span>篇</span></div></a></li></ul></div><hr/></div></div></div><div class="button-group"><div class="console-btn-item"><a class="darkmode_switchbutton" title="显示模式切换" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-moon"></i></a></div><div class="console-btn-item" id="consoleHideAside" onclick="anzhiyu.hideAsideBtn()" title="边栏显示控制"><a class="asideSwitch"><i class="anzhiyufont anzhiyu-icon-arrows-left-right"></i></a></div><div class="console-btn-item on" id="consoleCommentBarrage" onclick="anzhiyu.switchCommentBarrage()" title="热评开关"><a class="commentBarrage"><i class="anzhiyufont anzhiyu-icon-message"></i></a></div><div class="console-btn-item" id="consoleMusic" onclick="anzhiyu.musicToggle()" title="音乐开关"><a class="music-switch"><i class="anzhiyufont anzhiyu-icon-music"></i></a></div></div><div class="console-mask" onclick="anzhiyu.hideConsole()" href="javascript:void(0);"></div></div><div class="nav-button" id="nav-totop"><a class="totopbtn" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i><span id="percent" onclick="anzhiyu.scrollToDest(0,500)">0</span></a></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);" title="切换"><i class="anzhiyufont anzhiyu-icon-bars"></i></a></div></div></div></nav><div id="post-info"><div id="post-firstinfo"><div class="meta-firstline"><a class="post-meta-original">原创</a><span class="post-meta-categories"><span class="post-meta-separator"></span><i class="anzhiyufont anzhiyu-icon-inbox post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E9%9D%A2%E8%AF%95%E9%A2%98/" itemprop="url">面试题</a></span><span class="article-meta tags"><a class="article-meta__tags" href="/tags/%E6%AF%8F%E6%97%A5%E9%9D%A2%E8%AF%95/" tabindex="-1" itemprop="url"> <span> <i class="anzhiyufont anzhiyu-icon-hashtag"></i>每日面试</span></a></span></div></div><h1 class="post-title" itemprop="name headline">1023面试题</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="anzhiyufont anzhiyu-icon-calendar-days post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" itemprop="dateCreated datePublished" datetime="2025-10-23T04:23:36.000Z" title="发表于 2025-10-23 12:23:36">2025-10-23</time><span class="post-meta-separator"></span><i class="anzhiyufont anzhiyu-icon-history post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" itemprop="dateCreated datePublished" datetime="2025-10-27T03:55:14.482Z" title="更新于 2025-10-27 11:55:14">2025-10-27</time></span></div><div class="meta-secondline"><span class="post-meta-separator"></span><span class="post-meta-pv-cv" id="" data-flag-title="1023面试题"><i class="anzhiyufont anzhiyu-icon-fw-eye post-meta-icon"></i><span class="post-meta-label" title="阅读量">阅读量:</span><span id="busuanzi_value_page_pv"><i class="anzhiyufont anzhiyu-icon-spinner anzhiyu-spin"></i></span></span><span class="post-meta-separator">       </span><span class="post-meta-position" title="作者IP属地为新乡"><i class="anzhiyufont anzhiyu-icon-location-dot"></i>新乡</span><span class="post-meta-separator"></span><span class="post-meta-commentcount"><i class="anzhiyufont anzhiyu-icon-comments post-meta-icon"></i><span class="post-meta-label">评论数:</span><a href="/posts/867c7511.html#post-comment" itemprop="discussionUrl"><span class="valine-comment-count" data-xid="/posts/867c7511.html" itemprop="commentCount"><i class="anzhiyufont anzhiyu-icon-spinner anzhiyu-spin"></i></span></a></span></div></div></div><section class="main-hero-waves-area waves-area"><svg class="waves-svg" xmlns="http://www.w3.org/2000/svg" xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M -160 44 c 30 0 58 -18 88 -18 s 58 18 88 18 s 58 -18 88 -18 s 58 18 88 18 v 44 h -352 Z"></path></defs><g class="parallax"><use href="#gentle-wave" x="48" y="0"></use><use href="#gentle-wave" x="48" y="3"></use><use href="#gentle-wave" x="48" y="5"></use><use href="#gentle-wave" x="48" y="7"></use></g></svg></section><div id="post-top-cover"><img class="nolazyload" id="post-top-bg" src="https://s2.loli.net/2025/10/23/wfbr2eNcL1VvXIn.png?_r_=d6c7fb12-5099-f17e-6221-88d93687f7e5"></div></header><main id="blog-container"><div class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container" itemscope itemtype="https://gukeyang.github.io/posts/867c7511.html"><header><a class="post-meta-categories" href="/categories/%E9%9D%A2%E8%AF%95%E9%A2%98/" itemprop="url">面试题</a><a href="/tags/%E6%AF%8F%E6%97%A5%E9%9D%A2%E8%AF%95/" tabindex="-1" itemprop="url">每日面试</a><h1 id="CrawlerTitle" itemprop="name headline">1023面试题</h1><span itemprop="author" itemscope itemtype="http://schema.org/Person">北川</span><time itemprop="dateCreated datePublished" datetime="2025-10-23T04:23:36.000Z" title="发表于 2025-10-23 12:23:36">2025-10-23</time><time itemprop="dateCreated datePublished" datetime="2025-10-27T03:55:14.482Z" title="更新于 2025-10-27 11:55:14">2025-10-27</time></header><h2 id="1-为什么在重写equals方法的时候需要重写hashCode方法"><a href="#1-为什么在重写equals方法的时候需要重写hashCode方法" class="headerlink" title="1.为什么在重写equals方法的时候需要重写hashCode方法"></a>1.为什么在重写equals方法的时候需要重写hashCode方法</h2><p><code>equals</code> 用来判断两个对象内容是否相等，而 <code>hashCode</code> 是对象的散列值，主要用于哈希类容器（如 <code>HashMap</code>、<code>HashSet</code>）。</p>
<p>Java 的规范要求：如果两个对象通过 <code>equals</code> 判断相等，它们的 <code>hashCode</code> 必须相同。否则，哈希容器会认为它们不在同一个桶中，导致查找或去重出错。</p>
<p>Hash 容器查找过程：</p>
<ol>
<li>根据 <code>hashCode()</code> 计算桶位置。</li>
<li>在桶内通过 <code>equals()</code> 精确匹配。<br> 若 hash 不一致，根本不会调用 equals。</li>
</ol>
<h2 id="2什么是序列化？什么是反序列化？应用场景？"><a href="#2什么是序列化？什么是反序列化？应用场景？" class="headerlink" title="2什么是序列化？什么是反序列化？应用场景？"></a>2什么是序列化？什么是反序列化？应用场景？</h2><p>序列化（Serialization）是把对象转为字节流，方便网络传输或磁盘持久化；反序列化（Deserialization）是把字节流还原为对象。</p>
<p>Java 提供 <code>Serializable</code> 接口，使用 <code>ObjectOutputStream</code> &#x2F; <code>ObjectInputStream</code>。<br> 类中可定义 <code>serialVersionUID</code> 保证版本兼容。<br> 高级框架常用 <strong>自定义序列化机制</strong>：</p>
<ul>
<li>JSON（Jackson、Fastjson）</li>
<li>Kryo（高性能）</li>
<li>Protobuf（跨语言）</li>
</ul>
<p><strong>应用场景：</strong></p>
<ol>
<li>网络通信（RPC、消息队列）</li>
<li>分布式缓存（如 Redis 存对象）</li>
<li>Java 对象持久化（写入文件、数据库）</li>
</ol>
<h2 id="3-抽象类和接口的应用场景"><a href="#3-抽象类和接口的应用场景" class="headerlink" title="3.抽象类和接口的应用场景"></a>3.抽象类和接口的应用场景</h2><table>
<thead>
<tr>
<th>维度</th>
<th>抽象类（Abstract Class）</th>
<th>接口（Interface）</th>
</tr>
</thead>
<tbody><tr>
<td>定义关键字</td>
<td><code>abstract class</code></td>
<td><code>interface</code></td>
</tr>
<tr>
<td>实例化</td>
<td>不能实例化</td>
<td>不能实例化</td>
</tr>
<tr>
<td>方法类型</td>
<td>可包含抽象方法、具体方法</td>
<td>Java 8 前：仅抽象方法；之后：支持默认方法、静态方法</td>
</tr>
<tr>
<td>成员变量</td>
<td>可包含普通变量（各种访问修饰符）</td>
<td>只能包含常量（默认 <code>public static final</code>）</td>
</tr>
<tr>
<td>构造方法</td>
<td>有（用于子类初始化）</td>
<td>无</td>
</tr>
<tr>
<td>继承 &#x2F; 实现方式</td>
<td>子类通过 <code>extends</code> 单继承</td>
<td>类通过 <code>implements</code> 多实现</td>
</tr>
<tr>
<td>设计目的</td>
<td>体现 “is-a” 关系（继承，强调共性）</td>
<td>体现 “has-a” 关系（实现，强调能力）</td>
</tr>
<tr>
<td>代码复用</td>
<td>可通过具体方法复用代码</td>
<td>Java 8 前无法复用代码；之后通过默认方法复用</td>
</tr>
</tbody></table>
<ol>
<li><strong>若需要代码复用（属性、方法实现），且类之间是 “is-a” 继承关系</strong> → 用抽象类。例如：<code>Car</code> 作为抽象类，<code>BMW</code>、<code>Tesla</code> 是其子类（“宝马是一种车”），共享 <code>run()</code> 方法的基础实现。</li>
<li><strong>若仅需定义行为规范，且类之间是 “has-a” 能力关系（无继承）</strong> → 用接口。例如：<code>Swimmable</code> 接口，<code>Fish</code>、<code>Duck</code>、<code>Human</code> 都可实现（“鱼有游泳能力”“人有游泳能力”）。</li>
</ol>
<h2 id="4-java反射机制，应用场景"><a href="#4-java反射机制，应用场景" class="headerlink" title="4.java反射机制，应用场景"></a>4.java反射机制，应用场景</h2><p>反射是运行时动态获取类的信息，并能操作属性、方法、构造器。</p>
<p>基于 <code>Class</code> 对象，通过 <code>Method.invoke()</code>、<code>Field.set()</code> 等方式操作字节码元信息。</p>
<p><strong>应用场景：</strong></p>
<ul>
<li>Spring IOC（依赖注入）</li>
<li>MyBatis（动态代理 Mapper）</li>
<li>JUnit（自动调用测试方法）</li>
<li>框架扫描注解（如 <code>@Controller</code>、<code>@Service</code>）</li>
</ul>
<h2 id="5-BIO-NIO-AIO有什么区别"><a href="#5-BIO-NIO-AIO有什么区别" class="headerlink" title="5.BIO,NIO,AIO有什么区别?"></a>5.BIO,NIO,AIO有什么区别?</h2><table>
<thead>
<tr>
<th>模型</th>
<th>同步&#x2F;异步</th>
<th>阻塞&#x2F;非阻塞</th>
<th>特点</th>
</tr>
</thead>
<tbody><tr>
<td>BIO</td>
<td>同步</td>
<td>阻塞</td>
<td>每个请求一个线程</td>
</tr>
<tr>
<td>NIO</td>
<td>同步</td>
<td>非阻塞</td>
<td>一个线程可处理多个连接（Selector）</td>
</tr>
<tr>
<td>AIO</td>
<td>异步</td>
<td>非阻塞</td>
<td>操作系统通知结果（回调机制）</td>
</tr>
</tbody></table>
<p>BIO：小型应用、阻塞 I&#x2F;O</p>
<p>NIO：高并发服务器（如 Netty）</p>
<p>AIO：极高性能需求（如异步文件 I&#x2F;O）</p>
<h2 id="6-集合框架"><a href="#6-集合框架" class="headerlink" title="6.集合框架"></a>6.集合框架</h2><ol>
<li>请简述 Java 集合框架的体系结构<ul>
<li>接口层面：<ul>
<li>Collection 接口：是集合框架的根接口之一，定义了一组操作元素的方法，如添加、删除、查询等。它有两个重要的子接口：<ul>
<li><strong>List 接口</strong>：有序的集合，允许元素重复。其实现类如<code>ArrayList</code>、<code>LinkedList</code>等。<code>ArrayList</code>基于数组实现，查询效率高，增删操作尤其是在中间位置增删时效率较低；<code>LinkedList</code>基于链表实现，增删操作效率高，查询效率相对较低。</li>
<li><strong>Set 接口</strong>：无序且不允许元素重复的集合。常见实现类有<code>HashSet</code>、<code>TreeSet</code>等。<code>HashSet</code>基于哈希表实现，查询和添加效率高，元素无序；<code>TreeSet</code>基于红 - 黑树实现，元素有序，并且可以对元素进行排序。</li>
</ul>
</li>
<li><strong>Map 接口</strong>：用于存储键值对（key - value），一个键最多映射到一个值。常见实现类有<code>HashMap</code>、<code>TreeMap</code>、<code>ConcurrentHashMap</code>等。<code>HashMap</code>基于哈希表实现，允许<code>null</code>键和<code>null</code>值，查询和插入效率高；<code>TreeMap</code>基于红 - 黑树实现，按键的自然顺序或自定义顺序排序；<code>ConcurrentHashMap</code>是线程安全的哈希表，允许多个线程同时读，部分线程同时写，适用于高并发场景。</li>
</ul>
</li>
<li>具体实现类层面：<ul>
<li><strong>ArrayList</strong>：是最常用的<code>List</code>实现类，内部使用数组存储元素。支持随机访问，通过索引访问元素的时间复杂度为 O (1)，但在插入和删除元素时，尤其是在中间位置操作，需要移动元素，时间复杂度为 O (n)。</li>
<li><strong>LinkedList</strong>：基于双向链表实现，在链表头部或尾部插入和删除元素的时间复杂度为 O (1)，但随机访问元素时需要从头或尾开始遍历链表，时间复杂度为 O (n)。</li>
<li><strong>HashSet</strong>：内部使用<code>HashMap</code>来存储元素，将元素作为<code>HashMap</code>的键，值使用一个固定的对象。通过哈希表实现快速的插入、删除和查找操作，时间复杂度通常为 O (1)，但在哈希冲突严重时会退化为 O (n)。</li>
<li><strong>TreeSet</strong>：基于<code>TreeMap</code>实现，元素按照自然顺序或自定义顺序排序。插入、删除和查找操作的时间复杂度为 O (log n)，因为其底层是红 - 黑树结构。</li>
<li><strong>HashMap</strong>：使用哈希表存储键值对，通过哈希函数计算键的哈希值来确定存储位置。在没有哈希冲突的情况下，插入、删除和查找操作的时间复杂度为 O (1)。但当哈希冲突较多时，性能会下降。在 JDK 8 中，当链表长度超过一定阈值（默认为 8）时，链表会转换为红 - 黑树，以提高查询性能。</li>
<li><strong>TreeMap</strong>：基于红 - 黑树实现，按键的顺序对键值对进行排序。插入、删除和查找操作的时间复杂度为 O (log n)，适用于需要按键排序的场景。</li>
<li><strong>ConcurrentHashMap</strong>：在 JDK 7 中，采用分段锁机制，将哈希表分成多个段，每个段有独立的锁，不同段可以同时进行读写操作，提高了并发性能。在 JDK 8 中，采用 CAS（Compare - and - Swap）操作和 synchronized 关键字结合的方式，进一步提高了并发性能，并且在高并发下的性能优于 JDK 7 的版本。</li>
</ul>
</li>
</ul>
</li>
<li>ArrayList 和 LinkedList 有什么区别，在什么场景下应该选择哪个？<ul>
<li>区别：<ul>
<li>数据结构：<ul>
<li><strong>ArrayList</strong>：基于动态数组实现，内部维护一个数组，当数组容量不足时会进行扩容。</li>
<li><strong>LinkedList</strong>：基于双向链表实现，每个节点包含前驱节点、后继节点和数据。</li>
</ul>
</li>
<li>查询性能：<ul>
<li><strong>ArrayList</strong>：支持随机访问，通过索引直接定位元素，时间复杂度为 O (1)，在查询操作频繁的场景下性能较好。</li>
<li><strong>LinkedList</strong>：随机访问需要从头或尾开始遍历链表，时间复杂度为 O (n)，查询性能相对较差。</li>
</ul>
</li>
<li>插入和删除性能：<ul>
<li><strong>ArrayList</strong>：在数组末尾插入或删除元素的时间复杂度为 O (1)，但在中间位置插入或删除元素时，需要移动后续元素，时间复杂度为 O (n)。</li>
<li><strong>LinkedList</strong>：在链表头部或尾部插入或删除元素的时间复杂度为 O (1)，在中间位置插入或删除元素时，只需修改前后节点的指针，时间复杂度也为 O (1)。</li>
</ul>
</li>
<li>内存占用：<ul>
<li><strong>ArrayList</strong>：由于是数组结构，内存占用相对紧凑，但在扩容时可能会造成一定的内存浪费。</li>
<li><strong>LinkedList</strong>：每个节点除了存储数据外，还需要存储前驱和后继节点的引用，内存占用相对较大。</li>
</ul>
</li>
</ul>
</li>
<li>选择场景：<ul>
<li><strong>ArrayList</strong>：适用于查询操作频繁，插入和删除操作主要在尾部进行的场景，如数据统计、报表生成等。</li>
<li><strong>LinkedList</strong>：适用于插入和删除操作频繁，尤其是在中间位置进行插入和删除的场景，如实现栈、队列等数据结构，或者需要频繁对数据进行增删操作的场景。</li>
</ul>
</li>
</ul>
</li>
<li>HashMap 的工作原理是什么，它在 JDK 7 和 JDK 8 中有哪些主要变化？<ul>
<li>工作原理（以 JDK 8 为例）：<ul>
<li><strong>存储结构</strong>：<code>HashMap</code>使用数组加链表（或红 - 黑树）的结构来存储键值对。数组的每个元素是一个链表（或红 - 黑树）的头节点。</li>
<li><strong>哈希计算</strong>：当插入一个键值对时，首先计算键的哈希值，通过哈希函数将哈希值映射到数组的索引位置。如果该位置没有元素，则直接插入；如果该位置已有元素，说明发生了哈希冲突，此时会将新的键值对插入到该位置的链表（或红 - 黑树）中。</li>
<li><strong>链表转红 - 黑树</strong>：当链表长度超过一定阈值（默认为 8）且数组长度大于等于 64 时，链表会转换为红 - 黑树，以提高查询性能。当红 - 黑树节点数量小于 6 时，会退化为链表。</li>
<li><strong>扩容机制</strong>：当<code>HashMap</code>中的元素数量达到负载因子（默认为 0.75）与数组容量的乘积时，会进行扩容，扩容后的容量是原来的 2 倍。扩容时会重新计算每个元素的哈希值并重新分配到新的数组位置。</li>
</ul>
</li>
<li>JDK 7 和 JDK 8 的主要变化：<ul>
<li>数据结构：<ul>
<li><strong>JDK 7</strong>：采用数组加链表的结构，所有的哈希冲突都通过链表解决。</li>
<li><strong>JDK 8</strong>：在链表长度较长时引入了红 - 黑树，将链表转换为红 - 黑树以提高查询性能。</li>
</ul>
</li>
<li>哈希冲突解决方式：<ul>
<li><strong>JDK 7</strong>：使用头插法插入新元素到链表，在多线程环境下可能会形成环形链表，导致死循环。</li>
<li><strong>JDK 8</strong>：使用尾插法插入新元素到链表，避免了环形链表的问题。</li>
</ul>
</li>
<li>扩容机制：<ul>
<li><strong>JDK 7</strong>：扩容时需要重新计算每个元素的哈希值并重新分配到新的数组位置，性能消耗较大。</li>
<li><strong>JDK 8</strong>：在扩容时，对于链表节点，根据哈希值与旧容量的关系，判断节点是留在原位置还是移动到新位置的对应索引处，部分节点不需要重新计算哈希值，提高了扩容效率。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ol>
<h2 id="7-简述一下你了解的设计模式"><a href="#7-简述一下你了解的设计模式" class="headerlink" title="7.简述一下你了解的设计模式"></a>7.简述一下你了解的设计模式</h2><p><strong>常用模式（23种中核心7种）：</strong></p>
<ul>
<li>单例（保证唯一实例）</li>
<li>工厂（解耦对象创建）</li>
<li>代理（增强功能）</li>
<li>观察者（事件监听）</li>
<li>策略（算法可替换）</li>
<li>模板方法（固定流程）</li>
<li>装饰器（动态增强）</li>
</ul>
<p><strong>项目例：</strong><br> Spring AOP → 代理模式<br> MyBatis Mapper → 动态代理 + 工厂模式</p>
<h2 id="8-线程锁"><a href="#8-线程锁" class="headerlink" title="8.线程锁"></a>8.线程锁</h2><p><strong>类型：</strong></p>
<ul>
<li>synchronized（JVM 内置锁，偏向锁→轻量级→重量级）</li>
<li>ReentrantLock（可中断、公平锁、可超时）</li>
<li>ReadWriteLock（读写分离）</li>
<li>StampedLock（乐观读锁）</li>
</ul>
<p><strong>底层：</strong><br> <code>synchronized</code> 通过对象头 MarkWord 实现锁状态；<br> <code>ReentrantLock</code> 基于 AQS（AbstractQueuedSynchronizer）。</p>
<ol>
<li><p>​	请详细阐述 <code>synchronized</code> 锁从偏向锁到轻量级锁再到重量级锁的升级过程</p>
<ul>
<li>偏向锁：<ul>
<li><strong>适用场景</strong>：在大多数情况下，锁不仅不存在多线程竞争，而且总是由同一线程多次获得。偏向锁的设计就是为了在这种场景下，减少不必要的锁竞争开销。</li>
<li><strong>实现原理</strong>：当一个线程访问同步块并获取锁时，会在对象头的 MarkWord 中记录下该线程的 ID。之后该线程再次进入同步块时，只需检查 MarkWord 中的线程 ID 是否与自己的 ID 一致，若一致则无需进行任何同步操作，直接进入同步块，这大大提高了执行效率。偏向锁使用 CAS（Compare - and - Swap）操作来设置对象头中的线程 ID。</li>
<li><strong>升级条件</strong>：当有其他线程尝试获取偏向锁时，偏向锁就会升级为轻量级锁。这是因为此时已经出现了多线程竞争的情况，偏向锁无法再满足需求。</li>
</ul>
</li>
<li>轻量级锁：<ul>
<li><strong>适用场景</strong>：适用于短时间内有竞争，但竞争不太激烈的场景。</li>
<li><strong>实现原理</strong>：当偏向锁升级为轻量级锁时，线程会在自己的栈帧中创建一个锁记录（Lock Record），并将对象头中的 MarkWord 复制到锁记录中，然后使用 CAS 操作尝试将对象头中的 MarkWord 替换为指向锁记录的指针。如果 CAS 操作成功，当前线程就获得了锁；如果失败，表示有其他线程竞争锁，轻量级锁会膨胀为重量级锁。</li>
<li><strong>自旋机制</strong>：在轻量级锁竞争过程中，为了避免线程被挂起的开销，会采用自旋机制。即当一个线程获取锁失败时，它不会立即被挂起，而是在一定次数内尝试自旋等待，看持有锁的线程是否会很快释放锁。如果自旋一定次数后仍未获取到锁，才会将线程挂起。</li>
</ul>
</li>
<li>重量级锁：<ul>
<li><strong>适用场景</strong>：适用于竞争激烈的场景。</li>
<li><strong>实现原理</strong>：当轻量级锁膨胀为重量级锁后，锁的实现依赖于操作系统的互斥量（Mutex）。获取锁的线程会进入内核态，通过操作系统的调度来管理线程的阻塞和唤醒。此时，等待锁的线程会被挂起，放入等待队列中，当持有锁的线程释放锁时，会从等待队列中唤醒一个线程来获取锁。重量级锁的开销较大，因为线程的挂起和唤醒需要操作系统的介入，涉及用户态和内核态的切换。</li>
</ul>
</li>
</ul>
</li>
<li><p><code>ReentrantLock</code> 相较于 <code>synchronized</code> 有哪些优势？</p>
<ul>
<li>可中断：<ul>
<li>**<code>ReentrantLock</code>**：<code>ReentrantLock</code> 提供了可中断的获取锁的方法，如 <code>lockInterruptibly()</code>。当一个线程在获取锁的过程中，若其他线程调用了该线程的 <code>interrupt()</code> 方法，当前线程可以响应中断，停止等待锁，转而处理中断逻辑。</li>
<li>**<code>synchronized</code>**：<code>synchronized</code> 关键字不支持可中断的锁获取方式。一旦线程进入同步块获取锁，除非获取到锁或者抛出异常，否则不会响应中断。</li>
</ul>
</li>
<li>公平锁：<ul>
<li>**<code>ReentrantLock</code>**：<code>ReentrantLock</code> 可以通过构造函数来设置是否为公平锁。公平锁保证了等待时间最长的线程优先获取锁，按照线程等待的先后顺序来分配锁，避免了线程饥饿问题。但公平锁的实现开销较大，会降低系统的吞吐量。</li>
<li>**<code>synchronized</code>**：<code>synchronized</code> 是非公平锁，它在锁可用时，并不保证等待时间最长的线程优先获取锁，而是随机选择一个等待线程获取锁，这种方式可能导致某些线程长时间无法获取锁，出现线程饥饿现象。</li>
</ul>
</li>
<li>可超时：<ul>
<li>**<code>ReentrantLock</code>**：<code>ReentrantLock</code> 提供了带超时的获取锁方法，如 <code>tryLock(long timeout, TimeUnit unit)</code>。线程在尝试获取锁时，如果在指定的超时时间内没有获取到锁，会返回 <code>false</code>，线程可以选择执行其他操作，而不是一直等待。</li>
<li>**<code>synchronized</code>**：<code>synchronized</code> 没有提供直接的超时获取锁机制，一旦进入同步块等待锁，就会一直等待下去，直到获取到锁。</li>
</ul>
</li>
<li>锁的获取与释放灵活性：<ul>
<li>**<code>ReentrantLock</code>**：<code>ReentrantLock</code> 需要手动调用 <code>lock()</code> 方法获取锁，并且在使用完后要在 <code>finally</code> 块中手动调用 <code>unlock()</code> 方法释放锁，这种方式提供了更大的灵活性。例如，可以在不同的代码块中获取和释放锁，以满足复杂的业务逻辑需求。</li>
<li>**<code>synchronized</code>**：<code>synchronized</code> 是基于代码块或方法的，锁的获取和释放是自动的。当进入同步块或方法时获取锁，退出同步块或方法时自动释放锁，灵活性相对较差。</li>
</ul>
</li>
</ul>
<p><strong><code>ReentrantLock</code> 是如何基于 AQS 实现的</strong>:</p>
<ul>
<li>基于 AQS 的实现：<ul>
<li><strong>AQS（AbstractQueuedSynchronizer）概述</strong>：AQS 是一个用于构建锁和同步器的框架，它提供了一种基于 FIFO 队列来管理线程等待和唤醒的机制。<code>ReentrantLock</code> 内部包含一个继承自 AQS 的静态内部类 <code>Sync</code>，通过 <code>Sync</code> 来实现锁的获取和释放逻辑。</li>
<li><strong>获取锁过程</strong>：当线程调用 <code>ReentrantLock</code> 的 <code>lock()</code> 方法时，实际上是调用了 <code>Sync</code> 的 <code>lock()</code> 方法。对于非公平锁（<code>ReentrantLock</code> 默认是非公平锁），首先会尝试使用 CAS 操作将 AQS 的状态（state）从 0 设置为 1，表示获取锁成功。如果 CAS 操作失败，说明有其他线程已经持有锁，此时线程会被封装成一个 Node 节点，加入到 AQS 的等待队列中。对于公平锁，线程会先判断等待队列是否为空以及当前线程是否是等待队列的第一个节点，如果不是，则直接将线程封装成 Node 节点加入等待队列。</li>
<li><strong>释放锁过程</strong>：当线程调用 <code>ReentrantLock</code> 的 <code>unlock()</code> 方法时，会将 AQS 的状态（state）减 1。如果状态减为 0，表示当前线程已经完全释放了锁，此时会从等待队列中唤醒一个等待的线程。如果状态不为 0，说明当前线程还持有锁（因为 <code>ReentrantLock</code> 是可重入锁）。</li>
</ul>
</li>
</ul>
</li>
</ol>
<h2 id="9-如何理解存储引擎"><a href="#9-如何理解存储引擎" class="headerlink" title="9.如何理解存储引擎"></a>9.如何理解存储引擎</h2><p>存储引擎是数据库管理系统（DBMS）中负责数据存储、检索、更新和删除等操作的组件。在 MySQL 数据库中，常见的存储引擎有 InnoDB、MyISAM 等。</p>
<p><strong>MySQL 核心引擎：</strong></p>
<ul>
<li>InnoDB（默认，支持事务、行锁、外键）</li>
<li>MyISAM（读多写少）</li>
<li>Memory（内存表）</li>
<li>Archive（日志型）</li>
</ul>
<p><strong>区别关键：</strong></p>
<ol>
<li>以 MySQL 为例，InnoDB 和 MyISAM 存储引擎有哪些主要区别，各自适用于什么场景？<ul>
<li>主要区别：<ul>
<li>事务支持：<ul>
<li><strong>InnoDB</strong>：完全支持事务，遵循 ACID 原则，能保证数据的一致性和完整性。这使得它适用于对数据一致性要求极高的场景，如银行转账、电子商务订单处理等业务，确保在一系列操作中，数据要么全部正确更新，要么回滚到初始状态。</li>
<li><strong>MyISAM</strong>：不支持事务，这意味着在执行多个操作时，如果中途出现错误，无法回滚到操作前的状态。但由于没有事务管理的开销，MyISAM 在简单查询场景下性能较高。</li>
</ul>
</li>
<li>锁机制：<ul>
<li><strong>InnoDB</strong>：支持行级锁和表级锁，默认使用行级锁。行级锁可以精确锁定正在操作的行，减少锁争用，提高并发写入性能。例如在多用户同时对不同行进行修改时，不会相互阻塞，适用于高并发的读写操作场景。</li>
<li><strong>MyISAM</strong>：只支持表级锁，在对表进行写入操作时，会锁定整个表，其他读写操作都需要等待锁释放。这在高并发写入场景下可能导致性能瓶颈，因为同一时间只能有一个写入操作，但在读取操作占主导且写入较少的场景下，表级锁的开销相对较小。</li>
</ul>
</li>
<li>索引结构：<ul>
<li><strong>InnoDB</strong>：采用聚簇索引，数据和主键索引存储在一起。这使得基于主键的查询非常快速，因为可以直接定位到数据行。但如果查询条件不涉及主键，可能需要进行回表操作，即先通过二级索引找到主键，再通过主键找到数据行。</li>
<li><strong>MyISAM</strong>：数据和索引是分开存储的，索引文件仅保存数据记录的地址。这种结构在非主键查询时可能不需要回表操作，但在基于主键的查询性能上相对 InnoDB 较弱。</li>
</ul>
</li>
<li>存储文件：<ul>
<li><strong>InnoDB</strong>：有.frm 文件用于存储表结构定义，.ibd 文件用于存储数据和索引（在开启独立表空间时）。如果是共享表空间，数据和索引都存储在系统表空间文件 ibdataX 中。</li>
<li><strong>MyISAM</strong>：有.frm 文件存储表结构定义，.MYD 文件存储数据，.MYI 文件存储索引。</li>
</ul>
</li>
<li>崩溃恢复能力：<ul>
<li><strong>InnoDB</strong>：具备崩溃恢复能力。它通过日志机制（如重做日志、回滚日志）在数据库发生崩溃后能够恢复到崩溃前的状态，保证数据的完整性。</li>
<li><strong>MyISAM</strong>：不具备崩溃自动恢复能力，在数据库崩溃后，可能需要手动修复数据文件和索引文件。</li>
</ul>
</li>
</ul>
</li>
<li>适用场景：<ul>
<li><strong>InnoDB</strong>：适用于对事务处理要求高、数据一致性要求严格、高并发读写的场景，如电子商务系统、金融系统等。在这些场景中，数据的准确性和并发处理能力至关重要，InnoDB 的事务支持和行级锁机制能够满足这些需求。</li>
<li><strong>MyISAM</strong>：适用于以读操作和插入操作为主、对事务要求不高的场景，如日志记录系统、数据仓库的某些查询场景等。由于其不支持事务和仅使用表级锁，在简单查询场景下性能较高，且存储结构相对简单，占用空间较小。</li>
</ul>
</li>
</ul>
</li>
</ol>
<h2 id="10-数据库如何优化"><a href="#10-数据库如何优化" class="headerlink" title="10.数据库如何优化"></a>10.数据库如何优化</h2><ol>
<li><h3 id="1-SQL-优化"><a href="#1-SQL-优化" class="headerlink" title="1. SQL 优化"></a>1. SQL 优化</h3><ul>
<li><strong>索引有效利用</strong>：避免索引失效场景，如<code>WHERE</code>子句中对索引列使用函数 &#x2F; 计算（<code>WHERE SUBSTR(name,1,3)=&#39;abc&#39;</code>）、隐式类型转换（字符串列与数字比较）、使用<code>NOT IN</code>&#x2F;<code>!=</code>&#x2F;<code>IS NULL</code>（部分场景失效）等；优先使用<code>WHERE</code>过滤而非<code>HAVING</code>，减少后续处理数据量。</li>
<li><strong>减少子查询嵌套</strong>：子查询尤其是多层嵌套可能导致低效执行计划，可改用<code>JOIN</code>重写（如将<code>WHERE id IN (SELECT ...)</code>改为<code>JOIN</code>关联查询），利用连接算法优化性能。</li>
<li><strong>控制返回数据量</strong>：避免<code>SELECT *</code>，只查询必要字段；使用<code>LIMIT</code>限制分页数据，避免全表扫描返回大量结果。</li>
<li><strong>避免事务过长</strong>：长事务会锁定更多资源，增加并发冲突，应拆分事务为短事务，减少锁持有时间。</li>
</ul>
<h3 id="2-索引优化"><a href="#2-索引优化" class="headerlink" title="2. 索引优化"></a>2. 索引优化</h3><ul>
<li><strong>联合索引设计</strong>：遵循 “最左前缀原则”，将过滤性高（区分度大）的字段放在前面（如<code>WHERE a=? AND b=?</code>，联合索引<code>(a,b)</code>更高效）；避免重复索引（如已存在<code>(a,b)</code>，无需单独建<code>(a)</code>）。</li>
<li><strong>覆盖索引</strong>：索引包含查询所需全部字段（如<code>SELECT id,name FROM t WHERE age=?</code>，建<code>(age,id,name)</code>索引可避免回表查数据），直接从索引获取结果，提升效率。</li>
<li><strong>删除冗余 &#x2F; 低效索引</strong>：频繁更新的列（如<code>status</code>）不适合建索引（更新会导致索引维护开销）；低区分度列（如<code>gender</code>）建索引收益低，可能反而拖慢写入。</li>
<li><strong>使用前缀索引</strong>：对长字符串列（如<code>varchar(255)</code>），可只对前 N 个字符建索引（如<code>INDEX idx_name (name(10))</code>），减少索引存储空间。</li>
</ul>
<h3 id="3-表结构优化"><a href="#3-表结构优化" class="headerlink" title="3. 表结构优化"></a>3. 表结构优化</h3><ul>
<li>范式与反范式平衡：<ul>
<li>遵循范式（1NF-3NF）减少冗余（如拆分大表为小表，避免重复字段），降低更新异常风险；</li>
<li>适当反范式（如增加冗余字段、合并表）优化查询，减少<code>JOIN</code>操作（如订单表冗余用户姓名，避免查询时关联用户表）。</li>
</ul>
</li>
<li><strong>字段类型优化</strong>：选择合适字段类型（如用<code>INT</code>存年龄而非<code>VARCHAR</code>，用<code>DATE</code>&#x2F;<code>DATETIME</code>存日期而非字符串），减少存储空间和计算开销；对长度固定的字段用<code>CHAR</code>，可变长度用<code>VARCHAR</code>。</li>
<li><strong>拆分大表</strong>：将包含大量字段的表拆分为 “核心表”（高频访问字段）和 “扩展表”（低频字段），减少单表数据量和 IO 压力。</li>
</ul>
<h3 id="4-缓存优化（减轻数据库读压力）"><a href="#4-缓存优化（减轻数据库读压力）" class="headerlink" title="4. 缓存优化（减轻数据库读压力）"></a>4. 缓存优化（减轻数据库读压力）</h3><ul>
<li><strong>缓存热点数据</strong>：将高频查询、低频更新的数据（如商品基本信息、用户配置）缓存到 Redis 等内存数据库，查询时先查缓存，未命中再查数据库并更新缓存。</li>
<li>缓存策略设计：<ul>
<li>设置合理过期时间，避免缓存雪崩（大量 key 同时过期）；</li>
<li>采用缓存穿透防护（如布隆过滤器过滤无效 key）；</li>
<li>处理缓存与数据库一致性（如更新数据库后同步更新缓存，或采用延迟双删）。</li>
</ul>
</li>
<li><strong>读写分离配合缓存</strong>：主库写入，从库读数据并同步到缓存，进一步分流主库压力。</li>
</ul>
<h3 id="5-分库分表（解决数据量过大问题）"><a href="#5-分库分表（解决数据量过大问题）" class="headerlink" title="5. 分库分表（解决数据量过大问题）"></a>5. 分库分表（解决数据量过大问题）</h3><ul>
<li><strong>垂直拆分</strong>：按业务维度拆分（如电商系统拆分为用户库、订单库、商品库），降低单库压力，便于独立扩展。</li>
<li><strong>水平拆分</strong>：按数据维度拆分大表（如订单表按时间范围拆分为<code>order_2023</code>、<code>order_2024</code>，或按用户 ID 哈希拆分为<code>order_0</code>到<code>order_15</code>），减少单表数据量（建议单表控制在千万级以内），提升查询效率。</li>
<li><strong>路由策略</strong>：通过中间件（如 ShardingSphere）自动路由请求到目标分库分表，简化业务层逻辑。</li>
</ul>
<h3 id="6-连接池优化（提升并发效率）"><a href="#6-连接池优化（提升并发效率）" class="headerlink" title="6. 连接池优化（提升并发效率）"></a>6. 连接池优化（提升并发效率）</h3><ul>
<li><strong>选择高性能连接池</strong>：如 HikariCP（轻量、高效），相比 C3P0、DBCP 有更低的 overhead。</li>
<li>合理配置参数：<ul>
<li><code>maximum-pool-size</code>：最大连接数（根据并发量设置，不宜过大，避免数据库连接耗尽）；</li>
<li><code>minimum-idle</code>：最小空闲连接数（保证基础并发需求，避免频繁创建连接）；</li>
<li><code>connection-timeout</code>：连接超时时间（避免线程长期阻塞）。</li>
</ul>
</li>
<li><strong>避免连接泄露</strong>：确保连接使用后正确关闭（推荐 try-with-resources 语法），释放资源。</li>
</ul>
</li>
</ol>
<p><strong>底层：</strong><br> 慢查询日志 + Explain 分析执行计划。</p>
<h3 id="慢查询日志：定位-“慢-SQL”"><a href="#慢查询日志：定位-“慢-SQL”" class="headerlink" title="慢查询日志：定位 “慢 SQL”"></a>慢查询日志：定位 “慢 SQL”</h3><p>慢查询日志用于记录执行时间超过指定阈值的 SQL 语句，帮助发现耗时较长的查询。</p>
<h4 id="1-开启与配置（以-MySQL-为例）"><a href="#1-开启与配置（以-MySQL-为例）" class="headerlink" title="1. 开启与配置（以 MySQL 为例）"></a>1. 开启与配置（以 MySQL 为例）</h4><ul>
<li><p><strong>开启慢查询日志</strong>：在<code>my.cnf</code>或<code>my.ini</code>中配置：</p>
<figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="attr">slow_query_log</span> = <span class="number">1</span>  <span class="comment"># 开启慢查询日志（1为开启，0为关闭）</span></span><br><span class="line"><span class="attr">slow_query_log_file</span> = /var/log/mysql/mysql-slow.log  <span class="comment"># 日志文件路径</span></span><br><span class="line"><span class="attr">long_query_time</span> = <span class="number">1</span>  <span class="comment"># 慢查询阈值（单位：秒，默认10秒，建议根据业务设为1-2秒）</span></span><br><span class="line"><span class="attr">log_queries_not_using_indexes</span> = <span class="number">1</span>  <span class="comment"># 记录未使用索引的查询（即使未超阈值，可选）</span></span><br></pre></td></tr></table></figure>

<p>重启 MySQL 生效，或动态生效：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SET</span> <span class="keyword">GLOBAL</span> slow_query_log <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">SET</span> <span class="keyword">GLOBAL</span> long_query_time <span class="operator">=</span> <span class="number">1</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>查看配置</strong>：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> VARIABLES <span class="keyword">LIKE</span> <span class="string">&#x27;%slow_query%&#x27;</span>;</span><br><span class="line"><span class="keyword">SHOW</span> VARIABLES <span class="keyword">LIKE</span> <span class="string">&#x27;long_query_time&#x27;</span>;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="2-分析慢查询日志"><a href="#2-分析慢查询日志" class="headerlink" title="2. 分析慢查询日志"></a>2. 分析慢查询日志</h4><ul>
<li><p><strong>直接查看日志内容</strong>：日志会记录 SQL 执行时间、锁等待时间、扫描行数等关键信息，例如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># Time: 2025-10-23T10:00:00Z</span><br><span class="line"># User@Host: root[root] @ localhost []</span><br><span class="line"># Query_time: 5.200  Lock_time: 0.001  Rows_sent: 100  Rows_examined: 1000000</span><br><span class="line">SELECT * FROM orders WHERE create_time &lt; &#x27;2023-01-01&#x27;;</span><br></pre></td></tr></table></figure>

<p>关键指标：</p>
<ul>
<li><code>Query_time</code>：执行时间（超过<code>long_query_time</code>才记录）；</li>
<li><code>Rows_examined</code>：扫描行数（远大于<code>Rows_sent</code>说明低效，可能未用索引）；</li>
<li><code>Lock_time</code>：锁等待时间（过长可能存在并发冲突）。</li>
</ul>
</li>
<li><p><strong>工具分析</strong>：日志量大时，用<code>mysqldumpslow</code>（MySQL 自带）或<code>pt-query-digest</code>（Percona Toolkit）汇总分析：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 统计最耗时的10条SQL</span></span><br><span class="line">mysqldumpslow -s t -t 10 /var/log/mysql/mysql-slow.log</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="二、EXPLAIN：分析-SQL-执行计划"><a href="#二、EXPLAIN：分析-SQL-执行计划" class="headerlink" title="二、EXPLAIN：分析 SQL 执行计划"></a>二、EXPLAIN：分析 SQL 执行计划</h3><p>找到慢查询后，用<code>EXPLAIN</code>（或<code>EXPLAIN ANALYZE</code>，部分数据库支持）查看 MySQL 优化器生成的执行计划，判断 SQL 是否高效利用索引、是否全表扫描等。</p>
<h4 id="1-基本用法"><a href="#1-基本用法" class="headerlink" title="1. 基本用法"></a>1. 基本用法</h4><p>在 SQL 前加<code>EXPLAIN</code>，例如：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> orders <span class="keyword">WHERE</span> user_id <span class="operator">=</span> <span class="number">123</span> <span class="keyword">AND</span> status <span class="operator">=</span> <span class="string">&#x27;paid&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>输出结果包含 12 列（MySQL），核心关注以下字段：</p>
<h4 id="2-核心字段解析"><a href="#2-核心字段解析" class="headerlink" title="2. 核心字段解析"></a>2. 核心字段解析</h4><table>
<thead>
<tr>
<th>字段</th>
<th>含义与关键值</th>
</tr>
</thead>
<tbody><tr>
<td><code>type</code></td>
<td>访问类型（最重要指标），从优到差：<code>system</code> &gt; <code>const</code> &gt; <code>eq_ref</code> &gt; <code>ref</code> &gt; <code>range</code> &gt; <code>index</code> &gt; <code>ALL</code><strong>目标</strong>：至少达到<code>range</code>，最好<code>ref</code>或<code>eq_ref</code>；<code>ALL</code>表示全表扫描（需优化）。</td>
</tr>
<tr>
<td><code>key</code></td>
<td>实际使用的索引（<code>NULL</code>表示未用索引）。</td>
</tr>
<tr>
<td><code>key_len</code></td>
<td>索引使用的长度（越长说明使用的索引字段越多，需结合联合索引最左前缀原则判断）。</td>
</tr>
<tr>
<td><code>rows</code></td>
<td>预估扫描行数（值越小越好，需与实际数据量对比）。</td>
</tr>
<tr>
<td><code>Extra</code></td>
<td>额外信息（关键优化依据）：- <code>Using index</code>：覆盖索引（优秀，无需回表）；- <code>Using where; Using index</code>：用索引过滤并覆盖查询；- <code>Using filesort</code>：需额外排序（未用索引排序，低效）；- <code>Using temporary</code>：使用临时表（如 GROUP BY 未用索引，低效）；- <code>Using join buffer</code>：连接未用索引，需优化关联条件。</td>
</tr>
</tbody></table>
<h4 id="3-常见场景与优化思路"><a href="#3-常见场景与优化思路" class="headerlink" title="3. 常见场景与优化思路"></a>3. 常见场景与优化思路</h4><ul>
<li><strong>场景 1：<code>type=ALL</code>（全表扫描）</strong>原因：<code>WHERE</code>条件未命中索引，或索引失效（如函数操作、隐式转换）。优化：添加合适索引，或修改 SQL 避免索引失效（如<code>WHERE SUBSTR(name,1,3)=&#39;abc&#39;</code>改为<code>WHERE name LIKE &#39;abc%&#39;</code>并建<code>name</code>索引）。</li>
<li>**场景 2：<code>Extra=Using filesort</code>**原因：<code>ORDER BY</code>字段未用索引，导致内存 &#x2F; 磁盘排序。优化：将排序字段加入联合索引（如<code>WHERE a=? ORDER BY b</code>，建<code>(a,b)</code>索引）。</li>
<li>**场景 3：<code>Extra=Using temporary</code>**原因：<code>GROUP BY</code>&#x2F;<code>DISTINCT</code>未用索引，需创建临时表存储中间结果。优化：将分组字段加入索引（如<code>GROUP BY a</code>，建<code>a</code>单列索引或包含<code>a</code>的联合索引）。</li>
<li>**场景 4：<code>key=NULL</code>但<code>type=range</code>**原因：可能使用了索引但未显示（极少），或<code>range</code>条件未命中有效索引。优化：检查<code>range</code>条件（如<code>&gt;</code>, <code>&lt;</code>, <code>IN</code>）是否可通过索引覆盖，调整索引字段顺序。</li>
</ul>
<h3 id="三、结合使用：慢查询-EXPLAIN-实战流程"><a href="#三、结合使用：慢查询-EXPLAIN-实战流程" class="headerlink" title="三、结合使用：慢查询 + EXPLAIN 实战流程"></a>三、结合使用：慢查询 + EXPLAIN 实战流程</h3><ol>
<li><strong>开启慢查询日志</strong>，收集一段时间（如 1 天）的慢 SQL；</li>
<li><strong>用工具筛选</strong>出高频、高耗时的 SQL（如<code>mysqldumpslow</code>排序）；</li>
<li>**对目标 SQL 执行<code>EXPLAIN</code>**，分析<code>type</code>、<code>key</code>、<code>Extra</code>等字段，定位问题（如全表扫描、未用索引、排序低效）；</li>
<li>针对性优化：<ul>
<li>若未用索引：添加合适索引（联合索引、覆盖索引）；</li>
<li>若索引失效：修改 SQL 避免函数 &#x2F; 隐式转换；</li>
<li>若排序 &#x2F; 分组低效：优化索引包含排序 &#x2F; 分组字段；</li>
</ul>
</li>
<li><strong>验证优化效果</strong>：重新执行 SQL，对比执行时间，再次用<code>EXPLAIN</code>确认执行计划改善。</li>
</ol>
<h2 id="11-事务"><a href="#11-事务" class="headerlink" title="11.事务"></a>11.事务</h2><p>数据库事务是由一系列数据库操作组成的逻辑单元，这些操作要么全部成功执行，要么全部不执行，是一个不可分割的整体。</p>
<h3 id="四大特性：ACID"><a href="#四大特性：ACID" class="headerlink" title="四大特性：ACID"></a><strong>四大特性：ACID</strong></h3><ul>
<li>原子性（Atomicity）事务中的所有操作要么全部成功提交，要么全部失败回滚。	</li>
<li>一致性（Consistency）事务执行前后，数据库的完整性约束（如主键约束、外键约束、数据类型约束等）必须保持一致。</li>
<li>隔离性（Isolation）多个事务并发执行时，一个事务的执行不能被其他事务干扰。不同事务之间的数据相互隔离，每个事务都感觉不到其他事务的存在。</li>
<li>持久性（Durability）一旦事务提交成功，对数据库所做的更改将永久保存，即使系统发生故障（如停电、系统崩溃等），这些更改也不会丢失。</li>
</ul>
<h3 id="隔离级别"><a href="#隔离级别" class="headerlink" title="隔离级别"></a><strong>隔离级别</strong></h3><ul>
<li>读未提交（Read Uncommitted）：<ul>
<li><strong>隔离级别描述</strong>：在这种隔离级别下，一个事务可以读取到另一个未提交事务修改的数据。这是最低的隔离级别，几乎没有提供任何隔离保护。</li>
<li>可能产生的并发问题：<ul>
<li><strong>脏读（Dirty Read）</strong>：一个事务读取到另一个未提交事务修改的数据。例如，事务 A 修改了某条数据，但还未提交，此时事务 B 读取了这条被修改的数据。如果事务 A 随后回滚，事务 B 读取到的数据就是无效的脏数据，这可能导致业务逻辑错误。</li>
</ul>
</li>
</ul>
</li>
<li>读已提交（Read Committed）：<ul>
<li><strong>隔离级别描述</strong>：一个事务只能读取到另一个已提交事务修改的数据。这是大多数数据库的默认隔离级别。</li>
<li>可能产生的并发问题：<ul>
<li><strong>不可重复读（Non - Repeatable Read）</strong>：在一个事务内多次读取同一数据时，由于其他事务在期间对该数据进行了修改并提交，导致每次读取到的数据不一致。例如，事务 A 在开始时读取了某条数据，之后事务 B 修改并提交了这条数据，当事务 A 再次读取时，得到的数据与第一次读取的不同，这可能会影响事务 A 的业务逻辑。</li>
</ul>
</li>
</ul>
</li>
<li>可重复读（Repeatable Read）：<ul>
<li><strong>隔离级别描述</strong>：在一个事务内多次读取同一数据时，其他事务不能修改该数据，直到当前事务结束。它保证了在同一事务内多次读取的数据是一致的。</li>
<li>可能产生的并发问题：<ul>
<li><strong>幻读（Phantom Read）</strong>：在一个事务内，按照相同的查询条件多次读取数据时，由于其他事务插入了符合查询条件的新数据，导致每次读取到的数据行数不同。例如，事务 A 按照某个条件查询数据，得到了一定数量的结果集。之后事务 B 插入了一些符合该条件的新数据并提交，当事务 A 再次按照相同条件查询时，得到的结果集行数增加了，就好像出现了 “幻影” 数据。虽然可重复读保证了已读取数据的一致性，但无法防止新数据的插入导致结果集的变化。</li>
</ul>
</li>
</ul>
</li>
<li>串行化（Serializable）：<ul>
<li><strong>隔离级别描述</strong>：这是最高的隔离级别，所有事务依次串行执行，即一个事务执行完后，另一个事务才能开始执行。它通过强制事务排队，避免了所有的并发问题。</li>
<li>优点和缺点：<ul>
<li><strong>优点</strong>：能够确保数据的高度一致性，完全避免了脏读、不可重复读和幻读等并发问题。</li>
<li><strong>缺点</strong>：由于所有事务是串行执行的，性能较低，在高并发场景下，可能会导致大量事务等待，严重影响系统的并发处理能力。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="ACID怎么实现的"><a href="#ACID怎么实现的" class="headerlink" title="ACID怎么实现的?"></a>ACID怎么实现的?</h3><ol>
<li>原子性（Atomicity）的实现<ul>
<li><strong>日志记录（Log Records）</strong>：数据库使用日志来记录事务执行过程中的所有操作。以 MySQL 的 InnoDB 存储引擎为例，它有重做日志（redo log）和回滚日志（undo log）。当事务执行时，每一个修改操作都会先记录到日志中。比如，在执行一个插入操作时，会记录插入的数据以及相关的元数据到日志。如果事务执行过程中出现故障，数据库可以根据回滚日志撤销未完成事务对数据的修改，确保事务的原子性。回滚日志记录了数据修改前的版本，通过逆向操作（如反向的插入、更新或删除）将数据恢复到事务开始前的状态。</li>
<li><strong>事务状态跟踪</strong>：数据库系统会跟踪事务的状态，通常分为活动（active）、部分提交（partially committed）、失败（failed）、中止（aborted）和提交（committed）等状态。在事务执行期间，它处于活动状态，当所有操作都成功完成，事务进入部分提交状态。此时，数据库会将日志持久化到存储设备（这一步确保即使系统崩溃，已完成的操作也不会丢失）。如果在这之后没有发生故障，事务就会提交，状态变为提交；若在事务执行过程中任何一步出现错误，事务进入失败状态，然后利用回滚日志进行回滚操作，将事务状态变为中止，从而保证事务要么全部成功，要么全部失败。</li>
</ul>
</li>
<li>一致性（Consistency）的实现<ul>
<li><strong>完整性约束（Integrity Constraints）</strong>：数据库通过定义和强制实施各种完整性约束来保证一致性。常见的完整性约束包括实体完整性（如主键约束，确保表中每一行数据的唯一性）、参照完整性（如外键约束，保证不同表之间数据的一致性）和用户定义完整性（如检查约束，根据业务规则对数据进行限制）。例如，在一个订单系统中，订单表和客户表通过客户 ID 建立关联，订单表中的客户 ID 作为外键参照客户表的主键。当插入一条新订单记录时，数据库会检查外键约束，确保该客户 ID 在客户表中存在，否则插入操作将失败，以此保证数据的一致性。</li>
<li><strong>事务的正确执行</strong>：原子性、隔离性和持久性是保证一致性的基础。原子性确保事务要么全部执行，要么全部不执行，避免数据处于部分修改的不一致状态；隔离性防止并发事务之间的干扰，保证每个事务看到的数据是一致的；持久性确保已提交事务对数据的修改是永久性的，不会因系统故障而丢失。只有这几个特性都满足，才能保证数据库在事务执行前后处于一致状态。例如，在银行转账事务中，原子性保证了扣款和入账操作要么都成功，要么都失败；隔离性确保在转账过程中，其他并发事务不会干扰该转账操作的数据读取和修改；持久性保证了转账成功后，账户余额的改变是永久性的，从而维持了整个银行账户系统数据的一致性。</li>
</ul>
</li>
<li>隔离性（Isolation）的实现<ul>
<li><strong>锁机制（Locking Mechanisms）</strong>：数据库使用锁来控制并发事务对数据的访问。锁可以分为共享锁（Shared Lock，S 锁）和排他锁（Exclusive Lock，X 锁）。共享锁允许多个事务同时读取数据，但不允许其他事务对数据进行修改；排他锁则阻止其他事务对数据进行任何读写操作。例如，当一个事务对某条数据获取了排他锁，其他事务就不能再获取该数据的任何锁，直到排他锁被释放。不同的隔离级别对锁的使用策略不同。在读未提交隔离级别下，几乎不使用锁，所以可能会出现脏读；在读已提交隔离级别下，读取数据时会获取共享锁，但数据读完后锁就会释放，这可能导致不可重复读；在可重复读隔离级别下，读取数据时获取的共享锁会保持到事务结束，从而避免不可重复读；在串行化隔离级别下，会对所有操作的数据获取排他锁，保证事务串行执行，避免所有并发问题。</li>
<li><strong>多版本并发控制（MVCC，Multi - Version Concurrency Control）</strong>：许多数据库系统（如 MySQL 的 InnoDB 存储引擎）采用 MVCC 来实现隔离性。MVCC 通过维护数据的多个版本来避免锁争用，提高并发性能。当一个事务修改数据时，会创建一个新版本的数据，并记录旧版本数据的指针。读取操作时，根据事务的隔离级别和数据版本号来决定读取哪个版本的数据。例如，在可重复读隔离级别下，事务在开始时会获取一个一致性视图，在整个事务期间，所有的读取操作都基于这个视图，读取到的数据版本是事务开始时的数据版本，即使其他事务对数据进行了修改，也不会影响当前事务的读取结果，从而避免了不可重复读和幻读问题。</li>
</ul>
</li>
<li>持久性（Durability）的实现<ul>
<li><strong>日志持久化（Log Persistence）</strong>：重做日志在保证持久性方面起着关键作用。在事务执行过程中，修改操作的日志记录会不断写入重做日志文件。当事务提交时，数据库会确保重做日志已经持久化到稳定存储设备（如磁盘）。即使系统发生崩溃，在重启后，数据库可以根据重做日志中的记录重新执行已提交事务的操作，将数据恢复到崩溃前的状态。例如，在 MySQL 中，InnoDB 存储引擎通过将重做日志写入磁盘的方式来保证持久性。重做日志采用循环写的方式，空间使用完后会覆盖旧的日志，但在事务提交前，会确保相关的日志已经写入到磁盘，并且在系统崩溃恢复时，会按照日志记录的顺序重新应用这些操作，从而保证已提交事务对数据的修改是永久性的。</li>
<li><strong>检查点机制（Checkpoint）</strong>：为了减少系统崩溃恢复的时间，数据库引入了检查点机制。检查点是数据库系统在某个时刻将内存中已修改的数据页（脏页）刷新到磁盘的操作。在检查点之后，重做日志中记录的操作都是在检查点之后发生的。当系统崩溃恢复时，只需要从检查点开始应用重做日志，而不需要从头开始，大大缩短了恢复时间。例如，MySQL 的 InnoDB 存储引擎会定期执行检查点操作，将脏页刷新到磁盘，同时记录检查点的位置。在恢复时，从记录的检查点位置开始读取重做日志并应用其中的操作，确保数据的持久性。</li>
</ul>
</li>
</ol>
<h3 id="MVCC详解"><a href="#MVCC详解" class="headerlink" title="MVCC详解"></a><strong>MVCC详解</strong></h3><ol>
<li>MVCC 的基本概念与原理<ul>
<li><strong>概念</strong>：多版本并发控制（MVCC）是一种用于数据库管理系统的并发控制机制，它允许数据库在高并发环境下，不同事务能同时访问和修改数据，同时保证数据的一致性。MVCC 的核心思想是通过维护数据的多个版本，使得读写操作可以在不同版本的数据上进行，减少锁的使用，从而提高系统的并发性能。</li>
<li>原理：<ul>
<li><strong>版本链的维护</strong>：当数据被修改时，数据库会创建数据的新版本，并记录旧版本数据的指针，从而形成版本链。例如，在 MySQL 的 InnoDB 存储引擎中，每行数据除了实际的数据内容外，还包含隐藏的列，如<code>DB_TRX_ID</code>（记录修改该数据的事务 ID）和<code>DB_ROLL_PTR</code>（指向回滚段中旧版本数据的指针）。假设初始数据为<code>A</code>，事务<code>T1</code>对其进行修改为<code>A1</code>，此时会记录<code>A</code>的旧版本指针，事务<code>T2</code>再对<code>A1</code>修改为<code>A2</code>，又会记录<code>A1</code>的旧版本指针，这样就形成了一条版本链<code>A -&gt; A1 -&gt; A2</code>。</li>
<li><strong>一致性视图的生成</strong>：每个事务在启动时会生成一个一致性视图，该视图记录了当前系统中活跃的事务 ID 列表。一致性视图用于确定事务在读取数据时应该看到哪个版本的数据。在事务执行过程中，它只能看到在一致性视图生成之前提交的事务对数据的修改，而看不到在一致性视图生成之后开始的事务对数据的修改。</li>
</ul>
</li>
</ul>
</li>
</ol>
<h2 id="12-谈谈你对spring的理解"><a href="#12-谈谈你对spring的理解" class="headerlink" title="12.谈谈你对spring的理解"></a>12.谈谈你对spring的理解</h2><p>Spring 是一个开源的轻量级 Java 应用框架，旨在简化企业级 Java 应用的开发。</p>
<p><strong>核心思想：</strong><br> 控制反转（IOC）+ 面向切面编程（AOP）</p>
<p><strong>IOC</strong> 负责“创建和管理对象”，让程序员不用手动 new，而是由 Spring 容器统一控制对象的创建与依赖注入。</p>
<p><strong>AOP</strong> 负责“动态增强行为”，在不修改源码的前提下对方法进行横切逻辑增强（例如日志、事务、权限、监控等）。</p>
<p><strong>IOC 原理：</strong><br> XML&#x2F;注解 → BeanDefinition → 反射创建 Bean → 依赖注入。</p>
<p>​	<strong>配置阶段</strong>：Spring 通过 XML 或注解（如 <code>@Component</code>, <code>@Bean</code>）扫描 Bean 定义信息。</p>
<p>​	<strong>解析阶段</strong>：将这些配置信息封装成 <code>BeanDefinition</code> 对象（描述 Bean 的结构与依赖关系）。</p>
<p>​	<strong>实例化阶段</strong>：<code>BeanFactory</code>（或 <code>ApplicationContext</code>）根据 <code>BeanDefinition</code> 使用<strong>反射</strong>创建 Bean 实例。</p>
<p>​	<strong>依赖注入阶段</strong>：通过反射或 <code>AutowiredAnnotationBeanPostProcessor</code> 实现属性注入。</p>
<p>​	<strong>生命周期管理</strong>：Bean 初始化前后可被 BeanPostProcessor 拦截（例如 AOP 动态代理就在这里织入）</p>
<p> <strong>AOP 原理：</strong><br> 动态代理（JDK Proxy &#x2F; CGLIB）增强方法。</p>
<p>AOP 的底层关键在于<strong>动态代理机制</strong>。</p>
<p><strong>两种主要方式：</strong></p>
<ol>
<li><strong>JDK 动态代理</strong>（基于接口）<br> 使用 <code>java.lang.reflect.Proxy</code> + <code>InvocationHandler</code> 在运行时生成代理类，适用于有接口的目标类。</li>
<li><strong>CGLIB 动态代理</strong>（基于继承）<br> 利用字节码技术在运行时创建目标类的子类，实现方法拦截增强，适用于无接口类。</li>
</ol>
<p><strong>织入时机：</strong><br> Spring AOP 在 Bean 初始化的后置处理阶段（<code>BeanPostProcessor</code>）判断该 Bean 是否需要增强，<br> 如果需要，就为其生成代理对象（Proxy Bean）替换原始 Bean。</p>
<h2 id="13-springboot自动配置原理"><a href="#13-springboot自动配置原理" class="headerlink" title="13.springboot自动配置原理"></a>13.springboot自动配置原理</h2><p><strong>核心机制：</strong></p>
<ol>
<li><code>@SpringBootApplication</code> → <code>@EnableAutoConfiguration</code></li>
<li><code>SpringFactoriesLoader</code> 加载 <code>META-INF/spring.factories</code></li>
<li>条件装配：<code>@ConditionalOnClass</code>, <code>@ConditionalOnMissingBean</code></li>
<li>注册 Bean 到 IOC 容器。</li>
</ol>
<p>以下是整个执行过程的关键节点顺序：</p>
<p>1️⃣ <strong><code>SpringApplication.run()</code></strong><br> → 启动 Spring 容器<br> ↓<br> 2️⃣ <strong><code>@SpringBootApplication</code></strong><br> → 含有 <code>@EnableAutoConfiguration</code><br> ↓<br> 3️⃣ <strong><code>AutoConfigurationImportSelector</code></strong><br> → 加载自动配置类<br> ↓<br> 4️⃣ <strong><code>SpringFactoriesLoader</code></strong><br> → 从 <code>spring.factories</code> 或 <code>AutoConfiguration.imports</code> 加载候选类<br> ↓<br> 5️⃣ <strong><code>AutoConfigurationImportFilter</code></strong><br> → 条件注解过滤不匹配的配置类<br> ↓<br> 6️⃣ <strong><code>ConfigurationClassPostProcessor</code></strong><br> → 解析配置类并注册 BeanDefinition<br> ↓<br> 7️⃣ <strong>IOC 容器 refresh()</strong><br> → 实例化 Bean，自动配置生效</p>
<h2 id="14-redis适用场景"><a href="#14-redis适用场景" class="headerlink" title="14.redis适用场景"></a>14.redis适用场景</h2><ul>
<li><h3 id="1️⃣-缓存热点数据"><a href="#1️⃣-缓存热点数据" class="headerlink" title="1️⃣ 缓存热点数据"></a>1️⃣ <strong>缓存热点数据</strong></h3><p><strong>场景</strong>：系统中访问频率高、变动少的数据，如：</p>
<ul>
<li>商品详情页信息</li>
<li>用户登录态（token &#x2F; session）</li>
<li>文章列表页缓存</li>
</ul>
<p><strong>为什么适合</strong>：</p>
<ul>
<li>内存读写速度极快（10w+ QPS）</li>
<li>减少数据库压力</li>
<li>结合过期时间 TTL 自动淘汰冷数据</li>
</ul>
<p><strong>延伸</strong>：<br> 可搭配双写一致性、缓存穿透&#x2F;击穿&#x2F;雪崩防护策略。</p>
<hr>
<h3 id="2️⃣-分布式-Session-存储"><a href="#2️⃣-分布式-Session-存储" class="headerlink" title="2️⃣ 分布式 Session 存储"></a>2️⃣ <strong>分布式 Session 存储</strong></h3><p><strong>场景</strong>：集群部署下，Session 共享问题。<br> 传统 Session 存在单点问题（保存在 Tomcat 内存中），多个实例间无法共享。</p>
<p><strong>Redis 解法</strong>：</p>
<ul>
<li>将 Session 数据集中存入 Redis</li>
<li>所有应用实例都可共享访问</li>
<li>可设置过期时间，实现自动失效</li>
</ul>
<hr>
<h3 id="3️⃣-计数器-排行榜-点赞系统"><a href="#3️⃣-计数器-排行榜-点赞系统" class="headerlink" title="3️⃣ 计数器 &#x2F; 排行榜 &#x2F; 点赞系统"></a>3️⃣ <strong>计数器 &#x2F; 排行榜 &#x2F; 点赞系统</strong></h3><p><strong>场景</strong>：</p>
<ul>
<li>文章浏览量、点赞量统计</li>
<li>实时排行榜（如游戏积分榜）</li>
</ul>
<p><strong>使用结构</strong>：</p>
<ul>
<li><code>String</code>：原子自增 <code>INCR</code> &#x2F; <code>INCRBY</code></li>
<li><code>ZSet</code>：带权重排序</li>
</ul>
<p><strong>优势</strong>：</p>
<ul>
<li>支持原子操作，线程安全</li>
<li>通过 ZSet 实现动态实时排行</li>
</ul>
<hr>
<h3 id="4️⃣-分布式锁"><a href="#4️⃣-分布式锁" class="headerlink" title="4️⃣ 分布式锁"></a>4️⃣ <strong>分布式锁</strong></h3><p><strong>场景</strong>：控制多节点并发访问同一资源，例如：</p>
<ul>
<li>秒杀系统防止超卖</li>
<li>定时任务防止重复执行</li>
</ul>
<p><strong>Redis 实现方式</strong>：</p>
<ul>
<li>使用 <code>SET key value NX EX 30</code> 实现原子加锁（NX：仅当不存在时设置；EX：过期时间）</li>
<li>解锁时使用 Lua 脚本防止误删别人的锁</li>
<li>或使用 Redisson 提供的可重入锁机制</li>
</ul>
<hr>
<h3 id="5️⃣-限流（Rate-Limiter）"><a href="#5️⃣-限流（Rate-Limiter）" class="headerlink" title="5️⃣ 限流（Rate Limiter）"></a>5️⃣ <strong>限流（Rate Limiter）</strong></h3><p><strong>场景</strong>：</p>
<ul>
<li>防止接口被刷 &#x2F; 恶意请求</li>
<li>控制用户访问频率（如 1 秒只能请求 10 次）</li>
</ul>
<p><strong>实现方式</strong>：</p>
<ul>
<li>利用 <code>INCR</code> + 过期时间</li>
<li>或使用 <code>ZSet</code> 存时间戳实现滑动窗口算法</li>
</ul>
<p><strong>示例</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">INCR user:123:req_count</span><br><span class="line">EXPIRE user:123:req_count 60</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="6️⃣-消息队列-异步任务"><a href="#6️⃣-消息队列-异步任务" class="headerlink" title="6️⃣ 消息队列 &#x2F; 异步任务"></a>6️⃣ <strong>消息队列 &#x2F; 异步任务</strong></h3><p><strong>场景</strong>：</p>
<ul>
<li>异步解耦（下单 → 发短信 &#x2F; 发票）</li>
<li>简易队列任务调度</li>
</ul>
<p><strong>Redis 实现结构</strong>：</p>
<ul>
<li><code>List</code>（用 <code>LPUSH</code> &#x2F; <code>BRPOP</code> 实现 FIFO 队列）</li>
<li><code>Stream</code>（Redis 5.0+ 更强的消息流模型）</li>
</ul>
<p><strong>对比 Kafka &#x2F; RabbitMQ</strong>：</p>
<ul>
<li>Redis 更轻量、运维简单</li>
<li>但不保证严格可靠投递（非强一致）</li>
</ul>
<hr>
<h3 id="7️⃣-地理位置服务（GEO）"><a href="#7️⃣-地理位置服务（GEO）" class="headerlink" title="7️⃣ 地理位置服务（GEO）"></a>7️⃣ <strong>地理位置服务（GEO）</strong></h3><p><strong>场景</strong>：</p>
<ul>
<li>附近的人 &#x2F; 店铺 &#x2F; 司机匹配</li>
<li>限制范围内搜索（如 3 公里内）</li>
</ul>
<p><strong>实现方式</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">GEOADD city 116.403963 39.915119 &quot;天安门&quot;</span><br><span class="line">GEORADIUS city 116.41 39.90 5 km</span><br></pre></td></tr></table></figure>

<p><strong>底层原理</strong>：<br> 基于 GeoHash + ZSet 实现。</p>
<hr>
<h3 id="8️⃣-布隆过滤器（防止缓存穿透）"><a href="#8️⃣-布隆过滤器（防止缓存穿透）" class="headerlink" title="8️⃣ 布隆过滤器（防止缓存穿透）"></a>8️⃣ <strong>布隆过滤器（防止缓存穿透）</strong></h3><p><strong>场景</strong>：</p>
<ul>
<li>防止恶意请求访问不存在的数据导致数据库压力过大</li>
</ul>
<p><strong>实现方式</strong>：</p>
<ul>
<li>用 Redis 的 Bitmap 或 Module（RedisBloom）</li>
<li>用哈希函数快速判断 key 是否可能存在</li>
</ul>
</li>
</ul>
<p><strong>延伸：</strong><br> 高可用方案：主从复制 + Sentinel + Cluster。</p>
<h2 id="15-RabbitMQ工作原理"><a href="#15-RabbitMQ工作原理" class="headerlink" title="15.RabbitMQ工作原理"></a>15.RabbitMQ工作原理</h2><p><strong>模型：</strong><br> 生产者 → 交换机（Exchange）→ 队列（Queue）→ 消费者。</p>
<p><strong>交换机类型：</strong></p>
<ul>
<li>direct（点对点）</li>
<li>fanout（广播）</li>
<li>topic（通配符）</li>
<li>headers（头匹配）</li>
</ul>
<p><strong>可靠性：</strong></p>
<ul>
<li>消息确认机制（ACK）</li>
<li>持久化（durable）</li>
<li>死信队列（DLX）</li>
<li>延迟队列（TTL）</li>
</ul>
<h3 id="工作流程详解"><a href="#工作流程详解" class="headerlink" title="工作流程详解"></a>工作流程详解</h3><ol>
<li><strong>建立连接</strong><br> Producer 与 Broker 建立 TCP 连接后，会通过 <strong>Channel（信道）</strong> 进行通信。<br> Channel 是轻量级的通信通道，一个连接上可以复用多个 Channel，提高性能。</li>
<li><strong>发送消息</strong><br> Producer 将消息交给 Exchange，并指定：<ul>
<li><code>exchange</code> 名称</li>
<li><code>routingKey</code>（用于路由）</li>
<li><code>message body</code>（消息内容）</li>
<li>以及一些属性（如持久化、过期时间、优先级等）</li>
</ul>
</li>
<li><strong>消息路由</strong><br> Exchange 根据自己的类型 + Binding 的规则，将消息路由到一个或多个队列。</li>
<li><strong>消息存储</strong><br> Queue 接收到消息后，根据配置可能会：<ul>
<li>存入内存（默认）</li>
<li>持久化到磁盘（防止宕机丢失）</li>
<li>延迟投递（使用插件或 TTL 实现）</li>
</ul>
</li>
<li><strong>消费者订阅</strong><br> Consumer 订阅队列后，Broker 会推送（push）消息给 Consumer。<br> 消费者可以手动确认（ACK），也可以自动确认。</li>
<li><strong>消息确认机制（ACK&#x2F;NACK）</strong><ul>
<li><strong>ACK</strong>：消费者处理成功后告诉 RabbitMQ 可以删除该消息。</li>
<li><strong>NACK &#x2F; Reject</strong>：表示消息处理失败，可以选择重新入队（requeue）或丢弃。</li>
<li>未确认的消息如果 Consumer 断开连接，RabbitMQ 会重新投递。</li>
</ul>
</li>
</ol>
<h3 id="常见使用场景"><a href="#常见使用场景" class="headerlink" title="常见使用场景"></a>常见使用场景</h3><ol>
<li><strong>异步解耦</strong><br> 下单后异步发送短信、邮件，不影响主流程。</li>
<li><strong>流量削峰</strong><br> 高并发下单场景（如秒杀），将请求先放入队列，后台慢慢处理。</li>
<li><strong>消息广播</strong><br> 通过 fanout 交换机实现多系统同步通知。</li>
<li><strong>延迟任务</strong><br> 延迟关闭订单、延迟发送优惠券等。</li>
<li><strong>日志收集与监控</strong><br> 将分布式日志统一收集、异步处理</li>
</ol>
</article><div class="post-copyright"><div class="copyright-cc-box"><i class="anzhiyufont anzhiyu-icon-copyright"></i></div><div class="post-copyright__author_box"><a class="post-copyright__author_img" href="/" title="头像"><img class="post-copyright__author_img_back" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://s2.loli.net/2022/11/07/QVWvrnAsuGxelbS.jpg" title="头像" alt="头像"><img class="post-copyright__author_img_front" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://s2.loli.net/2022/11/07/QVWvrnAsuGxelbS.jpg" title="头像" alt="头像"></a><div class="post-copyright__author_name">北川</div><div class="post-copyright__author_desc">Believe in yourself</div></div><div class="post-copyright__post__info"><a class="post-copyright__original" title="该文章为原创文章，注意版权协议" href="https://gukeyang.github.io/posts/867c7511.html">原创</a><a class="post-copyright-title"><span onclick="rm.copyPageUrl('https://gukeyang.github.io/posts/867c7511.html')">1023面试题</span></a></div><div class="post-tools" id="post-tools"><div class="post-tools-left"><div class="rewardLeftButton"><div class="post-reward" onclick="anzhiyu.addRewardMask()"><div class="reward-button button--animated" title="赞赏作者"><i class="anzhiyufont anzhiyu-icon-hand-heart-fill"></i>打赏作者</div><div class="reward-main"><div class="reward-all"><span class="reward-title">感谢你赐予我前进的力量</span><ul class="reward-group"><li class="reward-item"><a href="/./img/wechat.jpg" target="_blank"><img class="post-qr-code-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/./img/wechat.jpg" alt="微信"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="/./img/alipay.jpg" target="_blank"><img class="post-qr-code-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/./img/alipay.jpg" alt="支付宝"/></a><div class="post-qr-code-desc">支付宝</div></li></ul><a class="reward-main-btn" href="/about/#about-reward" target="_blank"><div class="reward-text">赞赏者名单</div><div class="reward-dec">因为你们的支持让我意识到写文章的价值🙏</div></a></div></div></div><div id="quit-box" onclick="anzhiyu.removeRewardMask()" style="display: none"></div><div class="reward-link mode"><a class="reward-link-button" href="/wecaht/"><i class="anzhiyufont anzhiyu-icon-plant-fill"></i>运营模式与责任</a></div></div><div class="shareRight"><div class="share-link mobile"><div class="share-qrcode"><div class="share-button" title="使用手机访问这篇文章"><i class="anzhiyufont anzhiyu-icon-qrcode"></i></div><div class="share-main"><div class="share-main-all"><div id="qrcode" title="https://gukeyang.github.io/posts/867c7511.html"></div><div class="reward-dec">使用手机访问这篇文章</div></div></div></div></div><div class="share-link weibo"><a class="share-button" target="_blank" href="https://service.weibo.com/share/share.php?title=1023面试题&amp;url=https://gukeyang.github.io/posts/867c7511.html&amp;pic=https://s2.loli.net/2025/10/23/wfbr2eNcL1VvXIn.png?_r_=d6c7fb12-5099-f17e-6221-88d93687f7e5" rel="external nofollow noreferrer noopener"><i class="anzhiyufont anzhiyu-icon-weibo"></i></a></div><div class="share-link copyurl"><div class="share-button" id="post-share-url" title="复制链接" onclick="rm.copyPageUrl()"><i class="anzhiyufont anzhiyu-icon-link"></i></div></div></div></div></div><div class="post-copyright__notice"><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://gukeyang.github.io" target="_blank">北川的个人博客</a>！</span></div></div><div class="post-tools-right"><div class="tag_share"><div class="post-meta__box"><div class="post-meta__box__tag-list"><a class="post-meta__box__tags" href="/tags/%E6%AF%8F%E6%97%A5%E9%9D%A2%E8%AF%95/"><span class="tags-punctuation"> <i class="anzhiyufont anzhiyu-icon-tag"></i></span>每日面试<span class="tagsPageCount">2</span></a></div></div></div><div class="post_share"><div class="social-share" data-image="https://s2.loli.net/2025/10/23/wfbr2eNcL1VvXIn.png?_r_=c8b8c4d9-3b05-f070-2b01-ec5fb5e468d4" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.cbd.int/butterfly-extsrc@1.1.3/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"/><script src="https://cdn.cbd.int/butterfly-extsrc@1.1.3/sharejs/dist/js/social-share.min.js" defer="defer"></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/posts/daef90fc.html"><img class="prev-cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://s2.loli.net/2025/10/23/w3ErpsQhncfDed2.jpg?_r_=0371e445-bf85-3603-0394-49ec9944364f" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">抽象类和接口</div></div></a></div><div class="next-post pull-right"><a href="/posts/aff6963e.html"><img class="next-cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://s2.loli.net/2025/10/23/YUHOf5MZEItlGd3.jpg?_r_=1d335fd2-520a-5de8-b607-f2b3e5a780fa" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">如何解决高并发下的库存抢购超卖少买问题？</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="anzhiyufont anzhiyu-icon-thumbs-up fa-fw" style="font-size: 1.5rem; margin-right: 4px"></i><span>喜欢这篇文章的人也看了</span></div><div class="relatedPosts-list"><div><a href="/posts/69be1e2f.html" title="1022面试题"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://s2.loli.net/2025/10/23/SurYK9kV8bRd2Ll.jpg?_r_=281f03e3-d83c-c84c-d027-96bbacb1729f" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2025-10-22</div><div class="title">1022面试题</div></div></a></div></div></div><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="anzhiyufont anzhiyu-icon-comments"></i><span> 评论</span></div><div class="comment-randomInfo"><a onclick="anzhiyu.addRandomCommentInfo()" href="javascript:void(0)">匿名评论</a><a href="/privacy" style="margin-left: 4px">隐私政策</a></div></div><div class="comment-wrap"><div><div class="vcomment" id="vcomment"></div></div></div></div><div class="comment-barrage"></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="card-content"><div class="author-info__sayhi" id="author-info__sayhi" onclick="anzhiyu.changeSayHelloText()"></div><div class="author-info-avatar"><img class="avatar-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://s2.loli.net/2022/11/07/QVWvrnAsuGxelbS.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/><div class="author-status"><img class="g-status" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/zc998800/cdn/face/gif/m17.gif" ait="status"/></div></div><div class="author-info__description">路慢其修远兮 吾将上下而求索</div><div class="author-info__bottom-group"><a class="author-info__bottom-group-left" href="/"><h1 class="author-info__name">北川</h1><div class="author-info__desc">Believe in yourself</div></a><div class="card-info-social-icons is-center"><a class="social-icon faa-parent animated-hover" href="https://github.com/gukeyang" target="_blank" title="Github"><i class="anzhiyufont anzhiyu-icon-github"></i></a><a class="social-icon faa-parent animated-hover" href="https://space.bilibili.com/1542898061" target="_blank" title="BiliBili"><i class="anzhiyufont anzhiyu-icon-bilibili"></i></a></div></div></div></div><div class="card-widget anzhiyu-right-widget" id="card-wechat" onclick="null"><div id="flip-wrapper"><div id="flip-content"><div class="face" style="background: url(https://bu.dusays.com/2023/01/13/63c02edf44033.png) center center / 100% no-repeat"></div><div class="back face" style="background: url(https://s2.loli.net/2023/10/19/vNio4QGBSX9x5lO.png) center center / 100% no-repeat"></div></div></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-bars"></i><span>文章目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E4%B8%BA%E4%BB%80%E4%B9%88%E5%9C%A8%E9%87%8D%E5%86%99equals%E6%96%B9%E6%B3%95%E7%9A%84%E6%97%B6%E5%80%99%E9%9C%80%E8%A6%81%E9%87%8D%E5%86%99hashCode%E6%96%B9%E6%B3%95"><span class="toc-number">1.</span> <span class="toc-text">1.为什么在重写equals方法的时候需要重写hashCode方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2%E4%BB%80%E4%B9%88%E6%98%AF%E5%BA%8F%E5%88%97%E5%8C%96%EF%BC%9F%E4%BB%80%E4%B9%88%E6%98%AF%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%EF%BC%9F%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF%EF%BC%9F"><span class="toc-number">2.</span> <span class="toc-text">2什么是序列化？什么是反序列化？应用场景？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E6%8A%BD%E8%B1%A1%E7%B1%BB%E5%92%8C%E6%8E%A5%E5%8F%A3%E7%9A%84%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">3.</span> <span class="toc-text">3.抽象类和接口的应用场景</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-java%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6%EF%BC%8C%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">4.</span> <span class="toc-text">4.java反射机制，应用场景</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-BIO-NIO-AIO%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB"><span class="toc-number">5.</span> <span class="toc-text">5.BIO,NIO,AIO有什么区别?</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6"><span class="toc-number">6.</span> <span class="toc-text">6.集合框架</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-%E7%AE%80%E8%BF%B0%E4%B8%80%E4%B8%8B%E4%BD%A0%E4%BA%86%E8%A7%A3%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F"><span class="toc-number">7.</span> <span class="toc-text">7.简述一下你了解的设计模式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-%E7%BA%BF%E7%A8%8B%E9%94%81"><span class="toc-number">8.</span> <span class="toc-text">8.线程锁</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-%E5%A6%82%E4%BD%95%E7%90%86%E8%A7%A3%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E"><span class="toc-number">9.</span> <span class="toc-text">9.如何理解存储引擎</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10-%E6%95%B0%E6%8D%AE%E5%BA%93%E5%A6%82%E4%BD%95%E4%BC%98%E5%8C%96"><span class="toc-number">10.</span> <span class="toc-text">10.数据库如何优化</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-SQL-%E4%BC%98%E5%8C%96"><span class="toc-number">10.1.</span> <span class="toc-text">1. SQL 优化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E7%B4%A2%E5%BC%95%E4%BC%98%E5%8C%96"><span class="toc-number">10.2.</span> <span class="toc-text">2. 索引优化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E8%A1%A8%E7%BB%93%E6%9E%84%E4%BC%98%E5%8C%96"><span class="toc-number">10.3.</span> <span class="toc-text">3. 表结构优化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E7%BC%93%E5%AD%98%E4%BC%98%E5%8C%96%EF%BC%88%E5%87%8F%E8%BD%BB%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AF%BB%E5%8E%8B%E5%8A%9B%EF%BC%89"><span class="toc-number">10.4.</span> <span class="toc-text">4. 缓存优化（减轻数据库读压力）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8%EF%BC%88%E8%A7%A3%E5%86%B3%E6%95%B0%E6%8D%AE%E9%87%8F%E8%BF%87%E5%A4%A7%E9%97%AE%E9%A2%98%EF%BC%89"><span class="toc-number">10.5.</span> <span class="toc-text">5. 分库分表（解决数据量过大问题）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-%E8%BF%9E%E6%8E%A5%E6%B1%A0%E4%BC%98%E5%8C%96%EF%BC%88%E6%8F%90%E5%8D%87%E5%B9%B6%E5%8F%91%E6%95%88%E7%8E%87%EF%BC%89"><span class="toc-number">10.6.</span> <span class="toc-text">6. 连接池优化（提升并发效率）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%85%A2%E6%9F%A5%E8%AF%A2%E6%97%A5%E5%BF%97%EF%BC%9A%E5%AE%9A%E4%BD%8D-%E2%80%9C%E6%85%A2-SQL%E2%80%9D"><span class="toc-number">10.7.</span> <span class="toc-text">慢查询日志：定位 “慢 SQL”</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E5%BC%80%E5%90%AF%E4%B8%8E%E9%85%8D%E7%BD%AE%EF%BC%88%E4%BB%A5-MySQL-%E4%B8%BA%E4%BE%8B%EF%BC%89"><span class="toc-number">10.7.1.</span> <span class="toc-text">1. 开启与配置（以 MySQL 为例）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E5%88%86%E6%9E%90%E6%85%A2%E6%9F%A5%E8%AF%A2%E6%97%A5%E5%BF%97"><span class="toc-number">10.7.2.</span> <span class="toc-text">2. 分析慢查询日志</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E3%80%81EXPLAIN%EF%BC%9A%E5%88%86%E6%9E%90-SQL-%E6%89%A7%E8%A1%8C%E8%AE%A1%E5%88%92"><span class="toc-number">10.8.</span> <span class="toc-text">二、EXPLAIN：分析 SQL 执行计划</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95"><span class="toc-number">10.8.1.</span> <span class="toc-text">1. 基本用法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E6%A0%B8%E5%BF%83%E5%AD%97%E6%AE%B5%E8%A7%A3%E6%9E%90"><span class="toc-number">10.8.2.</span> <span class="toc-text">2. 核心字段解析</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E5%B8%B8%E8%A7%81%E5%9C%BA%E6%99%AF%E4%B8%8E%E4%BC%98%E5%8C%96%E6%80%9D%E8%B7%AF"><span class="toc-number">10.8.3.</span> <span class="toc-text">3. 常见场景与优化思路</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%89%E3%80%81%E7%BB%93%E5%90%88%E4%BD%BF%E7%94%A8%EF%BC%9A%E6%85%A2%E6%9F%A5%E8%AF%A2-EXPLAIN-%E5%AE%9E%E6%88%98%E6%B5%81%E7%A8%8B"><span class="toc-number">10.9.</span> <span class="toc-text">三、结合使用：慢查询 + EXPLAIN 实战流程</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#11-%E4%BA%8B%E5%8A%A1"><span class="toc-number">11.</span> <span class="toc-text">11.事务</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%9B%E5%A4%A7%E7%89%B9%E6%80%A7%EF%BC%9AACID"><span class="toc-number">11.1.</span> <span class="toc-text">四大特性：ACID</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB"><span class="toc-number">11.2.</span> <span class="toc-text">隔离级别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ACID%E6%80%8E%E4%B9%88%E5%AE%9E%E7%8E%B0%E7%9A%84"><span class="toc-number">11.3.</span> <span class="toc-text">ACID怎么实现的?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#MVCC%E8%AF%A6%E8%A7%A3"><span class="toc-number">11.4.</span> <span class="toc-text">MVCC详解</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#12-%E8%B0%88%E8%B0%88%E4%BD%A0%E5%AF%B9spring%E7%9A%84%E7%90%86%E8%A7%A3"><span class="toc-number">12.</span> <span class="toc-text">12.谈谈你对spring的理解</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#13-springboot%E8%87%AA%E5%8A%A8%E9%85%8D%E7%BD%AE%E5%8E%9F%E7%90%86"><span class="toc-number">13.</span> <span class="toc-text">13.springboot自动配置原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#14-redis%E9%80%82%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">14.</span> <span class="toc-text">14.redis适用场景</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%EF%B8%8F%E2%83%A3-%E7%BC%93%E5%AD%98%E7%83%AD%E7%82%B9%E6%95%B0%E6%8D%AE"><span class="toc-number">14.1.</span> <span class="toc-text">1️⃣ 缓存热点数据</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%EF%B8%8F%E2%83%A3-%E5%88%86%E5%B8%83%E5%BC%8F-Session-%E5%AD%98%E5%82%A8"><span class="toc-number">14.2.</span> <span class="toc-text">2️⃣ 分布式 Session 存储</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%EF%B8%8F%E2%83%A3-%E8%AE%A1%E6%95%B0%E5%99%A8-%E6%8E%92%E8%A1%8C%E6%A6%9C-%E7%82%B9%E8%B5%9E%E7%B3%BB%E7%BB%9F"><span class="toc-number">14.3.</span> <span class="toc-text">3️⃣ 计数器 &#x2F; 排行榜 &#x2F; 点赞系统</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4%EF%B8%8F%E2%83%A3-%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81"><span class="toc-number">14.4.</span> <span class="toc-text">4️⃣ 分布式锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5%EF%B8%8F%E2%83%A3-%E9%99%90%E6%B5%81%EF%BC%88Rate-Limiter%EF%BC%89"><span class="toc-number">14.5.</span> <span class="toc-text">5️⃣ 限流（Rate Limiter）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6%EF%B8%8F%E2%83%A3-%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97-%E5%BC%82%E6%AD%A5%E4%BB%BB%E5%8A%A1"><span class="toc-number">14.6.</span> <span class="toc-text">6️⃣ 消息队列 &#x2F; 异步任务</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7%EF%B8%8F%E2%83%A3-%E5%9C%B0%E7%90%86%E4%BD%8D%E7%BD%AE%E6%9C%8D%E5%8A%A1%EF%BC%88GEO%EF%BC%89"><span class="toc-number">14.7.</span> <span class="toc-text">7️⃣ 地理位置服务（GEO）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8%EF%B8%8F%E2%83%A3-%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8%EF%BC%88%E9%98%B2%E6%AD%A2%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F%EF%BC%89"><span class="toc-number">14.8.</span> <span class="toc-text">8️⃣ 布隆过滤器（防止缓存穿透）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#15-RabbitMQ%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86"><span class="toc-number">15.</span> <span class="toc-text">15.RabbitMQ工作原理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B%E8%AF%A6%E8%A7%A3"><span class="toc-number">15.1.</span> <span class="toc-text">工作流程详解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">15.2.</span> <span class="toc-text">常见使用场景</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-history"></i><span>最近发布</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/posts/c45230cb.html" title="mysql面试题"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://s2.loli.net/2025/10/23/wfbr2eNcL1VvXIn.png?_r_=c8b8c4d9-3b05-f070-2b01-ec5fb5e468d4" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="mysql面试题"/></a><div class="content"><a class="title" href="/posts/c45230cb.html" title="mysql面试题">mysql面试题</a><time datetime="2025-10-27T03:31:36.000Z" title="发表于 2025-10-27 11:31:36">2025-10-27</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/66c016fb.html" title="JVM"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://s2.loli.net/2025/10/23/w3ErpsQhncfDed2.jpg?_r_=073fb3c1-1ed6-85dc-4b49-6bade417019f" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="JVM"/></a><div class="content"><a class="title" href="/posts/66c016fb.html" title="JVM">JVM</a><time datetime="2025-10-24T15:31:36.000Z" title="发表于 2025-10-24 23:31:36">2025-10-24</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/498cfd8e.html" title="并发编程"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://s2.loli.net/2025/10/23/w3ErpsQhncfDed2.jpg?_r_=e93610d2-afe5-62c9-ffac-34bc6ede57ce" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="并发编程"/></a><div class="content"><a class="title" href="/posts/498cfd8e.html" title="并发编程">并发编程</a><time datetime="2025-10-23T15:51:36.000Z" title="发表于 2025-10-23 23:51:36">2025-10-23</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/7edb9ee1.html" title="集合框架"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://s2.loli.net/2025/10/23/g4UkwyDri9BWZtE.jpg?_r_=15bc3fef-3044-c8b4-4d1c-cc585f957842" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="集合框架"/></a><div class="content"><a class="title" href="/posts/7edb9ee1.html" title="集合框架">集合框架</a><time datetime="2025-10-23T08:48:49.330Z" title="发表于 2025-10-23 16:48:49">2025-10-23</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/aff6963e.html" title="如何解决高并发下的库存抢购超卖少买问题？"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://s2.loli.net/2025/10/23/YUHOf5MZEItlGd3.jpg?_r_=1d335fd2-520a-5de8-b607-f2b3e5a780fa" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="如何解决高并发下的库存抢购超卖少买问题？"/></a><div class="content"><a class="title" href="/posts/aff6963e.html" title="如何解决高并发下的库存抢购超卖少买问题？">如何解决高并发下的库存抢购超卖少买问题？</a><time datetime="2025-10-23T04:24:36.000Z" title="发表于 2025-10-23 12:24:36">2025-10-23</time></div></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div id="workboard"><img class="workSituationImg boardsign" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://npm.elemecdn.com/anzhiyu-blog@2.0.4/img/badge/安知鱼-上班摸鱼中.svg" alt="距离月入25k也就还差一个大佬带我~" title="距离月入25k也就还差一个大佬带我~"/><div id="runtimeTextTip"></div></div><p id="ghbdages"><a class="github-badge" target="_blank" href="https://hexo.io/" style="margin-inline:5px" data-title="博客框架为Hexo_v5.4.0" title="博客框架为Hexo_v5.4.0"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://npm.elemecdn.com/anzhiyu-blog@2.1.5/img/badge/Frame-Hexo.svg" alt="博客框架为Hexo_v5.4.0"/></a><a class="github-badge" target="_blank" href="https://blog.anheyu.com/" style="margin-inline:5px" data-title="本站使用AnZhiYu主题" title="本站使用AnZhiYu主题"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://npm.elemecdn.com/anzhiyu-theme-static@1.0.9/img/Theme-AnZhiYu-2E67D3.svg" alt="本站使用AnZhiYu主题"/></a><a class="github-badge" target="_blank" href="https://www.dogecloud.com/" style="margin-inline:5px" data-title="本站使用多吉云为静态资源提供CDN加速" title="本站使用多吉云为静态资源提供CDN加速"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://npm.elemecdn.com/anzhiyu-blog@2.2.0/img/badge/CDN-多吉云-3693F3.svg" alt="本站使用多吉云为静态资源提供CDN加速"/></a><a class="github-badge" target="_blank" href="https://github.com/" style="margin-inline:5px" data-title="本站项目由Github托管" title="本站项目由Github托管"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://npm.elemecdn.com/anzhiyu-blog@2.1.5/img/badge/Source-Github.svg" alt="本站项目由Github托管"/></a><a class="github-badge" target="_blank" href="http://creativecommons.org/licenses/by-nc-sa/4.0/" style="margin-inline:5px" data-title="本站采用知识共享署名-非商业性使用-相同方式共享4.0国际许可协议进行许可" title="本站采用知识共享署名-非商业性使用-相同方式共享4.0国际许可协议进行许可"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://npm.elemecdn.com/anzhiyu-blog@2.2.0/img/badge/Copyright-BY-NC-SA.svg" alt="本站采用知识共享署名-非商业性使用-相同方式共享4.0国际许可协议进行许可"/></a></p></div><div id="footer-bar"><div class="footer-bar-links"><div class="footer-bar-left"><div id="footer-bar-tips"><div class="copyright">&copy;2020 - 2025 By <a class="footer-bar-link" href="/" title="北川" target="_blank">北川</a></div></div><div id="footer-type-tips"></div></div><div class="footer-bar-right"><a class="footer-bar-link" target="_blank" rel="noopener" href="https://github.com/anzhiyu-c/hexo-theme-anzhiyu" title="主题">主题</a></div></div></div></footer></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="sidebar-site-data site-data is-center"><a href="/archives/" title="archive"><div class="headline">文章</div><div class="length-num">16</div></a><a href="/tags/" title="tag"><div class="headline">标签</div><div class="length-num">18</div></a><a href="/categories/" title="category"><div class="headline">分类</div><div class="length-num">5</div></a></div><span class="sidebar-menu-item-title">功能</span><div class="sidebar-menu-item"><a class="darkmode_switchbutton menu-child" href="javascript:void(0);" title="显示模式"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i><span>显示模式</span></a></div><div class="back-menu-list-groups"><div class="back-menu-list-group"><div class="back-menu-list-title">网页</div><div class="back-menu-list"><a class="back-menu-item" target="_blank" rel="noopener" href="https://blog.anheyu.com/" title="博客"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/favicon.png" alt="博客"/><span class="back-menu-item-text">博客</span></a></div></div></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 文章</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/archives/"><i class="anzhiyufont anzhiyu-icon-box-archive faa-tada" style="font-size: 0.9em;"></i><span> 隧道</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/categories/"><i class="anzhiyufont anzhiyu-icon-shapes faa-tada" style="font-size: 0.9em;"></i><span> 分类</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/tags/"><i class="anzhiyufont anzhiyu-icon-tags faa-tada" style="font-size: 0.9em;"></i><span> 标签</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 友链</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/link/"><i class="anzhiyufont anzhiyu-icon-link faa-tada" style="font-size: 0.9em;"></i><span> 友人帐</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/fcircle/"><i class="anzhiyufont anzhiyu-icon-artstation faa-tada" style="font-size: 0.9em;"></i><span> 朋友圈</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/comments/"><i class="anzhiyufont anzhiyu-icon-envelope faa-tada" style="font-size: 0.9em;"></i><span> 留言板</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 我的</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/music/?id=2898229193&amp;server=netease"><i class="anzhiyufont anzhiyu-icon-music faa-tada" style="font-size: 0.9em;"></i><span> 音乐馆</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/album/"><i class="anzhiyufont anzhiyu-icon-images faa-tada" style="font-size: 0.9em;"></i><span> 相册集</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/air-conditioner/"><i class="anzhiyufont anzhiyu-icon-fan faa-tada" style="font-size: 0.9em;"></i><span> 小空调</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 关于</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/about/"><i class="anzhiyufont anzhiyu-icon-paper-plane faa-tada" style="font-size: 0.9em;"></i><span> 关于本人</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/essay/"><i class="anzhiyufont anzhiyu-icon-lightbulb faa-tada" style="font-size: 0.9em;"></i><span> 闲言碎语</span></a></li></ul></div></div><span class="sidebar-menu-item-title">标签</span><div class="card-tags"><div class="item-headline"></div><div class="card-tag-cloud"><a href="/tags/JVM%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/" style="font-size: 0.88rem;">JVM内存模型<sup>1</sup></a><a href="/tags/JVM%E8%B0%83%E4%BC%98/" style="font-size: 0.88rem;">JVM调优<sup>1</sup></a><a href="/tags/java%E6%95%99%E7%A8%8B/" style="font-size: 0.88rem;">java教程<sup>1</sup></a><a href="/tags/mysql/" style="font-size: 0.88rem;">mysql<sup>1</sup></a><a href="/tags/%E5%87%BD%E6%95%B0/" style="font-size: 0.88rem;">函数<sup>1</sup></a><a href="/tags/%E5%8F%8D%E5%B0%84/" style="font-size: 0.88rem;">反射<sup>1</sup></a><a href="/tags/%E5%A4%8D%E4%B9%A0/" style="font-size: 0.88rem;">复习<sup>1</sup></a><a href="/tags/%E5%A4%8D%E4%B9%A0-%E5%8F%98%E9%87%8F/" style="font-size: 0.88rem;">复习 变量<sup>1</sup></a><a href="/tags/%E5%B7%A5%E5%85%B7/" style="font-size: 0.88rem;">工具<sup>1</sup></a><a href="/tags/%E5%B9%B6%E5%8F%91/" style="font-size: 0.88rem;">并发<sup>1</sup></a><a href="/tags/%E6%83%85%E6%84%9F/" style="font-size: 0.88rem;">情感<sup>1</sup></a><a href="/tags/%E6%8A%BD%E8%B1%A1%E7%B1%BB-%E6%8E%A5%E5%8F%A3/" style="font-size: 0.88rem;">抽象类 接口<sup>1</sup></a><a href="/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/" style="font-size: 0.88rem;">数据库<sup>1</sup></a><a href="/tags/%E6%AF%8F%E6%97%A5%E9%9D%A2%E8%AF%95/" style="font-size: 0.88rem;">每日面试<sup>2</sup></a><a href="/tags/%E7%94%B5%E5%95%86-%E8%AE%A2%E5%8D%95/" style="font-size: 0.88rem;">电商,订单<sup>1</sup></a><a href="/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" style="font-size: 0.88rem;">设计模式<sup>1</sup></a><a href="/tags/%E8%B6%85%E5%8D%96-%E5%BA%93%E5%AD%98/" style="font-size: 0.88rem;">超卖 , 库存<sup>1</sup></a><a href="/tags/%E9%9B%86%E5%90%88/" style="font-size: 0.88rem;">集合<sup>1</sup></a></div></div><hr/></div></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="anzhiyufont anzhiyu-icon-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">简</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="anzhiyufont anzhiyu-icon-arrows-left-right"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="anzhiyufont anzhiyu-icon-gear"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="anzhiyufont anzhiyu-icon-list-ul"></i></button><button id="chat-btn" type="button" title="聊天"><i class="anzhiyufont anzhiyu-icon-comment-sms"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="anzhiyufont anzhiyu-icon-comments"></i></a><a id="switch-commentBarrage" href="javascript:anzhiyu.switchCommentBarrage();" title="开关弹幕"><i class="anzhiyufont anzhiyu-icon-danmu"></i></a><button id="go-up" type="button" title="回到顶部"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></button></div></div><div id="nav-music"><a id="nav-music-hoverTips" onclick="anzhiyu.musicToggle()" accesskey="m">播放音乐</a><div id="console-music-bg"></div><meting-js id="8152976493" server="netease" type="playlist" mutex="true" preload="none" theme="var(--anzhiyu-main)" data-lrctype="0" order="random"></meting-js></div><div id="rightMenu"><div class="rightMenu-group rightMenu-small"><div class="rightMenu-item" id="menu-backward"><i class="anzhiyufont anzhiyu-icon-arrow-left"></i></div><div class="rightMenu-item" id="menu-forward"><i class="anzhiyufont anzhiyu-icon-arrow-right"></i></div><div class="rightMenu-item" id="menu-refresh"><i class="anzhiyufont anzhiyu-icon-arrow-rotate-right" style="font-size: 1rem;"></i></div><div class="rightMenu-item" id="menu-top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></div></div><div class="rightMenu-group rightMenu-line rightMenuPlugin"><div class="rightMenu-item" id="menu-copytext"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制选中文本</span></div><div class="rightMenu-item" id="menu-pastetext"><i class="anzhiyufont anzhiyu-icon-paste"></i><span>粘贴文本</span></div><a class="rightMenu-item" id="menu-commenttext"><i class="anzhiyufont anzhiyu-icon-comment-medical"></i><span>引用到评论</span></a><div class="rightMenu-item" id="menu-newwindow"><i class="anzhiyufont anzhiyu-icon-window-restore"></i><span>新窗口打开</span></div><div class="rightMenu-item" id="menu-copylink"><i class="anzhiyufont anzhiyu-icon-link"></i><span>复制链接地址</span></div><div class="rightMenu-item" id="menu-copyimg"><i class="anzhiyufont anzhiyu-icon-images"></i><span>复制此图片</span></div><div class="rightMenu-item" id="menu-downloadimg"><i class="anzhiyufont anzhiyu-icon-download"></i><span>下载此图片</span></div><div class="rightMenu-item" id="menu-newwindowimg"><i class="anzhiyufont anzhiyu-icon-window-restore"></i><span>新窗口打开图片</span></div><div class="rightMenu-item" id="menu-search"><i class="anzhiyufont anzhiyu-icon-magnifying-glass"></i><span>站内搜索</span></div><div class="rightMenu-item" id="menu-searchBaidu"><i class="anzhiyufont anzhiyu-icon-magnifying-glass"></i><span>百度搜索</span></div><div class="rightMenu-item" id="menu-music-toggle"><i class="anzhiyufont anzhiyu-icon-play"></i><span>播放音乐</span></div><div class="rightMenu-item" id="menu-music-back"><i class="anzhiyufont anzhiyu-icon-backward"></i><span>切换到上一首</span></div><div class="rightMenu-item" id="menu-music-forward"><i class="anzhiyufont anzhiyu-icon-forward"></i><span>切换到下一首</span></div><div class="rightMenu-item" id="menu-music-playlist" onclick="window.open(&quot;https://y.qq.com/n/ryqq/playlist/8152976493&quot;, &quot;_blank&quot;);" style="display: none;"><i class="anzhiyufont anzhiyu-icon-radio"></i><span>查看所有歌曲</span></div><div class="rightMenu-item" id="menu-music-copyMusicName"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制歌名</span></div></div><div class="rightMenu-group rightMenu-line rightMenuOther"><a class="rightMenu-item menu-link" id="menu-randomPost"><i class="anzhiyufont anzhiyu-icon-shuffle"></i><span>随便逛逛</span></a><a class="rightMenu-item menu-link" href="/categories/"><i class="anzhiyufont anzhiyu-icon-cube"></i><span>博客分类</span></a><a class="rightMenu-item menu-link" href="/tags/"><i class="anzhiyufont anzhiyu-icon-tags"></i><span>文章标签</span></a></div><div class="rightMenu-group rightMenu-line rightMenuOther"><a class="rightMenu-item" id="menu-copy" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制地址</span></a><a class="rightMenu-item" id="menu-commentBarrage" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-message"></i><span class="menu-commentBarrage-text">关闭热评</span></a><a class="rightMenu-item" id="menu-darkmode" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i><span class="menu-darkmode-text">深色模式</span></a><a class="rightMenu-item" id="menu-translate" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-language"></i><span>轉為繁體</span></a></div></div><div id="rightmenu-mask"></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.cbd.int/@fancyapps/ui@5.0.20/dist/fancybox/fancybox.umd.js"></script><script src="https://cdn.cbd.int/instant.page@5.2.0/instantpage.js" type="module"></script><script src="https://cdn.cbd.int/vanilla-lazyload@17.8.4/dist/lazyload.iife.min.js"></script><script src="https://cdn.cbd.int/node-snackbar@0.1.16/dist/snackbar.min.js"></script><canvas id="universe"></canvas><script async src="https://npm.elemecdn.com/anzhiyu-theme-static@1.0.0/dark/dark.js"></script><script>// 消除控制台打印
var HoldLog = console.log;
console.log = function () {};
let now1 = new Date();
queueMicrotask(() => {
  const Log = function () {
    HoldLog.apply(console, arguments);
  }; //在恢复前输出日志
  const grt = new Date("04/01/2023 00:00:00"); //此处修改你的建站时间或者网站上线时间
  now1.setTime(now1.getTime() + 250);
  const days = (now1 - grt) / 1000 / 60 / 60 / 24;
  const dnum = Math.floor(days);
  const ascll = [
    `欢迎使用安知鱼!`,
    `生活明朗, 万物可爱`,
    `
        
       █████╗ ███╗   ██╗███████╗██╗  ██╗██╗██╗   ██╗██╗   ██╗
      ██╔══██╗████╗  ██║╚══███╔╝██║  ██║██║╚██╗ ██╔╝██║   ██║
      ███████║██╔██╗ ██║  ███╔╝ ███████║██║ ╚████╔╝ ██║   ██║
      ██╔══██║██║╚██╗██║ ███╔╝  ██╔══██║██║  ╚██╔╝  ██║   ██║
      ██║  ██║██║ ╚████║███████╗██║  ██║██║   ██║   ╚██████╔╝
      ╚═╝  ╚═╝╚═╝  ╚═══╝╚══════╝╚═╝  ╚═╝╚═╝   ╚═╝    ╚═════╝
        
        `,
    "已上线",
    dnum,
    "天",
    "©2020 By 安知鱼 V1.6.8",
  ];
  const ascll2 = [`NCC2-036`, `调用前置摄像头拍照成功，识别为【小笨蛋】.`, `Photo captured: `, `🤪`];

  setTimeout(
    Log.bind(
      console,
      `\n%c${ascll[0]} %c ${ascll[1]} %c ${ascll[2]} %c${ascll[3]}%c ${ascll[4]}%c ${ascll[5]}\n\n%c ${ascll[6]}\n`,
      "color:#425AEF",
      "",
      "color:#425AEF",
      "color:#425AEF",
      "",
      "color:#425AEF",
      ""
    )
  );
  setTimeout(
    Log.bind(
      console,
      `%c ${ascll2[0]} %c ${ascll2[1]} %c \n${ascll2[2]} %c\n${ascll2[3]}\n`,
      "color:white; background-color:#4fd953",
      "",
      "",
      'background:url("https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/tinggge.gif") no-repeat;font-size:450%'
    )
  );

  setTimeout(Log.bind(console, "%c WELCOME %c 你好，小笨蛋.", "color:white; background-color:#4f90d9", ""));

  setTimeout(
    console.warn.bind(
      console,
      "%c ⚡ Powered by 安知鱼 %c 你正在访问 北川 的博客.",
      "color:white; background-color:#f0ad4e",
      ""
    )
  );

  setTimeout(Log.bind(console, "%c W23-12 %c 你已打开控制台.", "color:white; background-color:#4f90d9", ""));

  setTimeout(
    console.warn.bind(console, "%c S013-782 %c 你现在正处于监控中.", "color:white; background-color:#d9534f", "")
  );
});</script><script async src="/anzhiyu/random.js"></script><script async="async">(function () {
  var grt = new Date("04/01/2023 00:00:00"); //设置网站上线时间
  var now = new Date();
  var dnum;
  var hnum;
  var mnum;
  var snum;
  var nowHour;

  // 计算并更新天数、小时数、分钟数和秒数
  function updateTime() {
    now = new Date(); // 更新 now 的值
    nowHour = now.getHours(); // 更新 nowHour 的值
    var days = (now - grt) / 1000 / 60 / 60 / 24;
    dnum = Math.floor(days);
    var hours = (now - grt) / 1000 / 60 / 60 - 24 * dnum;
    hnum = Math.floor(hours);
    if (String(hnum).length == 1) {
      hnum = "0" + hnum;
    }
    var minutes = (now - grt) / 1000 / 60 - 24 * 60 * dnum - 60 * hnum;
    mnum = Math.floor(minutes);
    if (String(mnum).length == 1) {
      mnum = "0" + mnum;
    }
    var seconds = (now - grt) / 1000 - 24 * 60 * 60 * dnum - 60 * 60 * hnum - 60 * mnum;
    snum = Math.round(seconds);
    if (String(snum).length == 1) {
      snum = "0" + snum;
    }
  }

  // 更新网页中显示的网站运行时间
  function updateHtml() {
    const footer = document.getElementById("footer");
    if (!footer) return
    let currentTimeHtml = "";
    if (nowHour < 18 && nowHour >= 9) {
      // 如果是上班时间，默认就是"安知鱼-上班摸鱼中.svg"图片，不需要更改
      currentTimeHtml = `本站居然运行了 ${dnum} 天<span id='runtime'> ${hnum} 小时 ${mnum} 分 ${snum} 秒 </span><i class='anzhiyufont anzhiyu-icon-heartbeat' style='color:red'></i>`;
    } else {
      // 如果是下班时间，插入"安知鱼-下班啦.svg"图片
      let img = document.querySelector("#workboard .workSituationImg");
      img.src = "";
      img.title = "";
      img.alt = "";

      currentTimeHtml = `本站居然运行了 ${dnum} 天<span id='runtime'> ${hnum} 小时 ${mnum} 分 ${snum} 秒 </span><i class='anzhiyufont anzhiyu-icon-heartbeat' style='color:red'></i>`;
    }

    if (document.getElementById("runtimeTextTip")) {
      document.getElementById("runtimeTextTip").innerHTML = currentTimeHtml;
    }
  }

  setInterval(() => {
    updateTime();
    updateHtml();
  }, 1000);
})();</script><div class="js-pjax"><script>(() => {
  const initValine = () => {
    const valine = new Valine(Object.assign({
      el: '#vcomment',
      appId: '4GK2IcRZ0PX28gP4kGsW08qs-gzGzoHsz',
      appKey: 'TjKeHNK7GJrGTYuKYzGzh8yg',
      avatar: 'mp',
      serverURLs: '',
      emojiMaps: {"tv_doge":"6ea59c827c414b4a2955fe79e0f6fd3dcd515e24.png","tv_亲亲":"a8111ad55953ef5e3be3327ef94eb4a39d535d06.png","tv_偷笑":"bb690d4107620f1c15cff29509db529a73aee261.png","tv_再见":"180129b8ea851044ce71caf55cc8ce44bd4a4fc8.png","tv_冷漠":"b9cbc755c2b3ee43be07ca13de84e5b699a3f101.png","tv_发怒":"34ba3cd204d5b05fec70ce08fa9fa0dd612409ff.png","tv_发财":"34db290afd2963723c6eb3c4560667db7253a21a.png","tv_可爱":"9e55fd9b500ac4b96613539f1ce2f9499e314ed9.png","tv_吐血":"09dd16a7aa59b77baa1155d47484409624470c77.png","tv_呆":"fe1179ebaa191569b0d31cecafe7a2cd1c951c9d.png","tv_呕吐":"9f996894a39e282ccf5e66856af49483f81870f3.png","tv_困":"241ee304e44c0af029adceb294399391e4737ef2.png","tv_坏笑":"1f0b87f731a671079842116e0991c91c2c88645a.png","tv_大佬":"093c1e2c490161aca397afc45573c877cdead616.png","tv_大哭":"23269aeb35f99daee28dda129676f6e9ea87934f.png","tv_委屈":"d04dba7b5465779e9755d2ab6f0a897b9b33bb77.png","tv_害羞":"a37683fb5642fa3ddfc7f4e5525fd13e42a2bdb1.png","tv_尴尬":"7cfa62dafc59798a3d3fb262d421eeeff166cfa4.png","tv_微笑":"70dc5c7b56f93eb61bddba11e28fb1d18fddcd4c.png","tv_思考":"90cf159733e558137ed20aa04d09964436f618a1.png","tv_惊吓":"0d15c7e2ee58e935adc6a7193ee042388adc22af.png"},
      path: window.location.pathname,
      visitor: false
    }, null))
  }

  const loadValine = async () => {
    if (typeof Valine === 'function') initValine()
    else {
      await getScript('https://cdn.cbd.int/valine@1.5.1/dist/Valine.min.js')
      initValine()
    }
  }

  if ('Valine' === 'Valine' || !false) {
    if (false) anzhiyu.loadComment(document.getElementById('vcomment'),loadValine)
    else setTimeout(loadValine, 0)
  } else {
    window.loadOtherComment = loadValine
  }
})()</script><input type="hidden" name="page-type" id="page-type" value="post"></div><script src="https://cdn.cbd.int/blueimp-md5@2.19.0/js/md5.min.js"></script><script>window.addEventListener('load', () => {
  const changeContent = (content) => {
    if (content === '') return content

    content = content.replace(/<img.*?src="(.*?)"?[^\>]+>/ig, '[图片]') // replace image link
    content = content.replace(/<a[^>]+?href=["']?([^"']+)["']?[^>]*>([^<]+)<\/a>/gi, '[链接]') // replace url
    content = content.replace(/<pre><code>.*?<\/pre>/gi, '[代码]') // replace code
    content = content.replace(/<[^>]+>/g,"") // remove html tag

    if (content.length > 150) {
      content = content.substring(0,150) + '...'
    }
    return content
  }

  const getIcon = (icon, mail) => {
    if (icon) return icon
    let defaultIcon = '?d=mp'
    let iconUrl = `https://gravatar.loli.net/avatar/${md5(mail.toLowerCase()) + defaultIcon}`
    return iconUrl
  }

  const generateHtml = array => {
    let result = ''

    if (array.length) {
      for (let i = 0; i < array.length; i++) {
        result += '<div class=\'aside-list-item\'>'

        if (true) {
          const name = 'data-lazy-src'
          result += `<a href='${array[i].url}' class='thumbnail'><img ${name}='${array[i].avatar}' alt='${array[i].nick}'></a>`
        }

        result += `<div class='content'>
        <a class='comment' href='${array[i].url}' title='${array[i].content}'>${array[i].content}</a>
        <div class='name'><span>${array[i].nick} / </span><time datetime="${array[i].date}">${anzhiyu.diffDate(array[i].date, true)}</time></div>
        </div></div>`
      }
    } else {
      result += '没有评论'
    }

    let $dom = document.querySelector('#card-newest-comments .aside-list')
    $dom.innerHTML= result
    window.lazyLoadInstance && window.lazyLoadInstance.update()
    window.pjax && window.pjax.refresh($dom)
  }

  const getComment = () => {
    const serverURL = 'https://4GK2IcRZ.api.lncldglobal.com'

    var settings = {
      "method": "GET",
      "headers": {
        "X-LC-Id": '4GK2IcRZ0PX28gP4kGsW08qs-gzGzoHsz',
        "X-LC-Key": 'TjKeHNK7GJrGTYuKYzGzh8yg',
        "Content-Type": "application/json"
      },
    }

    fetch(`${serverURL}/1.1/classes/Comment?limit=6&order=-createdAt`,settings)
      .then(response => response.json())
      .then(data => {
        const valineArray = data.results.map(function (e) {
          return {
            'avatar': getIcon(e.QQAvatar, e.mail),
            'content': changeContent(e.comment),
            'nick': e.nick,
            'url': e.url + '#' + e.objectId,
            'date': e.updatedAt,
          }
        })
        saveToLocal.set('valine-newest-comments', JSON.stringify(valineArray), 10/(60*24))
        generateHtml(valineArray)
      }).catch(e => {
        const $dom = document.querySelector('#card-newest-comments .aside-list')
        $dom.textContent= "无法获取评论，请确认相关配置是否正确"
      }) 
  }

  const newestCommentInit = () => {
    if (document.querySelector('#card-newest-comments .aside-list')) {
      const data = saveToLocal.get('valine-newest-comments')
      if (data) {
        generateHtml(JSON.parse(data))
      } else {
        getComment()
      }
    }
  }

  newestCommentInit()
  document.addEventListener('pjax:complete', newestCommentInit)
})</script><script>var visitorMail = "visitor@anheyu.com";
</script><script async data-pjax src="https://cdn.cbd.int/anzhiyu-theme-static@1.0.0/waterfall/waterfall.js"></script><script src="https://lf3-cdn-tos.bytecdntp.com/cdn/expire-1-M/qrcodejs/1.0.0/qrcode.min.js"></script><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.1.9/icon/ali_iconfont_css.css"><script src="//code.tidio.co/4nifo6zdbrmyjsngh2yzxwbnlhrvshrf.js" async="async"></script><script>(() => {
  const isChatBtn = true
  const isChatHideShow = true

  if (isChatBtn) {
    let isShow = false
    const close = () => {
      window.tidioChatApi.hide()
      isShow = false
    }
    
    const open = () => {
      window.tidioChatApi.open()
      window.tidioChatApi.show()
      isShow = true
    }

    const onTidioChatApiReady = () => {
      window.tidioChatApi.hide()
      window.tidioChatApi.on("close", close)
    }
    if (window.tidioChatApi) {
      window.tidioChatApi.on("ready", onTidioChatApiReady)
    } else {
      document.addEventListener("tidioChat-ready", onTidioChatApiReady)
    }

    window.chatBtnFn = () => {
      if (!window.tidioChatApi) return
      isShow ? close() : open()
    }
  } else if (isChatHideShow) {
    window.chatBtn = {
      hide: () => {
        window.tidioChatApi && window.tidioChatApi.hide()
      },
      show: () => {
        window.tidioChatApi && window.tidioChatApi.show()
      }
    }
  }
})()</script><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.0.0/aplayer/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.cbd.int/anzhiyu-blog-static@1.0.1/js/APlayer.min.js"></script><script src="https://cdn.cbd.int/hexo-anzhiyu-music@1.0.1/assets/js/Meting2.min.js"></script><script src="https://cdn.cbd.int/pjax@0.2.8/pjax.min.js"></script><script>let pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]
var pjax = new Pjax({
  elements: 'a:not([target="_blank"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {
  // removeEventListener scroll 
  anzhiyu.removeGlobalFnEvent('pjax')
  anzhiyu.removeGlobalFnEvent('themeChange')

  document.getElementById('rightside').classList.remove('rightside-show')
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')
})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()
})

document.addEventListener('pjax:error', e => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script charset="UTF-8" src="https://cdn.cbd.int/anzhiyu-theme-static@1.1.5/accesskey/accesskey.js"></script></div><div id="popup-window"><div class="popup-window-title">通知</div><div class="popup-window-divider"></div><div class="popup-window-content"><div class="popup-tip">你好呀</div><div class="popup-link"><i class="anzhiyufont anzhiyu-icon-arrow-circle-right"></i></div></div></div></body></html>