<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no"><title>并发编程 | Wsk Blog</title><meta name="keywords" content="并发"><meta name="author" content="Wsk,2047891093@qq.com"><meta name="copyright" content="Wsk"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#f7f9fe"><meta name="mobile-web-app-capable" content="yes"><meta name="apple-touch-fullscreen" content="yes"><meta name="apple-mobile-web-app-title" content="并发编程"><meta name="application-name" content="并发编程"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="#f7f9fe"><meta property="og:type" content="article"><meta property="og:title" content="并发编程"><meta property="og:url" content="https://wsk0404.github.io/posts/498cfd8e.html"><meta property="og:site_name" content="Wsk Blog"><meta property="og:description" content="什么是线程？什么是进程？进程是系统资源分配的基本单位，拥有独立的内存空间，不同进程之间可以并发执行，创建新进程需要分类独立的内存空间和系统资源，成本高。一个进程的崩溃不会影响其他进程 线程是进程中的一个执行单元，是cpu调度的基本单位，共享所属进程的资源，只拥有自己的栈和寄存器；同一个进程内可以有多"><meta property="og:locale" content="zh-CN"><meta property="og:image" content="https://s2.loli.net/2025/10/23/w3ErpsQhncfDed2.jpg?_r_=e93610d2-afe5-62c9-ffac-34bc6ede57ce"><meta property="article:author" content="Wsk"><meta property="article:tag" content="博客,笔记,学习"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://s2.loli.net/2025/10/23/w3ErpsQhncfDed2.jpg?_r_=e93610d2-afe5-62c9-ffac-34bc6ede57ce"><meta name="description" content="什么是线程？什么是进程？进程是系统资源分配的基本单位，拥有独立的内存空间，不同进程之间可以并发执行，创建新进程需要分类独立的内存空间和系统资源，成本高。一个进程的崩溃不会影响其他进程 线程是进程中的一个执行单元，是cpu调度的基本单位，共享所属进程的资源，只拥有自己的栈和寄存器；同一个进程内可以有多"><link rel="shortcut icon" href="/favicon.ico"><link rel="canonical" href="https://wsk0404.github.io/posts/498cfd8e"><link rel="preconnect" href="//cdn.cbd.int"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><meta name="google-site-verification" content="xxx"/><meta name="baidu-site-verification" content="code-xxx"/><meta name="msvalidate.01" content="xxx"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.cbd.int/node-snackbar@0.1.16/dist/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.cbd.int/@fancyapps/ui@5.0.20/dist/fancybox/fancybox.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://npm.elemecdn.com/anzhiyu-theme-static@1.0.0/swiper/swiper.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  linkPageTop: undefined,
  peoplecanvas: {"enable":true,"img":"https://upload-bbs.miyoushe.com/upload/2023/09/03/125766904/ee23df8517f3c3e3efc4145658269c06_5714860933110284659.png"},
  postHeadAiDescription: undefined,
  diytitle: {"enable":true,"leaveTitle":"w(ﾟДﾟ)w 不要走！再看看嘛！","backTitle":"♪(^∇^*)欢迎肥来！"},
  LA51: undefined,
  greetingBox: {"enable":true,"default":"晚上好👋","list":[{"greeting":"晚安😴","startTime":0,"endTime":5},{"greeting":"早上好鸭👋, 祝你一天好心情！","startTime":6,"endTime":9},{"greeting":"上午好👋, 状态很好，鼓励一下～","startTime":10,"endTime":10},{"greeting":"11点多啦, 在坚持一下就吃饭啦～","startTime":11,"endTime":11},{"greeting":"午安👋, 宝贝","startTime":12,"endTime":14},{"greeting":"🌈充实的一天辛苦啦！","startTime":14,"endTime":18},{"greeting":"19点喽, 奖励一顿丰盛的大餐吧🍔。","startTime":19,"endTime":19},{"greeting":"晚上好👋, 在属于自己的时间好好放松😌~","startTime":20,"endTime":24}]},
  twikooEnvId: '',
  commentBarrageConfig:{"enable":true,"maxBarrage":1,"barrageTime":4000,"accessToken":"","mailMd5":"3932F24FA213E964B6B1B0FD091F88CE"},
  root: '/',
  preloader: {"source":3},
  friends_vue_info: {"apiurl":"https://friends.anheyu.com/"},
  navMusic: true,
  mainTone: {"mode":"both","api":"https://img2color-go.vercel.app/api?img=","cover_change":true},
  authorStatus: {"skills":["🤖️ 数码科技爱好者","🔍 分享与热心帮助","🔨 设计开发一条龙","🏃 脚踏实地行动派"]},
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简","rightMenuMsgToTraditionalChinese":"转为繁体","rightMenuMsgToSimplifiedChinese":"转为简体"},
  noticeOutdate: {"limitDay":365,"position":"top","messagePrev":"It has been","messageNext":"days since the last update, the content of the article may be outdated."},
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":330},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: true,
    simplehomepage: false,
    post: true
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"copy":true,"copyrightEbable":true,"limitCount":50,"languages":{"author":"作者: Wsk","link":"链接: ","source":"来源: Wsk Blog","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。","copySuccess":"复制成功，复制和转载请标注本文地址"}},
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#425AEF","bgDark":"#1f1f1f","position":"top-center"},
  source: {
    justifiedGallery: {
      js: 'https://cdn.cbd.int/flickr-justified-gallery@2.1.2/dist/fjGallery.min.js',
      css: 'https://cdn.cbd.int/flickr-justified-gallery@2.1.2/dist/fjGallery.css'
    }
  },
  isPhotoFigcaption: true,
  islazyload: true,
  isAnchor: false,
  shortcutKey: undefined,
  autoDarkmode: true
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  configTitle: 'Wsk Blog',
  title: '并发编程',
  postAI: '',
  pageFillDescription: '什么是线程？什么是进程？, Java创建线程有哪几种方式, 继承自Thread类, 实现Runnable接口, 实现 Callable 接口（带返回值）, ** 通过线程池进行创建**, 什么是线程池？为什么要使用线程池？, ThreadPoolExecutor 都有哪些核心参数？, 线程池的运行原理是什么？, 如何优雅地关闭线程池？, 线程的生命周期？, 线程的常用方法, yield和join的区别, 1. 作用不同, 2. 阻塞行为不同, 3. 对锁的影响不同, 4. 使用场景不同, wait和sleep的区别, 1. 所属类不同, 2. 对锁的处理不同（最核心区别）, 3. 使用场景不同, 4. 唤醒方式不同, 线程锁, 锁的分类, 你知道Java中有哪些锁吗？, Synchronized 用过吗其原理是什么, 1. 锁的载体：对象头（Object Header）, 2. 锁的升级：从无锁到重量级锁, Lock 与 synchronized 的对比, ReentrantLock****的底层原理, 1. CAS 尝试加锁, 2. 可重入性, 3. 入队与阻塞, 公平锁与非公平锁, 解释一下volatile关键字的作用和使用场景。, 一、volatile 的核心作用, 1. 保证可见性, 2. 禁止指令重排序, volatile 的实现原理是什么？, volatile 与 synchronized 的区别, ReentrantLock的底层原理, 多线程如何获取异步执行结果, （1）Future + Callable（最常用）, （2）CompletableFuture（Java 8+非阻塞式）, 什么是线程死锁？死锁如何产生？, ThreadLocal 原理？底层如何防止内存泄漏？, 什么是线程安全？怎么保证线程安全？, 如何保证线程安全（从思想到实现）, 不共享（线程封闭 Thread Confinement）, 不可变（Immutable）对象, 互斥锁（Synchronized x2F Lock）, 原子类（CAS + volatile 实现无锁并发）, 什么是可见性、原子性、有序性？, 可见性（Visibility）, 原子性（Atomicity）, 有序性（Ordering）, AQS, AQS 的两种模式, CAS, CAS 的优点, CAS 的问题（面试高频）, 1. ABA 问题, 2. 自旋开销大, 3. 只能保证单个变量的原子性什么是线程什么是进程进程是系统资源分配的基本单位拥有独立的内存空间不同进程之间可以并发执行创建新进程需要分类独立的内存空间和系统资源成本高一个进程的崩溃不会影响其他进程线程是进程中的一个执行单元是调度的基本单位共享所属进程的资源只拥有自己的栈和寄存器同一个进程内可以有多个线程并发执行创建新线程成本低一个线程崩溃可能导致整个进程崩溃创建线程有哪几种方式继承自类定义类继承类重写方法定义线程执行体创建子类对象并调用方法启动线程线程执行的逻辑创建并启动线程实现接口定义类实现接口实现方法创建实现类对象将其作为参数传递给构造器再调用方法线程执行的逻辑创建并启动线程实现接口带返回值定义类实现接口指定返回值类型实现方法定义线程执行体并返回结果通过包装实例再将传递给调用启动线程通过获取返回值实现接口指定返回值类型为重写方法定义任务逻辑并返回结果任务开始执行模拟任务执行如计算模拟耗时操作任务执行完毕结果为返回计算结果创建实例用包装用于接收结果启动线程实现了可作为的参数获取结果方法会阻塞直到任务完成总结果通过线程池进行创建使用工厂类创建线程池简单快捷固定大小线程池可缓存线程池单线程化线程池使用自定义线程池推荐方式使用创建定时任务线程池什么是线程池为什么要使用线程池线程池是采用池化思想管理线程的工具就像一个容器里面存放着一定数量的线程它基于包中的类及其体系实现使用线程池有诸多好处比如降低资源消耗通过重用已存在的线程减少线程创建和销毁的开销都有哪些核心参数有个核心参数分别是核心线程数最大线程数空闲线程超时时间时间单位阻塞队列拒绝策略线程工厂常见队列类型有界数组队列需指定容量如防止内存溢出推荐适用于需要严格控制任务数量防止资源过度消耗的场景无界链表队列默认容量可能因任务过多导致谨慎使用当任务产生的速度相对较慢或者系统资源足够充足能够处理大量任务时可以使用无界队列它可以保证任务不会因为队列满而被拒绝但需要注意可能会导致内存占用过高的问题同步队列不存储任务直接传递给线程适合场景优先级队列按任务优先级排序执行内置种拒绝策略默认直接抛出中断任务提交让提交任务的线程自己执行该任务减缓提交速度适用于并发不高的场景默默丢弃新任务不抛出异常可能丢失任务需谨慎丢弃队列中最旧的任务然后尝试提交新任务可能丢失旧任务自定义策略实现接口如记录日志持久化任务到数据库后续重试线程池的运行原理是什么线程池刚创建时没有线程当调用方法添加任务时会进行如下判断如果正在运行的线程数量小于马上创建线程运行这个任务如果正在运行的线程数量大于或等于将任务放入队列如果队列满了且正在运行的线程数量小于创建非核心线程立刻运行这个任务如果队列满了且正在运行的线程数量大于或等于线程池会拒绝这个任务调用来处理当一个线程完成任务时会从阻塞队列尝试获取下一个任务执行若未获取到则进入阻塞状态当一个线程超过没有获取到任务且当前运行的线程数大于这个线程会被停掉退出如何优雅地关闭线程池拒绝新任务执行完队列中已有任务后再关闭是优雅关闭的第一步阻塞当前线程等待线程池在指定时间内完成所有任务返回表示全部任务执行完返回表示超时如果等待超时还没结束则强制关闭同时发送中断信号给正在执行的任务返回未执行的任务列表捕获中断后要恢复中断状态防止异常吞掉中断标记线程的生命周期新建状态当线程对象对创建后即进入了新建状态如就绪状态当调用线程对象的方法线程即进入就绪状态处于就绪状态的线程只是说明此线程已经做好了准备随时等待调度执行并不是说执行了此线程立即就会执行运行状态当开始调度处于就绪状态的线程时此时线程才得以真正执行即进入到运行状态就绪状态是进入到运行状态的唯一入口也就是说线程要想进入运行状态执行首先必须处于就绪状态中阻塞状态处于运行状态中的线程由于某种原因暂时放弃对的使用权停止执行此时进入阻塞状态直到其进入到就绪状态才有机会再次被调用以进入到运行状态死亡状态线程执行完了或者因异常退出了方法该线程结束生命周期线程的常用方法启动线程使线程进入就绪状态等待调度线程的执行体包含线程要执行的任务代码让当前线程暂停执行指定时间毫秒进入状态等待当前线程执行完毕或等待指定时间后继续执行提示线程调度器当前线程愿意让出时间片进入状态和的区别和是类中用于线程调度的两个重要方法但它们的作用场景和底层逻辑有显著区别核心差异如下作用不同让当前线程主动让出资源从运行状态回到就绪状态给其他优先级相同或更高的线程提供执行机会这是一种建议性的操作可能忽略该请求当前线程仍可能继续执行让当前线程阻塞等待目标线程执行完毕后再继续执行例如主线程调用后会暂停执行直到线程执行结束主线程才恢复运行阻塞行为不同不会阻塞线程只是短暂放弃线程状态从运行转为就绪立即参与下一次调度竞争会阻塞当前线程调用的线程直到目标线程执行完毕或超时阻塞期间当前线程不参与调度对锁的影响不同不会释放当前线程持有的锁如锁只是让出执行权锁仍被当前线程持有底层通过实现会释放当前线程持有的锁如果有的话阻塞期间其他线程可以获取该锁使用场景不同适用于避免线程长时间独占的场景例如在循环中偶尔让出资源让其他线程有机会执行示例一个低优先级线程在执行非紧急任务时定期调用给高优先级线程机会适用于线程间协作需要等待其他线程完成后再执行的场景例如主线程等待所有子线程计算完毕后汇总结果和的区别和是中用于暂停线程执行的两个常用方法但它们的设计目的使用场景和底层机制有本质区别核心差异如下所属类不同属于类所有对象都有此方法是线程间协作的核心方法属于类是线程自身的休眠方法对锁的处理不同最核心区别会释放当前线程持有的对象锁调用时线程必须先持有该对象的锁在同步块方法中调用后会释放锁并进入该对象的等待队列其他线程可以获取该锁不会释放任何锁即使线程持有锁期间锁仍被当前线程持有其他线程无法获取该锁使用场景不同用于线程间协作等待某个条件满足如生产者消费者模型中消费者等待商品生产完成必须在同步块方法中调用否则会抛出用于让当前线程暂停执行一段固定时间如模拟网络延迟定时轮询与线程间协作无关无需在同步块中调用唤醒方式不同需通过其他线程调用同一个对象的或唤醒进入就绪状态重新竞争锁若调用超时后会自动唤醒时间到后自动唤醒进入就绪状态可被其他线程调用中断抛出线程锁在并发编程中锁是一种同步机制用于控制多个执行单元线程进程对共享资源的访问确保资源在同一时间只能被一个执行单元操作从而避免数据不一致冲突或错误如脏读丢失更新等问题锁的分类本质是为了适应不同的并发场景单进程内线程同步优先用线程锁跨进程同步用进程锁或分布式锁读多写少用共享锁乐观锁写操作频繁用排他锁悲观锁需公平性用公平锁追求性能用非公平锁锁的分类锁类型核心思想实现方式适用场景优点缺点悲观锁假设冲突一定会发生先加锁再操作关键字写操作频繁冲突概率高的场景数据安全性高避免并发冲突性能开销大可能导致线程阻塞乐观锁假设冲突很少发生更新时检查版本通过版本号或时间戳实现读操作频繁冲突概率低的场景无需加锁并发性能高可能需要重试不适合高冲突场景公平锁按请求顺序分配锁先到先得需要保证线程公平性避免饥饿的场景避免线程饥饿执行顺序可预测维护队列开销大上下文切换频繁非公平锁不按请求顺序分配锁当前线程优先默认追求高吞吐量允许线程饥饿的场景减少上下文切换性能更高可能导致部分线程长时间无法获取锁可重入锁允许同一线程多次获取同一把锁递归调用或嵌套锁的场景避免死锁简化代码逻辑需注意锁的释放顺序读写锁读锁共享写锁独占读多写少的场景提高读操作并发度写操作可能长时间等待自旋锁获取锁失败时循环等待而非阻塞通过锁持有时间短线程不希望被阻塞的场景减少线程上下文切换消耗资源不适用于长耗时操作你知道中有哪些锁吗关键字实现特性可重入自动释放非公平锁优势代码简洁低竞争时性能优异类包基于特性可重入手动释放中提供限时等待支持公平非公平锁优势高竞争场景非公平模式性能略优减少线程切换如特性读锁共享写锁互斥优势读操作并发高写操作互斥保持数据一致性优化读写锁特性支持乐观读无锁读取验证版本号冲突时降级为读锁三种模式读写乐观读优势乐观读的性能远远优于读写锁无锁竞争适合用于极低写频率场景如统计系统用过吗其原理是什么是中最基础也最常用的线程同步机制用于保证多线程环境下临界区代码的原子性可见性和有序性可作用于方法或代码块核心是通过锁对象实现线程互斥互斥性保证同一时刻只有一个线程可以获取锁并且只有该线程可以执行同步代码块中的代码可重入性同一个线程可以多次获取同步锁而不会被阻塞这样可以避免死锁的发生独占性如果一个线程获得了对象的锁则其他线程必须等待该线程释放锁之后才能获取锁核心原理的底层实现依赖的锁机制和对象头中的标记位其核心逻辑是通过锁对象控制线程对临界区的访问锁的载体对象头中每个对象都有一个对象头用于存储对象的元数据如哈希码年龄锁状态等的锁状态就记录在对象头的中位中占位占锁的升级从无锁到重量级锁为了减少锁的开销对进行了分层优化锁会根据竞争程度从低开销向高开销动态升级不可逆第一步无锁状态对象刚创建时存储哈希码等信息无锁竞争第二步偏向锁当只有一个线程多次获取锁时锁会偏向这个线程首次获取锁时通过操作将线程写入对象头的设置偏向锁标志为后续该线程再次进入同步块时无需竞争直接通过线程匹配确认持有锁几乎无开销触发升级当有其他线程尝试获取锁时偏向锁会膨胀为轻量级锁第三步轻量级锁当出现轻度锁竞争线程交替获取锁无长时间阻塞时线程获取锁时会在自己的栈帧中创建锁记录存储对象头中的拷贝通过操作将对象头的替换为指向栈中锁记录的指针表示持有轻量级锁若成功获取锁若失败说明有竞争线程会自旋循环重试几次仍失败则升级为重量级锁第四步重量级锁当竞争激烈自旋失败或线程阻塞时锁升级为重量级锁依赖操作系统的互斥量实现线程获取不到锁时会进入内核态阻塞放弃等待锁释放后被唤醒开销大涉及用户态与内核态切换但适合长时间持有锁或高竞争场景与的对比特性如锁获取释放显式调用需手动释放隐式自动获取释放可重入性支持支持公平性可选择公平非公平仅非公平中断响应支持不支持等待时无法被中断超时获取支持不支持条件变量支持多个精细控制仅一个等待队列性能高并发下性能更稳定低并发下优化好偏向锁轻量级锁的底层原理是基于实现的可重入独占锁它比更灵活更可控内部通过一个对象继承自来实现锁的获取与释放内部维护一个整数表示锁状态表示未加锁表示已加锁持有线程数也体现可重入性加锁流程尝试加锁当线程调用时若当前无锁通过将其改为若成功当前线程成为锁的持有者若失败锁被占用进入等待队列可重入性如果当前线程已经持有锁则允许再次进入入队与阻塞若其他线程也想获取锁失败后会调用会创建一个包含线程状态前后指针加入双向队列线程会被阻塞直到前驱节点释放锁公平锁与非公平锁非公平锁默认新线程插队尝试直接获取锁竞争激烈时性能高公平锁线程必须排队遵循先到先得通过判断是否排队解释一下关键字的作用和使用场景是中用于保证变量可见性和禁止指令重排序的关键字级关键字主要用于解决多线程环境下共享变量的同步问题但它不保证原子性一的核心作用保证可见性当一个变量被修饰时它会确保线程对该变量的修改会立即刷新到主内存而非仅停留在线程的工作内存其他线程读取该变量时会直接从主内存加载最新值而非使用工作内存中的缓存副本没有的问题多线程环境中线程会将共享变量从主内存加载到自己的工作内存缓存中操作若变量未被修饰一个线程的修改可能不会及时同步到主内存导致其他线程读取到旧值不可见禁止指令重排序编译器或为了优化性能可能会对没有数据依赖的指令进行重排序调整执行顺序会通过内存屏障禁止这种重排序保证指令执行顺序与代码逻辑一致没有的风险在初始化单例对象等场景中指令重排序可能导致其他线程获取到未完全初始化的对象的实现原理是什么底层实现靠的是在读写变量时插入内存屏障指令不同架构实现不同但通用原理一致写屏障强制将工作内存中变量刷新到主内存读屏障强制从主内存中重新读取最新值通过在读写操作前后插入内存屏障确保变量的可见性和有序性底层依赖的缓存一致性协议但它不保证复合操作的原子性因此只能用于状态标志或单次读写场景与的区别特性作用保证可见性禁止重排序保证原子性可见性有序性原子性不保证复合操作不安全保证临界区代码原子执行开销轻量无锁竞争可能较重锁升级机制优化适用场景状态标记简单变量读写复杂逻辑复合操作的底层原理是里用于实现线程同步的一个类它出自包提供了比关键字更丰富的锁操作其底层原理主要基于框架框架概述是一个用于构建锁和同步器的框架很多同步类的实现都依赖于它像等内部维护了一个变量用于表示同步状态还维护了一个先进先出的线程等待队列的结构内部有一个静态抽象类它继承自并且有两个具体的实现类非公平锁和公平锁非公平锁的加锁原理尝试直接获取锁当线程调用方法时会先尝试直接将状态从变为如果成功就表示获取到了锁当前线程成为锁的持有者进入队列若尝试失败线程会进入的等待队列重入情况如果当前线程已经是锁的持有者再次获取锁时的值会加这体现了锁的可重入性公平锁的加锁原理检查队列公平锁在获取锁时会先检查队列中是否有其他线程在等待如果有当前线程会进入队列尾部等待尝试获取锁若队列中没有其他线程等待才会尝试将状态从变为解锁原理释放锁当线程调用方法时会将的值减完全释放若的值减为就表示锁被完全释放此时会唤醒队列中等待的线程多线程如何获取异步执行结果最常用是带返回值的线程任务接口与不同它的方法可以返回结果是一个未来结果的容器用于存储的执行结果支持阻塞等待结果超时等待等非阻塞式支持异步回调无需主动阻塞等待更适合复杂的异步流程如链式调用多任务组合什么是线程死锁死锁如何产生例如假设线程持有资源并等待资源而线程持有资源并等待资源这时候就会出现死锁死锁线程死锁是指由于两个或者多个线程互相持有对方所需要的资源导致这些线程处于等待状态无法前往执行当线程进入对象的代码块时便占有了资源直到它退出该代码块或者调用方法才释放资源在此期间其他线程将不能进入该代码块当线程互相持有对方所需要的资源时会互相等待对方释放资源如果线程都不主动释放所占有的资源将产生死锁死锁的产生的一些特定条件中死锁产生的一些特定条件通常包括以下四个方面互斥条件一个资源一次只能被一个线程持有如果其他线程想要获取该资源就必须等待该线程释放该资源请求保持一个线程请求资源时如果已经持有了其他资源就可以保持对这些资源的控制直到满足所有资源的要求才释放不剥夺条件已经分配的资源不能被其他线程剥夺只能由持有资源的线程释放循环等待条件多个线程形成一种循环等待的关系每个线程都在等待其他线程所持有的资源从而导致死锁的产生当以上条件同时满足时就可能会出现死锁的情况为了避免死锁需要在设计时遵循一定的规范和原则例如尽量避免嵌套锁确保同步代码块执行时间尽可能短等同时也可以使用专门的工具进行死锁检测和分析帮助我们找到死锁的根本原因并进行相应的优化和调整如何避免死锁要避免线程死锁可以采取以下几种方法尽量避免使用多个锁尽量使用一个锁或者使用更加高级的锁例如读写锁或者确保同步代码块的执行时间尽可能短这样可以减少线程等待时间从而避免死锁的产生使用更高级的锁通过方法可以尝试获取锁如果在规定时间内获取不到锁则放弃锁避免嵌套锁如果需要使用多个锁请确保它们的获取顺序是一致的这样可以避免死锁原理底层如何防止内存泄漏为每个线程维护一个独立的变量副本底层通过持有的存储其中是对的弱引用防止对象无法回收是强引用为避免被回收后残留导致内存泄漏在时会清理的条目但开发者仍应在使用后手动调用释放资源为每个线程提供一个独立的变量副本让变量在多线程间互不干扰每个线程都持有自己独立的弱引用实际存放的对象强引用的是弱引用是强引用当外部没有引用对象时会被回收但还强引用着对象如果当前线程是线程池中的线程不会销毁这些就会永远被挂在里导致内存泄漏什么是线程安全怎么保证线程安全当多个线程同时访问同一份共享数据时无论执行时序如何交替程序的执行结果都是一致且符合预期的那么我们说这个代码是线程安全的线程不安全的根源三大问题原子性缺失操作不是一个不可分割的整体比如实际是三步读加写可见性问题线程对变量的修改其他线程看不到因为缓存工作内存有序性问题指令重排让程序执行顺序与预期不一致如何保证线程安全从思想到实现不共享线程封闭最简单的线程安全不让数据共享局部变量每个线程栈独有线程隔离不可变对象如果对象不可变线程之间共享也没问题典型例子因为不可变对象状态不会改变所以天然线程安全互斥锁让多个线程排队访问共享资源这类机制确保同一时刻只有一个线程执行临界区写操作对其他线程可见保证原子性和有序性原子类实现无锁并发使用实现原子更新不用加锁底层依赖指令如的保证操作不可中断线程安全是指多个线程同时访问共享变量时能保证数据一致性和程序的预期行为它主要涉及原子性可见性有序性三大问题保障方式有多种通过线程封闭或不可变对象避免共享通过实现互斥访问通过实现无锁原子操作通过并发容器封装线程安全逻辑实际项目中会根据场景权衡性能与安全什么是可见性原子性有序性可见性定义当一个线程修改了共享变量的值其他线程能够立即看到这个修改问题来源中每个线程都有一个工作内存线程本地缓存它会从主内存中拷贝变量的值到本地进行计算修改后不一定马上写回主内存所以另一个线程可能还在读旧值解决使用保证可见性使用它们隐含内存屏障使用构造完成后值不会再变原子性定义一个操作或一组操作要么全部执行完毕要么全部不执行不会出现中间状态问题来源很多看似简单的操作其实不是原子的解决使用或让操作互斥使用原子类底层用实现使用不可变对象有序性定义程序的执行顺序与代码顺序一致问题来源编译器和会对指令进行重排序以提高性能重排序对单线程无影响但多线程下可能出事解决使用禁止重排序使用或使用原则保证执行顺序全称是抽象队列同步器是并发包的核心基础类几乎所有常用的并发同步工具类如的底层实现都依赖于它通过一个状态值双向队列来管理线程的竞争与阻塞简单来说表示资源状态比如锁是否被占用剩余许可数等用来原子修改队列维护等待的线程队列把同步器的共性抽象出来让开发者只需要实现它的几个钩子方法就能轻松构建各种并发控制器的两种模式支持两种同步模式独占模式同一时间只有一个线程能持有资源典型代表共享模式允许多个线程同时获取资源典型代表是一种无锁并发原语用于在多线程环境下实现原子操作当且仅当内存中的值等于预期值时才把它更新为新值否则不做任何修改的优点无锁高性能不阻塞线程适合高并发下的原子更新避免上下文切换开销不像那样需要内核态的锁管理原子性由硬件保证无需锁机制就能确保线程安全的问题面试高频问题举个例子线程读取值线程把改成又改回再比较时发现值还是于是以为没人改过但实际上它被改过解决方案使用版本号机制比如记录值的版本每次修改不仅改值还更新版本号自旋开销大当竞争激烈时线程会一直自旋重试导致占用高优化内部有自适应自旋锁如果线程竞争不频繁则短暂自旋否则直接挂起线程避免浪费只能保证单个变量的原子性只能保证一个内存地址的更新是原子的如果要同时修改多个变量就得用更高层的机制比如封装对象或使用锁',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2025-10-27 11:55:14',
  postMainColor: '',
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#18171d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#f7f9fe')
        }
      }
      const t = saveToLocal.get('theme')
    
          const isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
          const isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
          const isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
          const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

          if (t === undefined) {
            if (isLightMode) activateLightMode()
            else if (isDarkMode) activateDarkMode()
            else if (isNotSpecified || hasNoSupport) {
              const now = new Date()
              const hour = now.getHours()
              const isNight = hour <= 6 || hour >= 18
              isNight ? activateDarkMode() : activateLightMode()
            }
            window.matchMedia('(prefers-color-scheme: dark)').addListener(e => {
              if (saveToLocal.get('theme') === undefined) {
                e.matches ? activateDarkMode() : activateLightMode()
              }
            })
          } else if (t === 'light') activateLightMode()
          else activateDarkMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.3.0"></head><body data-type="anzhiyu"><div id="web_bg"></div><div id="an_music_bg"></div><div id="loading-box" onclick="document.getElementById(&quot;loading-box&quot;).classList.add(&quot;loaded&quot;)"><div class="loading-bg"><img class="loading-img nolazyload" alt="加载头像" src="https://s2.loli.net/2022/11/07/QVWvrnAsuGxelbS.jpg"/><div class="loading-image-dot"></div></div></div><script>const preloader = {
  endLoading: () => {
    document.getElementById('loading-box').classList.add("loaded");
  },
  initLoading: () => {
    document.getElementById('loading-box').classList.remove("loaded")
  }
}
window.addEventListener('load',()=> { preloader.endLoading() })
setTimeout(function(){preloader.endLoading();},10000)

if (true) {
  document.addEventListener('pjax:send', () => { preloader.initLoading() })
  document.addEventListener('pjax:complete', () => { preloader.endLoading() })
}</script><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.1.10/progress_bar/progress_bar.css"/><script async="async" src="https://cdn.cbd.int/pace-js@1.2.4/pace.min.js" data-pace-options="{ &quot;restartOnRequestAfter&quot;:false,&quot;eventLag&quot;:false}"></script><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><div id="nav-group"><span id="blog_name"><a id="site-name" href="/" accesskey="h"><div class="title">Wsk Blog</div><i class="anzhiyufont anzhiyu-icon-house-chimney"></i></a></span><div class="mask-name-container"><div id="name-container"><a id="page-name" href="javascript:anzhiyu.scrollToDest(0, 500)">PAGE_NAME</a></div></div><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 文章</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/archives/"><i class="anzhiyufont anzhiyu-icon-box-archive faa-tada" style="font-size: 0.9em;"></i><span> 隧道</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/categories/"><i class="anzhiyufont anzhiyu-icon-shapes faa-tada" style="font-size: 0.9em;"></i><span> 分类</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/tags/"><i class="anzhiyufont anzhiyu-icon-tags faa-tada" style="font-size: 0.9em;"></i><span> 标签</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 友链</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/link/"><i class="anzhiyufont anzhiyu-icon-link faa-tada" style="font-size: 0.9em;"></i><span> 友人帐</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/fcircle/"><i class="anzhiyufont anzhiyu-icon-artstation faa-tada" style="font-size: 0.9em;"></i><span> 朋友圈</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/comments/"><i class="anzhiyufont anzhiyu-icon-envelope faa-tada" style="font-size: 0.9em;"></i><span> 留言板</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 我的</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/music/?id=2898229193&amp;server=netease"><i class="anzhiyufont anzhiyu-icon-music faa-tada" style="font-size: 0.9em;"></i><span> 音乐馆</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/album/"><i class="anzhiyufont anzhiyu-icon-images faa-tada" style="font-size: 0.9em;"></i><span> 相册集</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/air-conditioner/"><i class="anzhiyufont anzhiyu-icon-fan faa-tada" style="font-size: 0.9em;"></i><span> 小空调</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 关于</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/about/"><i class="anzhiyufont anzhiyu-icon-paper-plane faa-tada" style="font-size: 0.9em;"></i><span> 关于本人</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/essay/"><i class="anzhiyufont anzhiyu-icon-lightbulb faa-tada" style="font-size: 0.9em;"></i><span> 闲言碎语</span></a></li></ul></div></div></div><div id="nav-right"><div class="nav-button" id="randomPost_button"><a class="site-page" onclick="toRandomPost()" title="随机前往一个文章" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-dice"></i></a></div><input id="center-console" type="checkbox"/><label class="widget" for="center-console" title="中控台" onclick="anzhiyu.switchConsole();"><i class="left"></i><i class="widget center"></i><i class="widget right"></i></label><div id="console"><div class="console-card-group-reward"><ul class="reward-all console-card"><li class="reward-item"><a href="/./img/wechat.jpg" target="_blank"><img class="post-qr-code-img" alt="微信" src="/./img/wechat.jpg"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="/./img/alipay.jpg" target="_blank"><img class="post-qr-code-img" alt="支付宝" src="/./img/alipay.jpg"/></a><div class="post-qr-code-desc">支付宝</div></li></ul></div><div class="console-card-group"><div class="console-card-group-left"><div class="console-card" id="card-newest-comments"><div class="card-content"><div class="author-content-item-tips">互动</div><span class="author-content-item-title"> 最新评论</span></div><div class="aside-list"><span>正在加载中...</span></div></div></div><div class="console-card-group-right"><div class="console-card tags"><div class="card-content"><div class="author-content-item-tips">兴趣点</div><span class="author-content-item-title">寻找你感兴趣的领域</span><div class="card-tags"><div class="item-headline"></div><div class="card-tag-cloud"><a href="/tags/JVM%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/" style="font-size: 1.05rem;">JVM内存模型<sup>1</sup></a><a href="/tags/JVM%E8%B0%83%E4%BC%98/" style="font-size: 1.05rem;">JVM调优<sup>1</sup></a><a href="/tags/java%E6%95%99%E7%A8%8B/" style="font-size: 1.05rem;">java教程<sup>1</sup></a><a href="/tags/mysql/" style="font-size: 1.05rem;">mysql<sup>1</sup></a><a href="/tags/%E5%87%BD%E6%95%B0/" style="font-size: 1.05rem;">函数<sup>1</sup></a><a href="/tags/%E5%8F%8D%E5%B0%84/" style="font-size: 1.05rem;">反射<sup>1</sup></a><a href="/tags/%E5%A4%8D%E4%B9%A0/" style="font-size: 1.05rem;">复习<sup>1</sup></a><a href="/tags/%E5%A4%8D%E4%B9%A0-%E5%8F%98%E9%87%8F/" style="font-size: 1.05rem;">复习 变量<sup>1</sup></a><a href="/tags/%E5%B7%A5%E5%85%B7/" style="font-size: 1.05rem;">工具<sup>1</sup></a><a href="/tags/%E5%B9%B6%E5%8F%91/" style="font-size: 1.05rem;">并发<sup>1</sup></a><a href="/tags/%E6%83%85%E6%84%9F/" style="font-size: 1.05rem;">情感<sup>1</sup></a><a href="/tags/%E6%8A%BD%E8%B1%A1%E7%B1%BB-%E6%8E%A5%E5%8F%A3/" style="font-size: 1.05rem;">抽象类 接口<sup>1</sup></a><a href="/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/" style="font-size: 1.05rem;">数据库<sup>1</sup></a><a href="/tags/%E6%AF%8F%E6%97%A5%E9%9D%A2%E8%AF%95/" style="font-size: 1.05rem;">每日面试<sup>2</sup></a><a href="/tags/%E7%94%B5%E5%95%86-%E8%AE%A2%E5%8D%95/" style="font-size: 1.05rem;">电商,订单<sup>1</sup></a><a href="/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" style="font-size: 1.05rem;">设计模式<sup>1</sup></a><a href="/tags/%E8%B6%85%E5%8D%96-%E5%BA%93%E5%AD%98/" style="font-size: 1.05rem;">超卖 , 库存<sup>1</sup></a><a href="/tags/%E9%9B%86%E5%90%88/" style="font-size: 1.05rem;">集合<sup>1</sup></a></div></div><hr/></div></div><div class="console-card history"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-box-archiv"></i><span>文章</span></div><div class="card-archives"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-archive"></i><span>归档</span></div><ul class="card-archive-list"><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2025/10/"><span class="card-archive-list-date">十月 2025</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">9</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2025/04/"><span class="card-archive-list-date">四月 2025</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">4</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2023/10/"><span class="card-archive-list-date">十月 2023</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">3</span><span>篇</span></div></a></li></ul></div><hr/></div></div></div><div class="button-group"><div class="console-btn-item"><a class="darkmode_switchbutton" title="显示模式切换" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-moon"></i></a></div><div class="console-btn-item" id="consoleHideAside" onclick="anzhiyu.hideAsideBtn()" title="边栏显示控制"><a class="asideSwitch"><i class="anzhiyufont anzhiyu-icon-arrows-left-right"></i></a></div><div class="console-btn-item on" id="consoleCommentBarrage" onclick="anzhiyu.switchCommentBarrage()" title="热评开关"><a class="commentBarrage"><i class="anzhiyufont anzhiyu-icon-message"></i></a></div><div class="console-btn-item" id="consoleMusic" onclick="anzhiyu.musicToggle()" title="音乐开关"><a class="music-switch"><i class="anzhiyufont anzhiyu-icon-music"></i></a></div></div><div class="console-mask" onclick="anzhiyu.hideConsole()" href="javascript:void(0);"></div></div><div class="nav-button" id="nav-totop"><a class="totopbtn" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i><span id="percent" onclick="anzhiyu.scrollToDest(0,500)">0</span></a></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);" title="切换"><i class="anzhiyufont anzhiyu-icon-bars"></i></a></div></div></div></nav><div id="post-info"><div id="post-firstinfo"><div class="meta-firstline"><a class="post-meta-original">原创</a><span class="post-meta-categories"><span class="post-meta-separator"></span><i class="anzhiyufont anzhiyu-icon-inbox post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E9%9D%A2%E8%AF%95%E9%A2%98/" itemprop="url">面试题</a></span><span class="article-meta tags"><a class="article-meta__tags" href="/tags/%E5%B9%B6%E5%8F%91/" tabindex="-1" itemprop="url"> <span> <i class="anzhiyufont anzhiyu-icon-hashtag"></i>并发</span></a></span></div></div><h1 class="post-title" itemprop="name headline">并发编程</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="anzhiyufont anzhiyu-icon-calendar-days post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" itemprop="dateCreated datePublished" datetime="2025-10-23T15:51:36.000Z" title="发表于 2025-10-23 23:51:36">2025-10-23</time><span class="post-meta-separator"></span><i class="anzhiyufont anzhiyu-icon-history post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" itemprop="dateCreated datePublished" datetime="2025-10-27T03:55:14.510Z" title="更新于 2025-10-27 11:55:14">2025-10-27</time></span></div><div class="meta-secondline"><span class="post-meta-separator"></span><span class="post-meta-pv-cv" id="" data-flag-title="并发编程"><i class="anzhiyufont anzhiyu-icon-fw-eye post-meta-icon"></i><span class="post-meta-label" title="阅读量">阅读量:</span><span id="busuanzi_value_page_pv"><i class="anzhiyufont anzhiyu-icon-spinner anzhiyu-spin"></i></span></span><span class="post-meta-separator">       </span><span class="post-meta-position" title="作者IP属地为新乡"><i class="anzhiyufont anzhiyu-icon-location-dot"></i>新乡</span><span class="post-meta-separator"></span><span class="post-meta-commentcount"><i class="anzhiyufont anzhiyu-icon-comments post-meta-icon"></i><span class="post-meta-label">评论数:</span><a href="/posts/498cfd8e.html#post-comment" itemprop="discussionUrl"><span class="valine-comment-count" data-xid="/posts/498cfd8e.html" itemprop="commentCount"><i class="anzhiyufont anzhiyu-icon-spinner anzhiyu-spin"></i></span></a></span></div></div></div><section class="main-hero-waves-area waves-area"><svg class="waves-svg" xmlns="http://www.w3.org/2000/svg" xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M -160 44 c 30 0 58 -18 88 -18 s 58 18 88 18 s 58 -18 88 -18 s 58 18 88 18 v 44 h -352 Z"></path></defs><g class="parallax"><use href="#gentle-wave" x="48" y="0"></use><use href="#gentle-wave" x="48" y="3"></use><use href="#gentle-wave" x="48" y="5"></use><use href="#gentle-wave" x="48" y="7"></use></g></svg></section><div id="post-top-cover"><img class="nolazyload" id="post-top-bg" src="https://s2.loli.net/2025/10/23/w3ErpsQhncfDed2.jpg?_r_=e93610d2-afe5-62c9-ffac-34bc6ede57ce"></div></header><main id="blog-container"><div class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container" itemscope itemtype="https://wsk0404.github.io/posts/498cfd8e.html"><header><a class="post-meta-categories" href="/categories/%E9%9D%A2%E8%AF%95%E9%A2%98/" itemprop="url">面试题</a><a href="/tags/%E5%B9%B6%E5%8F%91/" tabindex="-1" itemprop="url">并发</a><h1 id="CrawlerTitle" itemprop="name headline">并发编程</h1><span itemprop="author" itemscope itemtype="http://schema.org/Person">Wsk</span><time itemprop="dateCreated datePublished" datetime="2025-10-23T15:51:36.000Z" title="发表于 2025-10-23 23:51:36">2025-10-23</time><time itemprop="dateCreated datePublished" datetime="2025-10-27T03:55:14.510Z" title="更新于 2025-10-27 11:55:14">2025-10-27</time></header><h2 id="什么是线程？什么是进程？"><a href="#什么是线程？什么是进程？" class="headerlink" title="什么是线程？什么是进程？"></a>什么是线程？什么是进程？</h2><p><strong>进程</strong>是系统资源分配的基本单位，拥有独立的内存空间，不同进程之间可以并发执行，创建新进程需要分类独立的内存空间和系统资源，成本高。一个进程的崩溃不会影响其他进程</p>
<p><strong>线程</strong>是进程中的一个执行单元，是cpu调度的基本单位，共享所属进程的资源，只拥有自己的栈和寄存器；同一个进程内可以有多个线程并发执行，创建新线程成本低。一个线程崩溃可能导致整个进程崩溃。</p>
<h2 id="Java创建线程有哪几种方式"><a href="#Java创建线程有哪几种方式" class="headerlink" title="Java创建线程有哪几种方式"></a>Java创建线程有哪几种方式</h2><h3 id="继承自Thread类"><a href="#继承自Thread类" class="headerlink" title="继承自Thread类"></a>继承自<code>Thread</code>类</h3><ol>
<li>定义类继承Thread类。</li>
<li>重写run()方法，定义线程执行体。</li>
<li>创建子类对象并调用start()方法启动线程。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 线程执行的逻辑</span></span><br><span class="line">        System.out.println(<span class="string">&quot;MyThread is running...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建并启动线程</span></span><br><span class="line"><span class="type">MyThread</span> <span class="variable">myThread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread</span>();</span><br><span class="line">myThread.start();</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="实现Runnable接口"><a href="#实现Runnable接口" class="headerlink" title="实现Runnable接口"></a>实现<code>Runnable</code>接口</h3><ol>
<li>定义类实现Runnable接口。</li>
<li>实现run()方法。</li>
<li>创建实现类对象，将其作为参数传递给Thread构造器，再调用start()方法。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyRunnable</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 线程执行的逻辑</span></span><br><span class="line">        System.out.println(<span class="string">&quot;MyRunnable is running...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建并启动线程</span></span><br><span class="line"><span class="type">Thread</span> <span class="variable">myThread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">MyRunnable</span>());</span><br><span class="line">myThread.start();</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="实现-Callable-接口（带返回值）"><a href="#实现-Callable-接口（带返回值）" class="headerlink" title="实现 Callable 接口（带返回值）"></a><strong>实现 Callable 接口（带返回值）</strong></h3><ol>
<li>定义类实现Callable接口，指定返回值类型。</li>
<li>实现call()方法，定义线程执行体并返回结果。</li>
<li>通过FutureTask包装Callable实例，再将FutureTask传递给Thread。</li>
<li>调用start()启动线程，通过FutureTask.get()获取返回值。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.Callable;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutionException;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.FutureTask;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1. 实现 Callable 接口，指定返回值类型为 Integer</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyCallable</span> <span class="keyword">implements</span> <span class="title class_">Callable</span>&lt;Integer&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> taskNum;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyCallable</span><span class="params">(<span class="type">int</span> num)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.taskNum = num;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 重写 call() 方法，定义任务逻辑并返回结果</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Integer <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;任务 &quot;</span> + taskNum + <span class="string">&quot; 开始执行&quot;</span>);</span><br><span class="line">        <span class="comment">// 模拟任务执行（如计算）</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;= taskNum; i++) &#123;</span><br><span class="line">            result += i;</span><br><span class="line">        &#125;</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>); <span class="comment">// 模拟耗时操作</span></span><br><span class="line">        System.out.println(<span class="string">&quot;任务 &quot;</span> + taskNum + <span class="string">&quot; 执行完毕，结果为：&quot;</span> + result);</span><br><span class="line">        <span class="keyword">return</span> result; <span class="comment">// 返回计算结果</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CallableDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 3. 创建 Callable 实例</span></span><br><span class="line">        <span class="type">MyCallable</span> <span class="variable">callable1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyCallable</span>(<span class="number">100</span>);</span><br><span class="line">        <span class="type">MyCallable</span> <span class="variable">callable2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyCallable</span>(<span class="number">200</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4. 用 FutureTask 包装 Callable（FutureTask 用于接收结果）</span></span><br><span class="line">        FutureTask&lt;Integer&gt; futureTask1 = <span class="keyword">new</span> <span class="title class_">FutureTask</span>&lt;&gt;(callable1);</span><br><span class="line">        FutureTask&lt;Integer&gt; futureTask2 = <span class="keyword">new</span> <span class="title class_">FutureTask</span>&lt;&gt;(callable2);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 5. 启动线程（FutureTask 实现了 Runnable，可作为 Thread 的参数）</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(futureTask1).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(futureTask2).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 6. 获取结果（get() 方法会阻塞，直到任务完成）</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">result1</span> <span class="operator">=</span> futureTask1.get();</span><br><span class="line">            <span class="type">int</span> <span class="variable">result2</span> <span class="operator">=</span> futureTask2.get();</span><br><span class="line">            System.out.println(<span class="string">&quot;总结果：&quot;</span> + (result1 + result2));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="通过线程池进行创建"><a href="#通过线程池进行创建" class="headerlink" title="** 通过线程池进行创建**"></a>** 通过线程池进行创建**</h3><p>使用 Executors 工厂类创建线程池（简单快捷）</p>
<p>​	<code>newFixedThreadPool(n)</code>：固定大小线程池</p>
<p>​	<code>newCachedThreadPool()</code>：可缓存线程池</p>
<p>​    <code>newSingleThreadExecutor()</code>：单线程化线程池</p>
<p>使用 ThreadPoolExecutor 自定义线程池（推荐方式）</p>
<p>使用 ScheduledThreadPoolExecutor 创建定时任务线程池</p>
<h2 id="什么是线程池？为什么要使用线程池？"><a href="#什么是线程池？为什么要使用线程池？" class="headerlink" title="什么是线程池？为什么要使用线程池？"></a><strong>什么是线程池？为什么要使用线程池？</strong></h2><p>线程池是采用池化思想管理线程的工具，就像一个容器，里面存放着一定数量的线程。它基于 JUC 包中的 ThreadPoolExecutor 类及其体系实现。使用线程池有诸多好处，比如降低资源消耗，通过重用已存在的线程，减少线程创建和销毁的开销</p>
<h2 id="ThreadPoolExecutor-都有哪些核心参数？"><a href="#ThreadPoolExecutor-都有哪些核心参数？" class="headerlink" title="ThreadPoolExecutor 都有哪些核心参数？"></a><strong>ThreadPoolExecutor 都有哪些核心参数？</strong></h2><p>ThreadPoolExecutor 有 7 个核心参数，分别是核心线程数（corePoolSize）、最大线程数（maximumPoolSize）、空闲线程超时时间	（keepAliveTime）、时间单位（unit）、阻塞队列（workQueue）、拒绝策略（handler）、线程工厂（ThreadFactory）。</p>
<ul>
<li><p>常见队列类型：</p>
<ul>
<li><code>ArrayBlockingQueue</code>：有界数组队列（需指定容量，如 <code>new ArrayBlockingQueue&lt;&gt;(100)</code>），防止内存溢出（推荐）。</li>
</ul>
<p>适用于需要严格控制任务数量，防止资源过度消耗的场景</p>
<ul>
<li><code>LinkedBlockingQueue</code>：无界链表队列（默认容量 <code>Integer.MAX_VALUE</code>，可能因任务过多导致 OOM，谨慎使用）。</li>
</ul>
<p>当任务产生的速度相对较慢，或者系统资源足够充足，能够处理大量任务时，可以使用无界队列。它可以保证任务不会因为队列满而被拒绝，但需要注意可能会导致内存占用过高的问题</p>
<ul>
<li><code>SynchronousQueue</code>：同步队列（不存储任务，直接传递给线程，适合 <code>newCachedThreadPool</code> 场景）。</li>
<li><code>PriorityBlockingQueue</code>：优先级队列（按任务优先级排序执行）。</li>
</ul>
</li>
<li><p>JDK 内置 4 种拒绝策略：</p>
<ul>
<li><code>AbortPolicy</code>（默认）：直接抛出 <code>RejectedExecutionException</code>，中断任务提交。</li>
<li><code>CallerRunsPolicy</code>：让提交任务的线程自己执行该任务（减缓提交速度，适用于并发不高的场景）。</li>
<li><code>DiscardPolicy</code>：默默丢弃新任务，不抛出异常（可能丢失任务，需谨慎）。</li>
<li><code>DiscardOldestPolicy</code>：丢弃队列中最旧的任务，然后尝试提交新任务（可能丢失旧任务）。</li>
</ul>
</li>
<li><p><strong>自定义策略</strong>：实现 <code>RejectedExecutionHandler</code> 接口，如记录日志、持久化任务到数据库后续重试</p>
</li>
</ul>
<h2 id="线程池的运行原理是什么？"><a href="#线程池的运行原理是什么？" class="headerlink" title="线程池的运行原理是什么？"></a><strong>线程池的运行原理是什么？</strong></h2><p>线程池刚创建时没有线程。当调用 execute () 方法添加任务时，会进行如下判断：</p>
<p>如果正在运行的线程数量小于 corePoolSize，马上创建线程运行这个任务；如果正在运行的线程数量大于或等于 corePoolSize，将任务放入队列；</p>
<p>如果队列满了，且正在运行的线程数量小于 maximumPoolSize，创建非核心线程立刻运行这个任务；</p>
<p>如果队列满了，且正在运行的线程数量大于或等于 maximumPoolSize，线程池会拒绝这个任务，调用 RejectedExecutionHandler 来处理。</p>
<p>当一个线程完成任务时，会从阻塞队列尝试获取下一个任务执行，若未获取到则进入阻塞状态。当一个线程超过 keepAliveTime 没有获取到任务，且当前运行的线程数大于 corePoolSize，这个线程会被停掉退出。</p>
<h2 id="如何优雅地关闭线程池？"><a href="#如何优雅地关闭线程池？" class="headerlink" title="如何优雅地关闭线程池？"></a>如何优雅地关闭线程池？</h2><p><strong>shutdown()</strong></p>
<ul>
<li>拒绝新任务。</li>
<li>执行完队列中已有任务后再关闭。</li>
<li>是优雅关闭的第一步。</li>
</ul>
<p><strong>awaitTermination(timeout)</strong></p>
<ul>
<li>阻塞当前线程，等待线程池在指定时间内完成所有任务。</li>
<li>返回 <code>true</code> 表示全部任务执行完。</li>
<li>返回 <code>false</code> 表示超时。</li>
</ul>
<p><strong>shutdownNow()</strong></p>
<ul>
<li>如果等待超时，还没结束，则强制关闭。</li>
<li>同时发送中断信号给正在执行的任务。</li>
<li>返回未执行的任务列表。</li>
</ul>
<p><strong>Thread.interrupt()</strong></p>
<ul>
<li>捕获中断后要恢复中断状态（<code>Thread.currentThread().interrupt()</code>），防止异常吞掉中断标记。</li>
</ul>
<h2 id="线程的生命周期？"><a href="#线程的生命周期？" class="headerlink" title="线程的生命周期？"></a>线程的生命周期？</h2><ul>
<li><p>新建状态（New）：当线程对象对创建后，即进入了新建状态，如：Thread t &#x3D; new MyThread()；</p>
</li>
<li><p>就绪状态（Runnable）：当调用线程对象的start()方法（t.start();），线程即进入就绪状态。处于就绪状态的线程，只是说明此线程已经做好了准备，随时等待CPU调度执行，并不是说执行了t.start()此线程立即就会执行；</p>
</li>
<li><p>运行状态（Running）：当CPU开始调度处于就绪状态的线程时，此时线程才得以真正执行，即进入到运行状态。就绪状态是进入到运行状态的唯一入口，也就是说，线程要想进入运行状态执行，首先必须处于就绪状态中；</p>
</li>
<li><p>阻塞状态（Blocked）：处于运行状态中的线程由于某种原因，暂时放弃对CPU的使用权，停止执行，此时进入阻塞状态，直到其进入到就绪状态，才 有机会再次被CPU调用以进入到运行状态。</p>
</li>
<li><p>死亡状态（Dead）：线程执行完了或者因异常退出了run()方法，该线程结束生命周期</p>
</li>
</ul>
<h2 id="线程的常用方法"><a href="#线程的常用方法" class="headerlink" title="线程的常用方法"></a><strong>线程的常用方法</strong></h2><p>**start()**启动线程，使线程进入就绪状态（等待 CPU 调度）。</p>
<p>**run()**线程的执行体，包含线程要执行的任务代码。</p>
<p><strong>sleep(long millis)<strong>让当前线程暂停执行指定时间（毫秒），进入</strong>TIMED_WAITING</strong>状态。</p>
<p><strong>join()</strong> <strong>&#x2F;</strong> **join(long millis)**等待当前线程执行完毕，或等待指定时间后继续执行。</p>
<p><strong>yield()<strong>提示线程调度器当前线程愿意让出 CPU 时间片，进入</strong>RUNNABLE</strong>状态。</p>
<h2 id="yield和join的区别"><a href="#yield和join的区别" class="headerlink" title="yield和join的区别"></a>yield和join的区别</h2><p><code>yield()</code> 和 <code>join()</code> 是 Thread 类中用于线程调度的两个重要方法，但它们的作用、场景和底层逻辑有显著区别，核心差异如下：</p>
<h3 id="1-作用不同"><a href="#1-作用不同" class="headerlink" title="1. 作用不同"></a><strong>1. 作用不同</strong></h3><ul>
<li><strong><code>yield()</code><strong>：让当前线程</strong>主动让出 CPU 资源</strong>，从 “运行状态” 回到 “就绪状态”，给其他<strong>优先级相同或更高</strong>的线程提供执行机会。这是一种 “建议性” 的操作，CPU 可能忽略该请求（当前线程仍可能继续执行）。</li>
<li><strong><code>join()</code><strong>：让</strong>当前线程阻塞等待</strong>目标线程执行完毕后，再继续执行。例如：主线程调用 <code>t.join()</code> 后，会暂停执行，直到线程 <code>t</code> 执行结束，主线程才恢复运行。</li>
</ul>
<h3 id="2-阻塞行为不同"><a href="#2-阻塞行为不同" class="headerlink" title="2. 阻塞行为不同"></a><strong>2. 阻塞行为不同</strong></h3><ul>
<li>**<code>yield()</code>**：不会阻塞线程，只是短暂放弃 CPU，线程状态从 “运行” 转为 “就绪”，立即参与下一次 CPU 调度竞争。</li>
<li><strong><code>join()</code><strong>：会阻塞</strong>当前线程</strong>（调用 <code>join()</code> 的线程），直到目标线程执行完毕或超时。阻塞期间，当前线程不参与 CPU 调度。</li>
</ul>
<h3 id="3-对锁的影响不同"><a href="#3-对锁的影响不同" class="headerlink" title="3. 对锁的影响不同"></a><strong>3. 对锁的影响不同</strong></h3><ul>
<li>**<code>yield()</code>**：不会释放当前线程持有的锁（如 <code>synchronized</code> 锁），只是让出 CPU 执行权，锁仍被当前线程持有。</li>
<li>**<code>join()</code>**：底层通过 <code>wait()</code> 实现，会释放当前线程持有的锁（如果有的话）。阻塞期间，其他线程可以获取该锁。</li>
</ul>
<h3 id="4-使用场景不同"><a href="#4-使用场景不同" class="headerlink" title="4. 使用场景不同"></a><strong>4. 使用场景不同</strong></h3><ul>
<li><strong><code>yield()</code><strong>：适用于</strong>避免线程长时间独占 CPU</strong>的场景，例如在循环中偶尔让出资源，让其他线程有机会执行。示例：一个低优先级线程在执行非紧急任务时，定期调用 <code>yield()</code> 给高优先级线程机会。</li>
<li><strong><code>join()</code><strong>：适用于</strong>线程间协作，需要等待其他线程完成后再执行</strong>的场景，例如主线程等待所有子线程计算完毕后汇总结果。</li>
</ul>
<h2 id="wait和sleep的区别"><a href="#wait和sleep的区别" class="headerlink" title="wait和sleep的区别"></a>wait和sleep的区别</h2><p><code>wait()</code> 和 <code>sleep()</code> 是 Java 中用于暂停线程执行的两个常用方法，但它们的设计目的、使用场景和底层机制有本质区别，核心差异如下：</p>
<h3 id="1-所属类不同"><a href="#1-所属类不同" class="headerlink" title="1. 所属类不同"></a><strong>1. 所属类不同</strong></h3><ul>
<li>**<code>wait()</code>**：属于 <code>Object</code> 类（所有对象都有此方法），是线程间协作的核心方法。</li>
<li>**<code>sleep(long millis)</code>**：属于 <code>Thread</code> 类，是线程自身的休眠方法。</li>
</ul>
<h3 id="2-对锁的处理不同（最核心区别）"><a href="#2-对锁的处理不同（最核心区别）" class="headerlink" title="2. 对锁的处理不同（最核心区别）"></a><strong>2. 对锁的处理不同（最核心区别）</strong></h3><ul>
<li><strong><code>wait()</code><strong>：</strong>会释放当前线程持有的对象锁</strong>。调用 <code>wait()</code> 时，线程必须先持有该对象的锁（在 <code>synchronized</code> 同步块 &#x2F; 方法中），调用后会释放锁并进入该对象的 “等待队列”，其他线程可以获取该锁。</li>
<li><strong><code>sleep()</code><strong>：</strong>不会释放任何锁</strong>。即使线程持有 <code>synchronized</code> 锁，<code>sleep()</code> 期间锁仍被当前线程持有，其他线程无法获取该锁。</li>
</ul>
<h3 id="3-使用场景不同"><a href="#3-使用场景不同" class="headerlink" title="3. 使用场景不同"></a><strong>3. 使用场景不同</strong></h3><ul>
<li><strong><code>wait()</code><strong>：用于</strong>线程间协作</strong>，等待某个条件满足（如生产者 - 消费者模型中，消费者等待商品生产完成）。必须在 <code>synchronized</code> 同步块 &#x2F; 方法中调用，否则会抛出 <code>IllegalMonitorStateException</code>。</li>
<li><strong><code>sleep()</code><strong>：用于</strong>让当前线程暂停执行一段固定时间</strong>（如模拟网络延迟、定时轮询），与线程间协作无关，无需在同步块中调用。</li>
</ul>
<h3 id="4-唤醒方式不同"><a href="#4-唤醒方式不同" class="headerlink" title="4. 唤醒方式不同"></a><strong>4. 唤醒方式不同</strong></h3><ul>
<li>**<code>wait()</code>**：<ul>
<li>需通过其他线程调用同一个对象的 <code>notify()</code> 或 <code>notifyAll()</code> 唤醒（进入就绪状态，重新竞争锁）。</li>
<li>若调用 <code>wait(long timeout)</code>，超时后会自动唤醒。</li>
</ul>
</li>
<li>**<code>sleep()</code>**：<ul>
<li>时间到后自动唤醒（进入就绪状态）。</li>
<li>可被其他线程调用 <code>interrupt()</code> 中断，抛出 <code>InterruptedException</code>。</li>
</ul>
</li>
</ul>
<h2 id="线程锁"><a href="#线程锁" class="headerlink" title="线程锁"></a>线程锁</h2><p>在并发编程中，<strong>锁（Lock）</strong> 是一种同步机制，用于控制多个执行单元（线程、进程）对共享资源的访问，确保资源在同一时间只能被一个执行单元操作，从而避免数据不一致、冲突或错误（如 “脏读”“丢失更新” 等问题）。</p>
<p>锁的分类本质是为了适应不同的并发场景：</p>
<ul>
<li>单进程内线程同步优先用 <strong>线程锁</strong>（<code>synchronized</code>、<code>ReentrantLock</code>）；</li>
<li>跨进程同步用 <strong>进程锁</strong> 或 <strong>分布式锁</strong>；</li>
<li>读多写少用 <strong>共享锁 &#x2F; 乐观锁</strong>，写操作频繁用 <strong>排他锁 &#x2F; 悲观锁</strong>；</li>
<li>需公平性用 <strong>公平锁</strong>，追求性能用 <strong>非公平锁</strong>。</li>
</ul>
<h2 id="锁的分类"><a href="#锁的分类" class="headerlink" title="锁的分类"></a>锁的分类</h2><table>
<thead>
<tr>
<th><strong>锁类型</strong></th>
<th><strong>核心思想</strong></th>
<th><strong>实现方式</strong></th>
<th><strong>适用场景</strong></th>
<th><strong>优点</strong></th>
<th><strong>缺点</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>悲观锁</strong></td>
<td>假设冲突一定会发生，先加锁再操作</td>
<td>- Java:synchronized关键字、ReentrantLock</td>
<td>写操作频繁、冲突概率高的场景</td>
<td>数据安全性高，避免并发冲突</td>
<td>性能开销大，可能导致线程阻塞</td>
</tr>
<tr>
<td><strong>乐观锁</strong></td>
<td>假设冲突很少发生，更新时检查版本</td>
<td>通过版本号（Version）或时间戳（Timestamp）实现</td>
<td>读操作频繁、冲突概率低的场景</td>
<td>无需加锁，并发性能高</td>
<td>可能需要重试，不适合高冲突场景</td>
</tr>
<tr>
<td><strong>公平锁</strong></td>
<td>按请求顺序分配锁（先到先得）</td>
<td>- Java:ReentrantLock(true)</td>
<td>需要保证线程公平性、避免饥饿的场景</td>
<td>避免线程饥饿，执行顺序可预测</td>
<td>维护队列开销大，上下文切换频繁</td>
</tr>
<tr>
<td><strong>非公平锁</strong></td>
<td>不按请求顺序分配锁，当前线程优先</td>
<td>- Java:ReentrantLock()（默认）</td>
<td>追求高吞吐量、允许线程饥饿的场景</td>
<td>减少上下文切换，性能更高</td>
<td>可能导致部分线程长时间无法获取锁</td>
</tr>
<tr>
<td><strong>可重入锁</strong></td>
<td>允许同一线程多次获取同一把锁</td>
<td>- Java:ReentrantLock</td>
<td>递归调用或嵌套锁的场景</td>
<td>避免死锁，简化代码逻辑</td>
<td>需注意锁的释放顺序</td>
</tr>
<tr>
<td><strong>读写锁</strong></td>
<td>读锁共享、写锁独占</td>
<td>- Java:ReentrantReadWriteLock</td>
<td>读多写少的场景</td>
<td>提高读操作并发度</td>
<td>写操作可能长时间等待</td>
</tr>
<tr>
<td><strong>自旋锁</strong></td>
<td>获取锁失败时循环等待而非阻塞</td>
<td>- Java: 通过AtomicBoolean</td>
<td>锁持有时间短、线程不希望被阻塞的场景</td>
<td>减少线程上下文切换</td>
<td>消耗 CPU 资源，不适用于长耗时操作</td>
</tr>
</tbody></table>
<h2 id="你知道Java中有哪些锁吗？"><a href="#你知道Java中有哪些锁吗？" class="headerlink" title="你知道Java中有哪些锁吗？"></a>你知道Java中有哪些锁吗？</h2><p><strong>synchronized</strong>（关键字，JVM实现）<br>特性：可重入、自动释放、非公平锁<br>优势：代码简洁，低竞争时性能优异<br><strong>ReentrantLock</strong>（类，JUC包，基于AQS）<br>特性：可重入、手动释放（finally中unclock()）、提供限时等待、支持公平\非公平锁<br>优势：高竞争场景（非公平模式）性能略优（减少线程切换）<br><strong>ReadWriteLock</strong>（如ReentrantReadWriteLock）<br>特性：读锁共享，写锁互斥<br>优势：读操作并发高，写操作互斥保持数据一致性<br><strong>StampedLock</strong>（JDK8+，优化读写锁）<br>特性：支持乐观读（无锁读取，验证版本号，冲突时降级为读锁），三种模式（读、写、乐观读）<br>优势：乐观读的性能远远优于读写锁（无锁竞争），适合用于极低写频率场景（如统计系统）</p>
<h2 id="Synchronized-用过吗，其原理是什么"><a href="#Synchronized-用过吗，其原理是什么" class="headerlink" title="Synchronized 用过吗，其原理是什么"></a>Synchronized 用过吗，其原理是什么</h2><p><code>synchronized</code> 是 Java 中最基础也最常用的线程同步机制，用于保证多线程环境下临界区代码的原子性、可见性和有序性。<code>synchronized</code> 可作用于<strong>方法</strong>或<strong>代码块</strong>，核心是通过 “锁对象” 实现线程互斥：</p>
<p><strong>互斥性</strong>：Synchronized 保证同一时刻只有一个线程可以获取锁，并且只有该线程可以执行同步代码块中的代码。</p>
<p><strong>可重入性</strong>：同一个线程可以多次获取同步锁而不会被阻塞，这样可以避免死锁的发生。</p>
<p><strong>独占性</strong>： 如果一个线程获得了对象的锁，则其他线程必须等待该线程释放锁之后才能获取锁。</p>
<p>核心原理：</p>
<p><code>synchronized</code> 的底层实现依赖 <strong>JVM 的锁机制</strong> 和 <strong>对象头（Object Header）</strong> 中的标记位，其核心逻辑是 “通过锁对象控制线程对临界区的访问”。</p>
<h4 id="1-锁的载体：对象头（Object-Header）"><a href="#1-锁的载体：对象头（Object-Header）" class="headerlink" title="1. 锁的载体：对象头（Object Header）"></a>1. <strong>锁的载体：对象头（Object Header）</strong></h4><p>Java 中每个对象都有一个 “对象头”，用于存储对象的元数据（如哈希码、GC 年龄、锁状态等）。<code> synchronized</code> 的锁状态就记录在对象头的 <strong>Mark Word</strong> 中（32 位 JVM 中占 32bit，64 位占 64bit）。</p>
<h4 id="2-锁的升级：从无锁到重量级锁"><a href="#2-锁的升级：从无锁到重量级锁" class="headerlink" title="2. 锁的升级：从无锁到重量级锁"></a>2. <strong>锁的升级：从无锁到重量级锁</strong></h4><p>为了减少锁的开销，JVM 对 <code>synchronized</code> 进行了<strong>分层优化</strong>，锁会根据竞争程度从 “低开销” 向 “高开销” 动态升级（不可逆）：</p>
<ul>
<li><strong>第一步：无锁状态</strong>对象刚创建时，Mark Word 存储哈希码等信息，无锁竞争。</li>
<li><strong>第二步：偏向锁（Biased Locking）</strong>当只有一个线程多次获取锁时，锁会 “偏向” 这个线程：<ul>
<li>首次获取锁时，通过 CAS 操作将线程 ID 写入对象头的 Mark Word，设置 “偏向锁标志” 为 1。</li>
<li>后续该线程再次进入同步块时，无需竞争，直接通过线程 ID 匹配确认持有锁（几乎无开销）。</li>
<li><strong>触发升级</strong>：当有其他线程尝试获取锁时，偏向锁会膨胀为轻量级锁。</li>
</ul>
</li>
<li><strong>第三步：轻量级锁（Lightweight Locking）</strong>当出现轻度锁竞争（线程交替获取锁，无长时间阻塞）时：<ul>
<li>线程获取锁时，会在自己的栈帧中创建 “锁记录（Lock Record）”，存储对象头中 Mark Word 的拷贝（Displaced Mark Word）。</li>
<li>通过 CAS 操作将对象头的 Mark Word 替换为指向栈中锁记录的指针（表示持有轻量级锁）。</li>
<li>若 CAS 成功，获取锁；若失败（说明有竞争），线程会自旋（循环重试）几次，仍失败则升级为重量级锁。</li>
</ul>
</li>
<li><strong>第四步：重量级锁（Heavyweight Locking）</strong>当竞争激烈（自旋失败或线程阻塞）时，锁升级为重量级锁：<ul>
<li>依赖操作系统的 <strong>互斥量（Mutex）</strong> 实现，线程获取不到锁时会进入内核态阻塞（放弃 CPU），等待锁释放后被唤醒。</li>
<li>开销大（涉及用户态与内核态切换），但适合长时间持有锁或高竞争场景</li>
</ul>
</li>
</ul>
<h2 id="Lock-与-synchronized-的对比"><a href="#Lock-与-synchronized-的对比" class="headerlink" title="Lock 与 synchronized 的对比"></a><strong><code>Lock</code> 与 <code>synchronized</code> 的对比</strong></h2><table>
<thead>
<tr>
<th>特性</th>
<th><code>Lock</code>（如 <code>ReentrantLock</code>）</th>
<th><code>synchronized</code></th>
</tr>
</thead>
<tbody><tr>
<td>锁获取 &#x2F; 释放</td>
<td>显式调用 <code>lock()</code>&#x2F;<code>unlock()</code>（需手动释放）</td>
<td>隐式（JVM 自动获取 &#x2F; 释放）</td>
</tr>
<tr>
<td>可重入性</td>
<td>支持</td>
<td>支持</td>
</tr>
<tr>
<td>公平性</td>
<td>可选择（公平 &#x2F; 非公平）</td>
<td>仅非公平</td>
</tr>
<tr>
<td>中断响应</td>
<td>支持（<code>lockInterruptibly()</code>）</td>
<td>不支持（等待时无法被中断）</td>
</tr>
<tr>
<td>超时获取</td>
<td>支持（<code>tryLock(time)</code>）</td>
<td>不支持</td>
</tr>
<tr>
<td>条件变量</td>
<td>支持多个 <code>Condition</code>（精细控制）</td>
<td>仅一个等待队列（<code>wait()</code>&#x2F;<code>notify()</code>）</td>
</tr>
<tr>
<td>性能</td>
<td>高并发下性能更稳定</td>
<td>低并发下优化好（偏向锁 &#x2F; 轻量级锁）</td>
</tr>
</tbody></table>
<h2 id="ReentrantLock-的底层原理"><a href="#ReentrantLock-的底层原理" class="headerlink" title="ReentrantLock****的底层原理"></a><strong>ReentrantLock****的底层原理</strong></h2><p><code>ReentrantLock</code> 是基于 <strong>AQS（AbstractQueuedSynchronizer）</strong> 实现的可重入独占锁，它比 <code>synchronized</code> 更灵活、更可控。</p>
<p><code>ReentrantLock</code> 内部通过一个 <strong>Sync</strong> 对象（继承自 AQS）来实现锁的获取与释放：AQS 内部维护一个整数 <code>state</code> 表示锁状态：</p>
<ul>
<li><code>state = 0</code> 表示未加锁；</li>
<li><code>state &gt; 0</code> 表示已加锁（持有线程数，也体现“可重入性”）。</li>
</ul>
<p>加锁流程（lock）</p>
<h4 id="1-CAS-尝试加锁"><a href="#1-CAS-尝试加锁" class="headerlink" title="1. CAS 尝试加锁"></a>1. CAS 尝试加锁</h4><p>当线程调用 <code>lock()</code> 时：</p>
<ul>
<li>若当前 <code>state == 0</code>（无锁），通过 <strong>CAS</strong>（Compare-And-Swap）将其改为 1；</li>
<li>若成功，当前线程成为锁的持有者；</li>
<li>若失败（锁被占用），进入 <strong>AQS 等待队列</strong>。</li>
</ul>
<h4 id="2-可重入性"><a href="#2-可重入性" class="headerlink" title="2. 可重入性"></a>2. 可重入性</h4><p>如果当前线程已经持有锁，则允许再次进入：</p>
<h4 id="3-入队与阻塞"><a href="#3-入队与阻塞" class="headerlink" title="3. 入队与阻塞"></a>3. 入队与阻塞</h4><p>若其他线程也想获取锁，<code>tryAcquire()</code> 失败后会调用 <code>acquire()</code>：</p>
<ul>
<li>AQS 会创建一个 <code>Node</code>（包含线程、状态、前后指针），加入 <strong>CLH 双向队列</strong>；</li>
<li>线程会被 <code>LockSupport.park()</code> 阻塞，直到前驱节点释放锁。</li>
</ul>
<h3 id="公平锁与非公平锁"><a href="#公平锁与非公平锁" class="headerlink" title="公平锁与非公平锁"></a>公平锁与非公平锁</h3><ul>
<li><strong>非公平锁（默认）</strong>：新线程插队尝试直接获取锁，竞争激烈时性能高；</li>
<li><strong>公平锁</strong>：线程必须排队，遵循“先到先得”，通过 <code>hasQueuedPredecessors()</code> 判断是否排队。</li>
</ul>
<h2 id="解释一下volatile关键字的作用和使用场景。"><a href="#解释一下volatile关键字的作用和使用场景。" class="headerlink" title="解释一下volatile关键字的作用和使用场景。"></a>解释一下volatile关键字的作用和使用场景。</h2><p><code>volatile</code> 是 Java 中用于保证变量<strong>可见性</strong>和<strong>禁止指令重排序</strong>的关键字级关键字，主要用于解决多线程环境下共享变量的同步问题，但它<strong>不保证原子性</strong>。</p>
<h3 id="一、volatile-的核心作用"><a href="#一、volatile-的核心作用" class="headerlink" title="一、volatile 的核心作用"></a><strong>一、volatile 的核心作用</strong></h3><h4 id="1-保证可见性"><a href="#1-保证可见性" class="headerlink" title="1. 保证可见性"></a>1. 保证可见性</h4><p>当一个变量被 <code>volatile</code> 修饰时，它会确保：</p>
<ul>
<li>线程对该变量的<strong>修改会立即刷新到主内存</strong>（而非仅停留在线程的工作内存）。</li>
<li>其他线程读取该变量时，会<strong>直接从主内存加载最新值</strong>（而非使用工作内存中的缓存副本）。</li>
</ul>
<p><strong>没有 volatile 的问题</strong>：多线程环境中，线程会将共享变量从主内存加载到自己的工作内存（CPU 缓存）中操作，若变量未被 <code>volatile</code> 修饰，一个线程的修改可能不会及时同步到主内存，导致其他线程读取到旧值（“不可见”）。</p>
<h4 id="2-禁止指令重排序"><a href="#2-禁止指令重排序" class="headerlink" title="2. 禁止指令重排序"></a>2. 禁止指令重排序</h4><p>编译器或 CPU 为了优化性能，可能会对<strong>没有数据依赖</strong>的指令进行重排序（调整执行顺序）。<code>volatile</code> 会通过<strong>内存屏障</strong>（Memory Barrier）禁止这种重排序，保证指令执行顺序与代码逻辑一致。</p>
<p><strong>没有 volatile 的风险</strong>：在初始化单例对象等场景中，指令重排序可能导致其他线程获取到 “未完全初始化” 的对象。</p>
<h3 id="volatile-的实现原理是什么？"><a href="#volatile-的实现原理是什么？" class="headerlink" title="volatile 的实现原理是什么？"></a><code>volatile</code> 的实现原理是什么？</h3><p>底层实现靠的是 <strong>JVM 在读写 volatile 变量时插入内存屏障指令</strong>。<br> 不同 CPU 架构实现不同，但通用原理一致：</p>
<ul>
<li><strong>写屏障（Store Barrier）</strong>：强制将工作内存中变量刷新到主内存。</li>
<li><strong>读屏障（Load Barrier）</strong>：强制从主内存中重新读取最新值。</li>
</ul>
<p><code>volatile</code> 通过在读写操作前后插入内存屏障（Memory Barrier）， 确保变量的可见性和有序性，底层依赖 CPU 的缓存一致性协议（MESI）。 但它不保证复合操作的原子性，因此只能用于状态标志或单次读写场景。</p>
<h2 id="volatile-与-synchronized-的区别"><a href="#volatile-与-synchronized-的区别" class="headerlink" title="volatile 与 synchronized 的区别"></a><strong>volatile 与 synchronized 的区别</strong></h2><table>
<thead>
<tr>
<th>特性</th>
<th>volatile</th>
<th>synchronized</th>
</tr>
</thead>
<tbody><tr>
<td>作用</td>
<td>保证可见性、禁止重排序</td>
<td>保证原子性、可见性、有序性</td>
</tr>
<tr>
<td>原子性</td>
<td>不保证（复合操作不安全）</td>
<td>保证（临界区代码原子执行）</td>
</tr>
<tr>
<td>开销</td>
<td>轻量（无锁竞争）</td>
<td>可能较重（锁升级机制优化）</td>
</tr>
<tr>
<td>适用场景</td>
<td>状态标记、简单变量读写</td>
<td>复杂逻辑、复合操作</td>
</tr>
</tbody></table>
<h2 id="ReentrantLock的底层原理"><a href="#ReentrantLock的底层原理" class="headerlink" title="ReentrantLock的底层原理"></a>ReentrantLock的底层原理</h2><p>ReentrantLock是 Java 里用于实现线程同步的一个类，它出自java.util.concurrent.locks包，提供了比synchronized关键字更丰富的锁操作。其底层原理主要基于 AQS（Abstract Queued Synchronizer）框架：</p>
<p><strong>1. AQS</strong> <strong>框架概述</strong></p>
<p>AQS 是一个用于构建锁和同步器的框架，很多同步类的实现都依赖于它，像ReentrantLock、CountDownLatch等。AQS 内部维护了一个volatile int state变量，用于表示同步状态，还维护了一个FIFO（先进先出）的线程等待队列。</p>
<p><strong>2.</strong> ReentrantLock<strong>的结构</strong></p>
<p>ReentrantLock内部有一个静态抽象类Sync，它继承自AbstractQueuedSynchronizer，并且有两个具体的实现类：NonfairSync（非公平锁）和FairSync（公平锁）。</p>
<p><strong>3.</strong> <strong>非公平锁（</strong>NonfairSync<strong>）的加锁原理</strong></p>
<p><strong>尝试直接获取锁</strong>：当线程调用lock()方法时，ReentrantLock会先尝试直接将state状态从 0 变为1，如果成功，就表示获取到了锁，当前线程成为锁的持有者。</p>
<p><strong>进入</strong> <strong>AQS</strong> <strong>队列</strong>：若尝试失败，线程会进入 AQS 的等待队列。</p>
<p><strong>重入情况</strong>：如果当前线程已经是锁的持有者，再次获取锁时，state的值会加 1，这体现了锁的可重入性。</p>
<p><strong>4.</strong> <strong>公平锁（</strong>FairSync<strong>）的加锁原理</strong></p>
<p><strong>检查队列</strong>：公平锁在获取锁时，会先检查 AQS 队列中是否有其他线程在等待，如果有，当前线程会进入队列尾部等待。</p>
<p><strong>尝试获取锁</strong>：若队列中没有其他线程等待，才会尝试将state状态从 0 变为 1。<strong>5.</strong> <strong>解锁原理</strong></p>
<p><strong>释放锁</strong>：当线程调用unlock()方法时，会将state的值减 1。</p>
<p><strong>完全释放</strong>：若state的值减为 0，就表示锁被完全释放，此时会唤醒 AQS 队列中等待的线程。</p>
<h2 id="多线程如何获取异步执行结果"><a href="#多线程如何获取异步执行结果" class="headerlink" title="多线程如何获取异步执行结果"></a><strong>多线程如何获取异步执行结果</strong></h2><h4 id="（1）Future-Callable（最常用）"><a href="#（1）Future-Callable（最常用）" class="headerlink" title="（1）Future + Callable（最常用）"></a>（1）<code>Future</code> + <code>Callable</code>（最常用）</h4><ul>
<li><code>Callable</code> 是带返回值的线程任务接口，与 <code>Runnable</code> 不同，它的 <code>call()</code> 方法可以返回结果。</li>
<li><code>Future</code> 是一个 “未来结果” 的容器，用于存储 <code>Callable</code> 的执行结果，支持阻塞等待结果、超时等待等。</li>
</ul>
<h4 id="（2）CompletableFuture（Java-8-，非阻塞式）"><a href="#（2）CompletableFuture（Java-8-，非阻塞式）" class="headerlink" title="（2）CompletableFuture（Java 8+，非阻塞式）"></a>（2）<code>CompletableFuture</code>（Java 8+，非阻塞式）</h4><p><code>CompletableFuture</code> 支持异步回调，无需主动阻塞等待，更适合复杂的异步流程（如链式调用、多任务组合）。</p>
<h2 id="什么是线程死锁？死锁如何产生？"><a href="#什么是线程死锁？死锁如何产生？" class="headerlink" title="什么是线程死锁？死锁如何产生？"></a><strong>什么是线程死锁？死锁如何产生？</strong></h2><p>例如，假设线程 A 持有资源 X，并等待资源 Y，而线程 B持有资源 Y，并等待资源 X，这时候就会出现死锁。</p>
<p><strong>死锁</strong></p>
<p>线程死锁是指由于两个或者多个线程互相持有对方所需要的资源，导致这些线程处于等待状态，无法前往执行。</p>
<p>当线程进入对象的synchronized代码块时，便占有了资源，直到它退出该代码块或者调用wait方法，才释放资</p>
<p>源，在此期间，其他线程将不能进入该代码块。当线程互相持有对方所需要的资源时，会互相等待对方</p>
<p>释放资源，如果线程都不主动释放所占有的资源，将产生死锁。</p>
<p><strong>死锁的产生的一些特定条件</strong></p>
<p>Java 中，死锁产生的一些特定条件通常包括以下四个方面：</p>
<p>互斥条件：一个资源一次只能被一个线程持有，如果其他线程想要获取该资源，就必须等待该线程释放该资源。</p>
<p>请求保持：一个线程请求资源时，如果已经持有了其他资源，就可以保持对这些资源的控制，直到满足所有资源的要求才释放。</p>
<p>不剥夺条件：已经分配的资源不能被其他线程剥夺，只能由持有资源的线程释放。</p>
<p>循环等待条件：多个线程形成一种循环等待的关系，每个线程都在等待其他线程所持有的资源，从而导致死锁的产生。</p>
<p>当以上条件同时满足时，就可能会出现死锁的情况。为了避免死锁，需要在设计时遵循一定的规范和原则，例如尽量避免嵌套锁，确保同步代码块执行时间尽可能短等，同时也可以使用专门的工具进行死锁检测和分析，帮助我们找到死锁的根本原因并进行相应的优化和调整。</p>
<p><strong>如何避免死锁</strong></p>
<p>要避免线程死锁，可以采取以下几种方法：</p>
<p>尽量避免使用多个锁，尽量使用一个锁或者使用更加高级的锁，例如读写锁或者 ReentrantLock。</p>
<p>确保同步代码块的执行时间尽可能短，这样可以减少线程等待时间，从而避免死锁的产生。</p>
<p>使用更高级的锁，通过 ReentrantLock.tryLock() 方法可以尝试获取锁，如果在规定时间内获取不到锁，则放弃锁。</p>
<p>避免嵌套锁，如果需要使用多个锁，请确保它们的获取顺序是一致的，这样可以避免死锁。</p>
<h2 id="ThreadLocal-原理？底层如何防止内存泄漏？"><a href="#ThreadLocal-原理？底层如何防止内存泄漏？" class="headerlink" title="ThreadLocal 原理？底层如何防止内存泄漏？"></a>ThreadLocal 原理？底层如何防止内存泄漏？</h2><p>ThreadLocal 为每个线程维护一个独立的变量副本，底层通过 <code>Thread</code> 持有的 <code>ThreadLocalMap</code> 存储，<br> 其中 <code>key</code> 是对 ThreadLocal 的弱引用（防止对象无法回收），<code>value</code> 是强引用。<br> 为避免 key 被回收后 value 残留导致内存泄漏，JVM 在 <code>get/set/remove</code> 时会清理 key&#x3D;null 的条目，<br> 但开发者仍应在使用后手动调用 <code>remove()</code> 释放资源。</p>
<p>ThreadLocal 为每个线程提供一个<strong>独立的变量副本</strong>，让变量在多线程间互不干扰。</p>
<p>每个线程都持有自己独立的 <code>ThreadLocalMap</code>。key：<code>ThreadLocal</code>（<strong>弱引用 WeakReference</strong>）。value：实际存放的对象（<strong>强引用</strong>）</p>
<p>ThreadLocalMap 的 key 是弱引用，value 是强引用。<br> 当外部没有引用 ThreadLocal 对象时，key 会被 GC 回收，key&#x3D;null，但 value 还强引用着对象。</p>
<p>如果当前线程是<strong>线程池中的线程</strong>（不会销毁），<br> 这些 <code>value</code> 就会永远被挂在 <code>ThreadLocalMap</code> 里，导致 <strong>内存泄漏（Memory Leak）</strong>。</p>
<h2 id="什么是线程安全？怎么保证线程安全？"><a href="#什么是线程安全？怎么保证线程安全？" class="headerlink" title="什么是线程安全？怎么保证线程安全？"></a>什么是线程安全？怎么保证线程安全？</h2><p>当多个线程<strong>同时访问同一份共享数据</strong>时，无论执行时序如何交替，<strong>程序的执行结果都是一致且符合预期的</strong>，那么我们说这个代码是线程安全的。</p>
<p>线程不安全的根源：三大问题</p>
<ol>
<li><strong>原子性（Atomicity）缺失</strong><br> 操作不是一个不可分割的整体，比如 <code>i++</code> 实际是三步（读、加、写）。</li>
<li><strong>可见性（Visibility）问题</strong><br> 线程对变量的修改，其他线程看不到（因为 CPU 缓存、JMM 工作内存）。</li>
<li><strong>有序性（Ordering）问题</strong><br> 指令重排（reordering）让程序执行顺序与预期不一致。</li>
</ol>
<h3 id="如何保证线程安全（从思想到实现）"><a href="#如何保证线程安全（从思想到实现）" class="headerlink" title="如何保证线程安全（从思想到实现）"></a>如何保证线程安全（从思想到实现）</h3><h4 id="不共享（线程封闭-Thread-Confinement）"><a href="#不共享（线程封闭-Thread-Confinement）" class="headerlink" title="不共享（线程封闭 Thread Confinement）"></a><strong>不共享（线程封闭 Thread Confinement）</strong></h4><p>最简单的线程安全：不让数据共享。</p>
<ul>
<li><strong>局部变量</strong>（每个线程栈独有）</li>
<li><strong>ThreadLocal</strong>（线程隔离）</li>
</ul>
<h4 id="不可变（Immutable）对象"><a href="#不可变（Immutable）对象" class="headerlink" title="不可变（Immutable）对象"></a><strong>不可变（Immutable）对象</strong></h4><p>如果对象不可变（immutable），线程之间共享也没问题。</p>
<p>典型例子：</p>
<ul>
<li><code>String</code></li>
<li><code>Integer</code></li>
<li><code>BigDecimal</code></li>
</ul>
<p>因为不可变对象状态不会改变，所以天然线程安全。</p>
<h4 id="互斥锁（Synchronized-Lock）"><a href="#互斥锁（Synchronized-Lock）" class="headerlink" title="互斥锁（Synchronized &#x2F; Lock）"></a>互斥锁（Synchronized &#x2F; Lock）</h4><p>让多个线程“排队”访问共享资源。</p>
<p>这类机制确保：</p>
<ul>
<li>同一时刻只有一个线程执行临界区；</li>
<li>写操作对其他线程可见；</li>
<li>保证原子性和有序性。</li>
</ul>
<h4 id="原子类（CAS-volatile-实现无锁并发）"><a href="#原子类（CAS-volatile-实现无锁并发）" class="headerlink" title="原子类（CAS + volatile 实现无锁并发）"></a>原子类（CAS + volatile 实现无锁并发）</h4><p>使用 <strong>CAS（Compare And Swap）</strong> 实现原子更新，不用加锁。CAS 底层依赖 CPU 指令（如 x86 的 <code>LOCK CMPXCHG</code>），保证操作不可中断。</p>
<p>“线程安全是指多个线程同时访问共享变量时，能保证数据一致性和程序的预期行为。<br> 它主要涉及原子性、可见性、有序性三大问题。<br> 保障方式有多种：<br> 1）通过线程封闭或不可变对象避免共享；<br> 2）通过 synchronized &#x2F; Lock 实现互斥访问；<br> 3）通过 CAS 实现无锁原子操作；<br> 4）通过并发容器封装线程安全逻辑。<br> 实际项目中会根据场景权衡性能与安全。”</p>
<h2 id="什么是“可见性”、“原子性”、“有序性”？"><a href="#什么是“可见性”、“原子性”、“有序性”？" class="headerlink" title="什么是“可见性”、“原子性”、“有序性”？"></a>什么是“可见性”、“原子性”、“有序性”？</h2><h3 id="可见性（Visibility）"><a href="#可见性（Visibility）" class="headerlink" title="可见性（Visibility）"></a>可见性（Visibility）</h3><p><strong>定义：</strong><br> 当一个线程修改了共享变量的值，其他线程能够<strong>立即看到这个修改</strong>。</p>
<p><strong>问题来源：</strong><br> Java 中每个线程都有一个<strong>工作内存（线程本地缓存）</strong>，它会从主内存中拷贝变量的值到本地进行计算。<br> 修改后，不一定马上写回主内存。<br> 所以另一个线程可能还在读旧值。</p>
<p><strong>解决：</strong></p>
<ul>
<li>使用 <code>volatile</code> 保证可见性；</li>
<li>使用 <code>synchronized</code>、<code>Lock</code>（它们隐含内存屏障）；</li>
<li>使用 <code>final</code>（构造完成后值不会再变）。</li>
</ul>
<h3 id="原子性（Atomicity）"><a href="#原子性（Atomicity）" class="headerlink" title="原子性（Atomicity）"></a>原子性（Atomicity）</h3><p><strong>定义：</strong><br> 一个操作或一组操作要么全部执行完毕，要么全部不执行，不会出现中间状态。</p>
<p><strong>问题来源：</strong><br> 很多看似简单的操作其实<strong>不是原子的</strong>。</p>
<p><strong>解决：</strong></p>
<ul>
<li>使用 <strong>synchronized</strong> 或 <strong>Lock</strong>，让操作互斥；</li>
<li>使用 <strong>原子类</strong>（<code>AtomicInteger</code>、<code>AtomicReference</code>），底层用 CAS（Compare-And-Swap） 实现；</li>
<li>使用 <strong>不可变对象（Immutable Object）</strong>。</li>
</ul>
<h3 id="有序性（Ordering）"><a href="#有序性（Ordering）" class="headerlink" title="有序性（Ordering）"></a>有序性（Ordering）</h3><p><strong>定义：</strong><br> 程序的执行顺序与代码顺序一致。</p>
<p><strong>问题来源：</strong><br> 编译器和 CPU 会对指令进行 <strong>重排序（Instruction Reordering）</strong>，以提高性能。<br> 重排序对单线程无影响，但多线程下可能出事。</p>
<p><strong>解决：</strong></p>
<ul>
<li>使用 <code>volatile</code>（禁止重排序）；</li>
<li>使用 <code>synchronized</code> 或 <code>Lock</code>；</li>
<li>使用 <code>happens-before</code> 原则保证执行顺序。</li>
</ul>
<h2 id="AQS"><a href="#AQS" class="headerlink" title="AQS"></a>AQS</h2><p>AQS，全称是 <strong>AbstractQueuedSynchronizer（抽象队列同步器）</strong>，是 <strong>Java 并发包（<code>java.util.concurrent.locks</code>）的核心基础类</strong>。<br> 几乎所有常用的并发同步工具类（如 <code>ReentrantLock</code>、<code>CountDownLatch</code>、<code>Semaphore</code>、<code>ReentrantReadWriteLock</code>、<code>CyclicBarrier</code>）的底层实现都依赖于它。</p>
<p>AQS 通过一个「状态值（state）」 + 「FIFO 双向队列」来管理线程的竞争与阻塞。</p>
<p>简单来说：</p>
<ul>
<li><strong>state</strong> 表示资源状态（比如锁是否被占用、剩余许可数等）。</li>
<li><strong>CAS（Compare And Swap）</strong> 用来原子修改 state。</li>
<li><strong>CLH 队列（FIFO）</strong> 维护等待的线程队列。</li>
</ul>
<p>AQS 把“<strong>同步器的共性</strong>”抽象出来，让开发者只需要实现它的几个钩子方法，就能轻松构建各种并发控制器。</p>
<h3 id="AQS-的两种模式"><a href="#AQS-的两种模式" class="headerlink" title="AQS 的两种模式"></a>AQS 的两种模式</h3><p>AQS 支持两种同步模式：</p>
<ol>
<li><strong>独占模式（Exclusive）</strong><ul>
<li>同一时间只有一个线程能持有资源。</li>
<li>典型代表：<code>ReentrantLock</code></li>
</ul>
</li>
<li><strong>共享模式（Shared）</strong><ul>
<li>允许多个线程同时获取资源。</li>
<li>典型代表：<code>Semaphore</code>、<code>CountDownLatch</code>、<code>ReentrantReadWriteLock.ReadLock</code></li>
</ul>
</li>
</ol>
<h2 id="CAS"><a href="#CAS" class="headerlink" title="CAS"></a>CAS</h2><p>CAS 是一种 <strong>无锁（Lock-Free）并发原语</strong>，用于在多线程环境下实现原子操作。</p>
<p>当且仅当内存中的值等于预期值时，才把它更新为新值，否则不做任何修改。</p>
<h3 id="CAS-的优点"><a href="#CAS-的优点" class="headerlink" title="CAS 的优点"></a>CAS 的优点</h3><ol>
<li><strong>无锁高性能</strong><br> 不阻塞线程，适合高并发下的原子更新。</li>
<li><strong>避免上下文切换开销</strong><br> 不像 synchronized 那样需要内核态的锁管理。</li>
<li><strong>原子性由硬件保证</strong><br> 无需锁机制就能确保线程安全。</li>
</ol>
<h3 id="CAS-的问题（面试高频）"><a href="#CAS-的问题（面试高频）" class="headerlink" title="CAS 的问题（面试高频）"></a>CAS 的问题（面试高频）</h3><h4 id="1-ABA-问题"><a href="#1-ABA-问题" class="headerlink" title="1. ABA 问题"></a>1. ABA 问题</h4><p>举个例子：</p>
<ul>
<li>线程 T1 读取值 A；</li>
<li>线程 T2 把 A 改成 B，又改回 A；</li>
<li>T1 再比较时发现值还是 A，于是以为没人改过，但实际上它被改过。</li>
</ul>
<p>解决方案：</p>
<ul>
<li>使用 <strong>版本号机制</strong>，比如 <code>AtomicStampedReference</code>，记录值的版本：每次修改不仅改值，还更新版本号。</li>
</ul>
<h4 id="2-自旋开销大"><a href="#2-自旋开销大" class="headerlink" title="2. 自旋开销大"></a>2. 自旋开销大</h4><p>当竞争激烈时，线程会一直自旋重试，导致 CPU 占用高。</p>
<p>优化：</p>
<ul>
<li>Java 内部有 <strong>自适应自旋锁</strong>，如果线程竞争不频繁，则短暂自旋；</li>
<li>否则直接挂起线程，避免浪费。</li>
</ul>
<h4 id="3-只能保证单个变量的原子性"><a href="#3-只能保证单个变量的原子性" class="headerlink" title="3. 只能保证单个变量的原子性"></a>3. 只能保证单个变量的原子性</h4><p>CAS 只能保证一个内存地址的更新是原子的。<br> 如果要同时修改多个变量，就得用更高层的机制，比如 <code>AtomicReference</code> 封装对象，或使用锁。</p>
</article><div class="post-copyright"><div class="copyright-cc-box"><i class="anzhiyufont anzhiyu-icon-copyright"></i></div><div class="post-copyright__author_box"><a class="post-copyright__author_img" href="/" title="头像"><img class="post-copyright__author_img_back" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://s2.loli.net/2022/11/07/QVWvrnAsuGxelbS.jpg" title="头像" alt="头像"><img class="post-copyright__author_img_front" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://s2.loli.net/2022/11/07/QVWvrnAsuGxelbS.jpg" title="头像" alt="头像"></a><div class="post-copyright__author_name">Wsk</div><div class="post-copyright__author_desc">Believe in yourself</div></div><div class="post-copyright__post__info"><a class="post-copyright__original" title="该文章为原创文章，注意版权协议" href="https://wsk0404.github.io/posts/498cfd8e.html">原创</a><a class="post-copyright-title"><span onclick="rm.copyPageUrl('https://wsk0404.github.io/posts/498cfd8e.html')">并发编程</span></a></div><div class="post-tools" id="post-tools"><div class="post-tools-left"><div class="rewardLeftButton"><div class="post-reward" onclick="anzhiyu.addRewardMask()"><div class="reward-button button--animated" title="赞赏作者"><i class="anzhiyufont anzhiyu-icon-hand-heart-fill"></i>打赏作者</div><div class="reward-main"><div class="reward-all"><span class="reward-title">感谢你赐予我前进的力量</span><ul class="reward-group"><li class="reward-item"><a href="/./img/wechat.jpg" target="_blank"><img class="post-qr-code-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/./img/wechat.jpg" alt="微信"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="/./img/alipay.jpg" target="_blank"><img class="post-qr-code-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/./img/alipay.jpg" alt="支付宝"/></a><div class="post-qr-code-desc">支付宝</div></li></ul><a class="reward-main-btn" href="/about/#about-reward" target="_blank"><div class="reward-text">赞赏者名单</div><div class="reward-dec">因为你们的支持让我意识到写文章的价值🙏</div></a></div></div></div><div id="quit-box" onclick="anzhiyu.removeRewardMask()" style="display: none"></div><div class="reward-link mode"><a class="reward-link-button" href="/wecaht/"><i class="anzhiyufont anzhiyu-icon-plant-fill"></i>运营模式与责任</a></div></div><div class="shareRight"><div class="share-link mobile"><div class="share-qrcode"><div class="share-button" title="使用手机访问这篇文章"><i class="anzhiyufont anzhiyu-icon-qrcode"></i></div><div class="share-main"><div class="share-main-all"><div id="qrcode" title="https://wsk0404.github.io/posts/498cfd8e.html"></div><div class="reward-dec">使用手机访问这篇文章</div></div></div></div></div><div class="share-link weibo"><a class="share-button" target="_blank" href="https://service.weibo.com/share/share.php?title=并发编程&amp;url=https://wsk0404.github.io/posts/498cfd8e.html&amp;pic=https://s2.loli.net/2025/10/23/w3ErpsQhncfDed2.jpg?_r_=e93610d2-afe5-62c9-ffac-34bc6ede57ce" rel="external nofollow noreferrer noopener"><i class="anzhiyufont anzhiyu-icon-weibo"></i></a></div><div class="share-link copyurl"><div class="share-button" id="post-share-url" title="复制链接" onclick="rm.copyPageUrl()"><i class="anzhiyufont anzhiyu-icon-link"></i></div></div></div></div></div><div class="post-copyright__notice"><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://wsk0404.github.io" target="_blank">Wsk Blog</a>！</span></div></div><div class="post-tools-right"><div class="tag_share"><div class="post-meta__box"><div class="post-meta__box__tag-list"><a class="post-meta__box__tags" href="/tags/%E5%B9%B6%E5%8F%91/"><span class="tags-punctuation"> <i class="anzhiyufont anzhiyu-icon-tag"></i></span>并发<span class="tagsPageCount">1</span></a></div></div></div><div class="post_share"><div class="social-share" data-image="https://s2.loli.net/2025/10/23/w3ErpsQhncfDed2.jpg?_r_=7a487ade-a613-3f8f-d549-a793e3c2aa17" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.cbd.int/butterfly-extsrc@1.1.3/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"/><script src="https://cdn.cbd.int/butterfly-extsrc@1.1.3/sharejs/dist/js/social-share.min.js" defer="defer"></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/posts/7edb9ee1.html"><img class="prev-cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://s2.loli.net/2025/10/23/g4UkwyDri9BWZtE.jpg?_r_=15bc3fef-3044-c8b4-4d1c-cc585f957842" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">集合框架</div></div></a></div><div class="next-post pull-right"><a href="/posts/66c016fb.html"><img class="next-cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://s2.loli.net/2025/10/23/w3ErpsQhncfDed2.jpg?_r_=073fb3c1-1ed6-85dc-4b49-6bade417019f" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">JVM</div></div></a></div></nav><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="anzhiyufont anzhiyu-icon-comments"></i><span> 评论</span></div><div class="comment-randomInfo"><a onclick="anzhiyu.addRandomCommentInfo()" href="javascript:void(0)">匿名评论</a><a href="/privacy" style="margin-left: 4px">隐私政策</a></div></div><div class="comment-wrap"><div><div class="vcomment" id="vcomment"></div></div></div></div><div class="comment-barrage"></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="card-content"><div class="author-info__sayhi" id="author-info__sayhi" onclick="anzhiyu.changeSayHelloText()"></div><div class="author-info-avatar"><img class="avatar-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://s2.loli.net/2022/11/07/QVWvrnAsuGxelbS.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/><div class="author-status"><img class="g-status" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/zc998800/cdn/face/gif/m17.gif" ait="status"/></div></div><div class="author-info__description">路慢其修远兮 吾将上下而求索</div><div class="author-info__bottom-group"><a class="author-info__bottom-group-left" href="/"><h1 class="author-info__name">Wsk</h1><div class="author-info__desc">Believe in yourself</div></a><div class="card-info-social-icons is-center"><a class="social-icon faa-parent animated-hover" href="https://github.com/gukeyang" target="_blank" title="Github"><i class="anzhiyufont anzhiyu-icon-github"></i></a><a class="social-icon faa-parent animated-hover" href="https://space.bilibili.com/1542898061" target="_blank" title="BiliBili"><i class="anzhiyufont anzhiyu-icon-bilibili"></i></a></div></div></div></div><div class="card-widget anzhiyu-right-widget" id="card-wechat" onclick="null"><div id="flip-wrapper"><div id="flip-content"><div class="face" style="background: url(https://bu.dusays.com/2023/01/13/63c02edf44033.png) center center / 100% no-repeat"></div><div class="back face" style="background: url(https://s2.loli.net/2023/10/19/vNio4QGBSX9x5lO.png) center center / 100% no-repeat"></div></div></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-bars"></i><span>文章目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E7%BA%BF%E7%A8%8B%EF%BC%9F%E4%BB%80%E4%B9%88%E6%98%AF%E8%BF%9B%E7%A8%8B%EF%BC%9F"><span class="toc-number">1.</span> <span class="toc-text">什么是线程？什么是进程？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Java%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B%E6%9C%89%E5%93%AA%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F"><span class="toc-number">2.</span> <span class="toc-text">Java创建线程有哪几种方式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%A7%E6%89%BF%E8%87%AAThread%E7%B1%BB"><span class="toc-number">2.1.</span> <span class="toc-text">继承自Thread类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0Runnable%E6%8E%A5%E5%8F%A3"><span class="toc-number">2.2.</span> <span class="toc-text">实现Runnable接口</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0-Callable-%E6%8E%A5%E5%8F%A3%EF%BC%88%E5%B8%A6%E8%BF%94%E5%9B%9E%E5%80%BC%EF%BC%89"><span class="toc-number">2.3.</span> <span class="toc-text">实现 Callable 接口（带返回值）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%9A%E8%BF%87%E7%BA%BF%E7%A8%8B%E6%B1%A0%E8%BF%9B%E8%A1%8C%E5%88%9B%E5%BB%BA"><span class="toc-number">2.4.</span> <span class="toc-text">** 通过线程池进行创建**</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E7%BA%BF%E7%A8%8B%E6%B1%A0%EF%BC%9F%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E4%BD%BF%E7%94%A8%E7%BA%BF%E7%A8%8B%E6%B1%A0%EF%BC%9F"><span class="toc-number">3.</span> <span class="toc-text">什么是线程池？为什么要使用线程池？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ThreadPoolExecutor-%E9%83%BD%E6%9C%89%E5%93%AA%E4%BA%9B%E6%A0%B8%E5%BF%83%E5%8F%82%E6%95%B0%EF%BC%9F"><span class="toc-number">4.</span> <span class="toc-text">ThreadPoolExecutor 都有哪些核心参数？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E8%BF%90%E8%A1%8C%E5%8E%9F%E7%90%86%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">5.</span> <span class="toc-text">线程池的运行原理是什么？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E4%BC%98%E9%9B%85%E5%9C%B0%E5%85%B3%E9%97%AD%E7%BA%BF%E7%A8%8B%E6%B1%A0%EF%BC%9F"><span class="toc-number">6.</span> <span class="toc-text">如何优雅地关闭线程池？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%EF%BC%9F"><span class="toc-number">7.</span> <span class="toc-text">线程的生命周期？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95"><span class="toc-number">8.</span> <span class="toc-text">线程的常用方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#yield%E5%92%8Cjoin%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">9.</span> <span class="toc-text">yield和join的区别</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E4%BD%9C%E7%94%A8%E4%B8%8D%E5%90%8C"><span class="toc-number">9.1.</span> <span class="toc-text">1. 作用不同</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E9%98%BB%E5%A1%9E%E8%A1%8C%E4%B8%BA%E4%B8%8D%E5%90%8C"><span class="toc-number">9.2.</span> <span class="toc-text">2. 阻塞行为不同</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E5%AF%B9%E9%94%81%E7%9A%84%E5%BD%B1%E5%93%8D%E4%B8%8D%E5%90%8C"><span class="toc-number">9.3.</span> <span class="toc-text">3. 对锁的影响不同</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF%E4%B8%8D%E5%90%8C"><span class="toc-number">9.4.</span> <span class="toc-text">4. 使用场景不同</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#wait%E5%92%8Csleep%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">10.</span> <span class="toc-text">wait和sleep的区别</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E6%89%80%E5%B1%9E%E7%B1%BB%E4%B8%8D%E5%90%8C"><span class="toc-number">10.1.</span> <span class="toc-text">1. 所属类不同</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%AF%B9%E9%94%81%E7%9A%84%E5%A4%84%E7%90%86%E4%B8%8D%E5%90%8C%EF%BC%88%E6%9C%80%E6%A0%B8%E5%BF%83%E5%8C%BA%E5%88%AB%EF%BC%89"><span class="toc-number">10.2.</span> <span class="toc-text">2. 对锁的处理不同（最核心区别）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF%E4%B8%8D%E5%90%8C"><span class="toc-number">10.3.</span> <span class="toc-text">3. 使用场景不同</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E5%94%A4%E9%86%92%E6%96%B9%E5%BC%8F%E4%B8%8D%E5%90%8C"><span class="toc-number">10.4.</span> <span class="toc-text">4. 唤醒方式不同</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E9%94%81"><span class="toc-number">11.</span> <span class="toc-text">线程锁</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%94%81%E7%9A%84%E5%88%86%E7%B1%BB"><span class="toc-number">12.</span> <span class="toc-text">锁的分类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%A0%E7%9F%A5%E9%81%93Java%E4%B8%AD%E6%9C%89%E5%93%AA%E4%BA%9B%E9%94%81%E5%90%97%EF%BC%9F"><span class="toc-number">13.</span> <span class="toc-text">你知道Java中有哪些锁吗？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Synchronized-%E7%94%A8%E8%BF%87%E5%90%97%EF%BC%8C%E5%85%B6%E5%8E%9F%E7%90%86%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-number">14.</span> <span class="toc-text">Synchronized 用过吗，其原理是什么</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E9%94%81%E7%9A%84%E8%BD%BD%E4%BD%93%EF%BC%9A%E5%AF%B9%E8%B1%A1%E5%A4%B4%EF%BC%88Object-Header%EF%BC%89"><span class="toc-number">14.0.1.</span> <span class="toc-text">1. 锁的载体：对象头（Object Header）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E9%94%81%E7%9A%84%E5%8D%87%E7%BA%A7%EF%BC%9A%E4%BB%8E%E6%97%A0%E9%94%81%E5%88%B0%E9%87%8D%E9%87%8F%E7%BA%A7%E9%94%81"><span class="toc-number">14.0.2.</span> <span class="toc-text">2. 锁的升级：从无锁到重量级锁</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Lock-%E4%B8%8E-synchronized-%E7%9A%84%E5%AF%B9%E6%AF%94"><span class="toc-number">15.</span> <span class="toc-text">Lock 与 synchronized 的对比</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ReentrantLock-%E7%9A%84%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86"><span class="toc-number">16.</span> <span class="toc-text">ReentrantLock****的底层原理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-CAS-%E5%B0%9D%E8%AF%95%E5%8A%A0%E9%94%81"><span class="toc-number">16.0.1.</span> <span class="toc-text">1. CAS 尝试加锁</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E5%8F%AF%E9%87%8D%E5%85%A5%E6%80%A7"><span class="toc-number">16.0.2.</span> <span class="toc-text">2. 可重入性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E5%85%A5%E9%98%9F%E4%B8%8E%E9%98%BB%E5%A1%9E"><span class="toc-number">16.0.3.</span> <span class="toc-text">3. 入队与阻塞</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%AC%E5%B9%B3%E9%94%81%E4%B8%8E%E9%9D%9E%E5%85%AC%E5%B9%B3%E9%94%81"><span class="toc-number">16.1.</span> <span class="toc-text">公平锁与非公平锁</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A7%A3%E9%87%8A%E4%B8%80%E4%B8%8Bvolatile%E5%85%B3%E9%94%AE%E5%AD%97%E7%9A%84%E4%BD%9C%E7%94%A8%E5%92%8C%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF%E3%80%82"><span class="toc-number">17.</span> <span class="toc-text">解释一下volatile关键字的作用和使用场景。</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E3%80%81volatile-%E7%9A%84%E6%A0%B8%E5%BF%83%E4%BD%9C%E7%94%A8"><span class="toc-number">17.1.</span> <span class="toc-text">一、volatile 的核心作用</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E4%BF%9D%E8%AF%81%E5%8F%AF%E8%A7%81%E6%80%A7"><span class="toc-number">17.1.1.</span> <span class="toc-text">1. 保证可见性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E7%A6%81%E6%AD%A2%E6%8C%87%E4%BB%A4%E9%87%8D%E6%8E%92%E5%BA%8F"><span class="toc-number">17.1.2.</span> <span class="toc-text">2. 禁止指令重排序</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#volatile-%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">17.2.</span> <span class="toc-text">volatile 的实现原理是什么？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#volatile-%E4%B8%8E-synchronized-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">18.</span> <span class="toc-text">volatile 与 synchronized 的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ReentrantLock%E7%9A%84%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86"><span class="toc-number">19.</span> <span class="toc-text">ReentrantLock的底层原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%A6%82%E4%BD%95%E8%8E%B7%E5%8F%96%E5%BC%82%E6%AD%A5%E6%89%A7%E8%A1%8C%E7%BB%93%E6%9E%9C"><span class="toc-number">20.</span> <span class="toc-text">多线程如何获取异步执行结果</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%881%EF%BC%89Future-Callable%EF%BC%88%E6%9C%80%E5%B8%B8%E7%94%A8%EF%BC%89"><span class="toc-number">20.0.1.</span> <span class="toc-text">（1）Future + Callable（最常用）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%882%EF%BC%89CompletableFuture%EF%BC%88Java-8-%EF%BC%8C%E9%9D%9E%E9%98%BB%E5%A1%9E%E5%BC%8F%EF%BC%89"><span class="toc-number">20.0.2.</span> <span class="toc-text">（2）CompletableFuture（Java 8+，非阻塞式）</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E7%BA%BF%E7%A8%8B%E6%AD%BB%E9%94%81%EF%BC%9F%E6%AD%BB%E9%94%81%E5%A6%82%E4%BD%95%E4%BA%A7%E7%94%9F%EF%BC%9F"><span class="toc-number">21.</span> <span class="toc-text">什么是线程死锁？死锁如何产生？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ThreadLocal-%E5%8E%9F%E7%90%86%EF%BC%9F%E5%BA%95%E5%B1%82%E5%A6%82%E4%BD%95%E9%98%B2%E6%AD%A2%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%EF%BC%9F"><span class="toc-number">22.</span> <span class="toc-text">ThreadLocal 原理？底层如何防止内存泄漏？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%EF%BC%9F%E6%80%8E%E4%B9%88%E4%BF%9D%E8%AF%81%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%EF%BC%9F"><span class="toc-number">23.</span> <span class="toc-text">什么是线程安全？怎么保证线程安全？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%EF%BC%88%E4%BB%8E%E6%80%9D%E6%83%B3%E5%88%B0%E5%AE%9E%E7%8E%B0%EF%BC%89"><span class="toc-number">23.1.</span> <span class="toc-text">如何保证线程安全（从思想到实现）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%8D%E5%85%B1%E4%BA%AB%EF%BC%88%E7%BA%BF%E7%A8%8B%E5%B0%81%E9%97%AD-Thread-Confinement%EF%BC%89"><span class="toc-number">23.1.1.</span> <span class="toc-text">不共享（线程封闭 Thread Confinement）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%8D%E5%8F%AF%E5%8F%98%EF%BC%88Immutable%EF%BC%89%E5%AF%B9%E8%B1%A1"><span class="toc-number">23.1.2.</span> <span class="toc-text">不可变（Immutable）对象</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%92%E6%96%A5%E9%94%81%EF%BC%88Synchronized-Lock%EF%BC%89"><span class="toc-number">23.1.3.</span> <span class="toc-text">互斥锁（Synchronized &#x2F; Lock）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8E%9F%E5%AD%90%E7%B1%BB%EF%BC%88CAS-volatile-%E5%AE%9E%E7%8E%B0%E6%97%A0%E9%94%81%E5%B9%B6%E5%8F%91%EF%BC%89"><span class="toc-number">23.1.4.</span> <span class="toc-text">原子类（CAS + volatile 实现无锁并发）</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E2%80%9C%E5%8F%AF%E8%A7%81%E6%80%A7%E2%80%9D%E3%80%81%E2%80%9C%E5%8E%9F%E5%AD%90%E6%80%A7%E2%80%9D%E3%80%81%E2%80%9C%E6%9C%89%E5%BA%8F%E6%80%A7%E2%80%9D%EF%BC%9F"><span class="toc-number">24.</span> <span class="toc-text">什么是“可见性”、“原子性”、“有序性”？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%AF%E8%A7%81%E6%80%A7%EF%BC%88Visibility%EF%BC%89"><span class="toc-number">24.1.</span> <span class="toc-text">可见性（Visibility）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8E%9F%E5%AD%90%E6%80%A7%EF%BC%88Atomicity%EF%BC%89"><span class="toc-number">24.2.</span> <span class="toc-text">原子性（Atomicity）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%89%E5%BA%8F%E6%80%A7%EF%BC%88Ordering%EF%BC%89"><span class="toc-number">24.3.</span> <span class="toc-text">有序性（Ordering）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#AQS"><span class="toc-number">25.</span> <span class="toc-text">AQS</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#AQS-%E7%9A%84%E4%B8%A4%E7%A7%8D%E6%A8%A1%E5%BC%8F"><span class="toc-number">25.1.</span> <span class="toc-text">AQS 的两种模式</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#CAS"><span class="toc-number">26.</span> <span class="toc-text">CAS</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#CAS-%E7%9A%84%E4%BC%98%E7%82%B9"><span class="toc-number">26.1.</span> <span class="toc-text">CAS 的优点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CAS-%E7%9A%84%E9%97%AE%E9%A2%98%EF%BC%88%E9%9D%A2%E8%AF%95%E9%AB%98%E9%A2%91%EF%BC%89"><span class="toc-number">26.2.</span> <span class="toc-text">CAS 的问题（面试高频）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-ABA-%E9%97%AE%E9%A2%98"><span class="toc-number">26.2.1.</span> <span class="toc-text">1. ABA 问题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E8%87%AA%E6%97%8B%E5%BC%80%E9%94%80%E5%A4%A7"><span class="toc-number">26.2.2.</span> <span class="toc-text">2. 自旋开销大</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E5%8F%AA%E8%83%BD%E4%BF%9D%E8%AF%81%E5%8D%95%E4%B8%AA%E5%8F%98%E9%87%8F%E7%9A%84%E5%8E%9F%E5%AD%90%E6%80%A7"><span class="toc-number">26.2.3.</span> <span class="toc-text">3. 只能保证单个变量的原子性</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-history"></i><span>最近发布</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/posts/c45230cb.html" title="mysql面试题"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://s2.loli.net/2025/10/23/w3ErpsQhncfDed2.jpg?_r_=7a487ade-a613-3f8f-d549-a793e3c2aa17" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="mysql面试题"/></a><div class="content"><a class="title" href="/posts/c45230cb.html" title="mysql面试题">mysql面试题</a><time datetime="2025-10-27T03:31:36.000Z" title="发表于 2025-10-27 11:31:36">2025-10-27</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/66c016fb.html" title="JVM"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://s2.loli.net/2025/10/23/w3ErpsQhncfDed2.jpg?_r_=073fb3c1-1ed6-85dc-4b49-6bade417019f" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="JVM"/></a><div class="content"><a class="title" href="/posts/66c016fb.html" title="JVM">JVM</a><time datetime="2025-10-24T15:31:36.000Z" title="发表于 2025-10-24 23:31:36">2025-10-24</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/498cfd8e.html" title="并发编程"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://s2.loli.net/2025/10/23/w3ErpsQhncfDed2.jpg?_r_=e93610d2-afe5-62c9-ffac-34bc6ede57ce" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="并发编程"/></a><div class="content"><a class="title" href="/posts/498cfd8e.html" title="并发编程">并发编程</a><time datetime="2025-10-23T15:51:36.000Z" title="发表于 2025-10-23 23:51:36">2025-10-23</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/7edb9ee1.html" title="集合框架"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://s2.loli.net/2025/10/23/g4UkwyDri9BWZtE.jpg?_r_=15bc3fef-3044-c8b4-4d1c-cc585f957842" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="集合框架"/></a><div class="content"><a class="title" href="/posts/7edb9ee1.html" title="集合框架">集合框架</a><time datetime="2025-10-23T08:48:49.330Z" title="发表于 2025-10-23 16:48:49">2025-10-23</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/aff6963e.html" title="如何解决高并发下的库存抢购超卖少买问题？"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://s2.loli.net/2025/10/23/YUHOf5MZEItlGd3.jpg?_r_=1d335fd2-520a-5de8-b607-f2b3e5a780fa" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="如何解决高并发下的库存抢购超卖少买问题？"/></a><div class="content"><a class="title" href="/posts/aff6963e.html" title="如何解决高并发下的库存抢购超卖少买问题？">如何解决高并发下的库存抢购超卖少买问题？</a><time datetime="2025-10-23T04:24:36.000Z" title="发表于 2025-10-23 12:24:36">2025-10-23</time></div></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div id="workboard"><img class="workSituationImg boardsign" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://npm.elemecdn.com/anzhiyu-blog@2.0.4/img/badge/安知鱼-上班摸鱼中.svg" alt="距离月入25k也就还差一个大佬带我~" title="距离月入25k也就还差一个大佬带我~"/><div id="runtimeTextTip"></div></div><p id="ghbdages"><a class="github-badge" target="_blank" href="https://hexo.io/" style="margin-inline:5px" data-title="博客框架为Hexo_v5.4.0" title="博客框架为Hexo_v5.4.0"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://npm.elemecdn.com/anzhiyu-blog@2.1.5/img/badge/Frame-Hexo.svg" alt="博客框架为Hexo_v5.4.0"/></a><a class="github-badge" target="_blank" href="https://blog.anheyu.com/" style="margin-inline:5px" data-title="本站使用AnZhiYu主题" title="本站使用AnZhiYu主题"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://npm.elemecdn.com/anzhiyu-theme-static@1.0.9/img/Theme-AnZhiYu-2E67D3.svg" alt="本站使用AnZhiYu主题"/></a><a class="github-badge" target="_blank" href="https://www.dogecloud.com/" style="margin-inline:5px" data-title="本站使用多吉云为静态资源提供CDN加速" title="本站使用多吉云为静态资源提供CDN加速"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://npm.elemecdn.com/anzhiyu-blog@2.2.0/img/badge/CDN-多吉云-3693F3.svg" alt="本站使用多吉云为静态资源提供CDN加速"/></a><a class="github-badge" target="_blank" href="https://github.com/" style="margin-inline:5px" data-title="本站项目由Github托管" title="本站项目由Github托管"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://npm.elemecdn.com/anzhiyu-blog@2.1.5/img/badge/Source-Github.svg" alt="本站项目由Github托管"/></a><a class="github-badge" target="_blank" href="http://creativecommons.org/licenses/by-nc-sa/4.0/" style="margin-inline:5px" data-title="本站采用知识共享署名-非商业性使用-相同方式共享4.0国际许可协议进行许可" title="本站采用知识共享署名-非商业性使用-相同方式共享4.0国际许可协议进行许可"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://npm.elemecdn.com/anzhiyu-blog@2.2.0/img/badge/Copyright-BY-NC-SA.svg" alt="本站采用知识共享署名-非商业性使用-相同方式共享4.0国际许可协议进行许可"/></a></p></div><div id="footer-bar"><div class="footer-bar-links"><div class="footer-bar-left"><div id="footer-bar-tips"><div class="copyright">&copy;2020 - 2025 By <a class="footer-bar-link" href="/" title="Wsk" target="_blank">Wsk</a></div></div><div id="footer-type-tips"></div></div><div class="footer-bar-right"><a class="footer-bar-link" target="_blank" rel="noopener" href="https://github.com/anzhiyu-c/hexo-theme-anzhiyu" title="主题">主题</a></div></div></div></footer></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="sidebar-site-data site-data is-center"><a href="/archives/" title="archive"><div class="headline">文章</div><div class="length-num">16</div></a><a href="/tags/" title="tag"><div class="headline">标签</div><div class="length-num">18</div></a><a href="/categories/" title="category"><div class="headline">分类</div><div class="length-num">5</div></a></div><span class="sidebar-menu-item-title">功能</span><div class="sidebar-menu-item"><a class="darkmode_switchbutton menu-child" href="javascript:void(0);" title="显示模式"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i><span>显示模式</span></a></div><div class="back-menu-list-groups"><div class="back-menu-list-group"><div class="back-menu-list-title">网页</div><div class="back-menu-list"><a class="back-menu-item" target="_blank" rel="noopener" href="https://blog.anheyu.com/" title="博客"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/favicon.png" alt="博客"/><span class="back-menu-item-text">博客</span></a></div></div></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 文章</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/archives/"><i class="anzhiyufont anzhiyu-icon-box-archive faa-tada" style="font-size: 0.9em;"></i><span> 隧道</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/categories/"><i class="anzhiyufont anzhiyu-icon-shapes faa-tada" style="font-size: 0.9em;"></i><span> 分类</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/tags/"><i class="anzhiyufont anzhiyu-icon-tags faa-tada" style="font-size: 0.9em;"></i><span> 标签</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 友链</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/link/"><i class="anzhiyufont anzhiyu-icon-link faa-tada" style="font-size: 0.9em;"></i><span> 友人帐</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/fcircle/"><i class="anzhiyufont anzhiyu-icon-artstation faa-tada" style="font-size: 0.9em;"></i><span> 朋友圈</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/comments/"><i class="anzhiyufont anzhiyu-icon-envelope faa-tada" style="font-size: 0.9em;"></i><span> 留言板</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 我的</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/music/?id=2898229193&amp;server=netease"><i class="anzhiyufont anzhiyu-icon-music faa-tada" style="font-size: 0.9em;"></i><span> 音乐馆</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/album/"><i class="anzhiyufont anzhiyu-icon-images faa-tada" style="font-size: 0.9em;"></i><span> 相册集</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/air-conditioner/"><i class="anzhiyufont anzhiyu-icon-fan faa-tada" style="font-size: 0.9em;"></i><span> 小空调</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 关于</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/about/"><i class="anzhiyufont anzhiyu-icon-paper-plane faa-tada" style="font-size: 0.9em;"></i><span> 关于本人</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/essay/"><i class="anzhiyufont anzhiyu-icon-lightbulb faa-tada" style="font-size: 0.9em;"></i><span> 闲言碎语</span></a></li></ul></div></div><span class="sidebar-menu-item-title">标签</span><div class="card-tags"><div class="item-headline"></div><div class="card-tag-cloud"><a href="/tags/JVM%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/" style="font-size: 0.88rem;">JVM内存模型<sup>1</sup></a><a href="/tags/JVM%E8%B0%83%E4%BC%98/" style="font-size: 0.88rem;">JVM调优<sup>1</sup></a><a href="/tags/java%E6%95%99%E7%A8%8B/" style="font-size: 0.88rem;">java教程<sup>1</sup></a><a href="/tags/mysql/" style="font-size: 0.88rem;">mysql<sup>1</sup></a><a href="/tags/%E5%87%BD%E6%95%B0/" style="font-size: 0.88rem;">函数<sup>1</sup></a><a href="/tags/%E5%8F%8D%E5%B0%84/" style="font-size: 0.88rem;">反射<sup>1</sup></a><a href="/tags/%E5%A4%8D%E4%B9%A0/" style="font-size: 0.88rem;">复习<sup>1</sup></a><a href="/tags/%E5%A4%8D%E4%B9%A0-%E5%8F%98%E9%87%8F/" style="font-size: 0.88rem;">复习 变量<sup>1</sup></a><a href="/tags/%E5%B7%A5%E5%85%B7/" style="font-size: 0.88rem;">工具<sup>1</sup></a><a href="/tags/%E5%B9%B6%E5%8F%91/" style="font-size: 0.88rem;">并发<sup>1</sup></a><a href="/tags/%E6%83%85%E6%84%9F/" style="font-size: 0.88rem;">情感<sup>1</sup></a><a href="/tags/%E6%8A%BD%E8%B1%A1%E7%B1%BB-%E6%8E%A5%E5%8F%A3/" style="font-size: 0.88rem;">抽象类 接口<sup>1</sup></a><a href="/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/" style="font-size: 0.88rem;">数据库<sup>1</sup></a><a href="/tags/%E6%AF%8F%E6%97%A5%E9%9D%A2%E8%AF%95/" style="font-size: 0.88rem;">每日面试<sup>2</sup></a><a href="/tags/%E7%94%B5%E5%95%86-%E8%AE%A2%E5%8D%95/" style="font-size: 0.88rem;">电商,订单<sup>1</sup></a><a href="/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" style="font-size: 0.88rem;">设计模式<sup>1</sup></a><a href="/tags/%E8%B6%85%E5%8D%96-%E5%BA%93%E5%AD%98/" style="font-size: 0.88rem;">超卖 , 库存<sup>1</sup></a><a href="/tags/%E9%9B%86%E5%90%88/" style="font-size: 0.88rem;">集合<sup>1</sup></a></div></div><hr/></div></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="anzhiyufont anzhiyu-icon-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">简</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="anzhiyufont anzhiyu-icon-arrows-left-right"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="anzhiyufont anzhiyu-icon-gear"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="anzhiyufont anzhiyu-icon-list-ul"></i></button><button id="chat-btn" type="button" title="聊天"><i class="anzhiyufont anzhiyu-icon-comment-sms"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="anzhiyufont anzhiyu-icon-comments"></i></a><a id="switch-commentBarrage" href="javascript:anzhiyu.switchCommentBarrage();" title="开关弹幕"><i class="anzhiyufont anzhiyu-icon-danmu"></i></a><button id="go-up" type="button" title="回到顶部"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></button></div></div><div id="nav-music"><a id="nav-music-hoverTips" onclick="anzhiyu.musicToggle()" accesskey="m">播放音乐</a><div id="console-music-bg"></div><meting-js id="8152976493" server="netease" type="playlist" mutex="true" preload="none" theme="var(--anzhiyu-main)" data-lrctype="0" order="random"></meting-js></div><div id="rightMenu"><div class="rightMenu-group rightMenu-small"><div class="rightMenu-item" id="menu-backward"><i class="anzhiyufont anzhiyu-icon-arrow-left"></i></div><div class="rightMenu-item" id="menu-forward"><i class="anzhiyufont anzhiyu-icon-arrow-right"></i></div><div class="rightMenu-item" id="menu-refresh"><i class="anzhiyufont anzhiyu-icon-arrow-rotate-right" style="font-size: 1rem;"></i></div><div class="rightMenu-item" id="menu-top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></div></div><div class="rightMenu-group rightMenu-line rightMenuPlugin"><div class="rightMenu-item" id="menu-copytext"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制选中文本</span></div><div class="rightMenu-item" id="menu-pastetext"><i class="anzhiyufont anzhiyu-icon-paste"></i><span>粘贴文本</span></div><a class="rightMenu-item" id="menu-commenttext"><i class="anzhiyufont anzhiyu-icon-comment-medical"></i><span>引用到评论</span></a><div class="rightMenu-item" id="menu-newwindow"><i class="anzhiyufont anzhiyu-icon-window-restore"></i><span>新窗口打开</span></div><div class="rightMenu-item" id="menu-copylink"><i class="anzhiyufont anzhiyu-icon-link"></i><span>复制链接地址</span></div><div class="rightMenu-item" id="menu-copyimg"><i class="anzhiyufont anzhiyu-icon-images"></i><span>复制此图片</span></div><div class="rightMenu-item" id="menu-downloadimg"><i class="anzhiyufont anzhiyu-icon-download"></i><span>下载此图片</span></div><div class="rightMenu-item" id="menu-newwindowimg"><i class="anzhiyufont anzhiyu-icon-window-restore"></i><span>新窗口打开图片</span></div><div class="rightMenu-item" id="menu-search"><i class="anzhiyufont anzhiyu-icon-magnifying-glass"></i><span>站内搜索</span></div><div class="rightMenu-item" id="menu-searchBaidu"><i class="anzhiyufont anzhiyu-icon-magnifying-glass"></i><span>百度搜索</span></div><div class="rightMenu-item" id="menu-music-toggle"><i class="anzhiyufont anzhiyu-icon-play"></i><span>播放音乐</span></div><div class="rightMenu-item" id="menu-music-back"><i class="anzhiyufont anzhiyu-icon-backward"></i><span>切换到上一首</span></div><div class="rightMenu-item" id="menu-music-forward"><i class="anzhiyufont anzhiyu-icon-forward"></i><span>切换到下一首</span></div><div class="rightMenu-item" id="menu-music-playlist" onclick="window.open(&quot;https://y.qq.com/n/ryqq/playlist/8152976493&quot;, &quot;_blank&quot;);" style="display: none;"><i class="anzhiyufont anzhiyu-icon-radio"></i><span>查看所有歌曲</span></div><div class="rightMenu-item" id="menu-music-copyMusicName"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制歌名</span></div></div><div class="rightMenu-group rightMenu-line rightMenuOther"><a class="rightMenu-item menu-link" id="menu-randomPost"><i class="anzhiyufont anzhiyu-icon-shuffle"></i><span>随便逛逛</span></a><a class="rightMenu-item menu-link" href="/categories/"><i class="anzhiyufont anzhiyu-icon-cube"></i><span>博客分类</span></a><a class="rightMenu-item menu-link" href="/tags/"><i class="anzhiyufont anzhiyu-icon-tags"></i><span>文章标签</span></a></div><div class="rightMenu-group rightMenu-line rightMenuOther"><a class="rightMenu-item" id="menu-copy" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制地址</span></a><a class="rightMenu-item" id="menu-commentBarrage" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-message"></i><span class="menu-commentBarrage-text">关闭热评</span></a><a class="rightMenu-item" id="menu-darkmode" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i><span class="menu-darkmode-text">深色模式</span></a><a class="rightMenu-item" id="menu-translate" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-language"></i><span>轉為繁體</span></a></div></div><div id="rightmenu-mask"></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.cbd.int/@fancyapps/ui@5.0.20/dist/fancybox/fancybox.umd.js"></script><script src="https://cdn.cbd.int/instant.page@5.2.0/instantpage.js" type="module"></script><script src="https://cdn.cbd.int/vanilla-lazyload@17.8.4/dist/lazyload.iife.min.js"></script><script src="https://cdn.cbd.int/node-snackbar@0.1.16/dist/snackbar.min.js"></script><canvas id="universe"></canvas><script async src="https://npm.elemecdn.com/anzhiyu-theme-static@1.0.0/dark/dark.js"></script><script>// 消除控制台打印
var HoldLog = console.log;
console.log = function () {};
let now1 = new Date();
queueMicrotask(() => {
  const Log = function () {
    HoldLog.apply(console, arguments);
  }; //在恢复前输出日志
  const grt = new Date("04/01/2023 00:00:00"); //此处修改你的建站时间或者网站上线时间
  now1.setTime(now1.getTime() + 250);
  const days = (now1 - grt) / 1000 / 60 / 60 / 24;
  const dnum = Math.floor(days);
  const ascll = [
    `欢迎使用安知鱼!`,
    `生活明朗, 万物可爱`,
    `
        
       █████╗ ███╗   ██╗███████╗██╗  ██╗██╗██╗   ██╗██╗   ██╗
      ██╔══██╗████╗  ██║╚══███╔╝██║  ██║██║╚██╗ ██╔╝██║   ██║
      ███████║██╔██╗ ██║  ███╔╝ ███████║██║ ╚████╔╝ ██║   ██║
      ██╔══██║██║╚██╗██║ ███╔╝  ██╔══██║██║  ╚██╔╝  ██║   ██║
      ██║  ██║██║ ╚████║███████╗██║  ██║██║   ██║   ╚██████╔╝
      ╚═╝  ╚═╝╚═╝  ╚═══╝╚══════╝╚═╝  ╚═╝╚═╝   ╚═╝    ╚═════╝
        
        `,
    "已上线",
    dnum,
    "天",
    "©2020 By 安知鱼 V1.6.8",
  ];
  const ascll2 = [`NCC2-036`, `调用前置摄像头拍照成功，识别为【小笨蛋】.`, `Photo captured: `, `🤪`];

  setTimeout(
    Log.bind(
      console,
      `\n%c${ascll[0]} %c ${ascll[1]} %c ${ascll[2]} %c${ascll[3]}%c ${ascll[4]}%c ${ascll[5]}\n\n%c ${ascll[6]}\n`,
      "color:#425AEF",
      "",
      "color:#425AEF",
      "color:#425AEF",
      "",
      "color:#425AEF",
      ""
    )
  );
  setTimeout(
    Log.bind(
      console,
      `%c ${ascll2[0]} %c ${ascll2[1]} %c \n${ascll2[2]} %c\n${ascll2[3]}\n`,
      "color:white; background-color:#4fd953",
      "",
      "",
      'background:url("https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/tinggge.gif") no-repeat;font-size:450%'
    )
  );

  setTimeout(Log.bind(console, "%c WELCOME %c 你好，小笨蛋.", "color:white; background-color:#4f90d9", ""));

  setTimeout(
    console.warn.bind(
      console,
      "%c ⚡ Powered by 安知鱼 %c 你正在访问 Wsk 的博客.",
      "color:white; background-color:#f0ad4e",
      ""
    )
  );

  setTimeout(Log.bind(console, "%c W23-12 %c 你已打开控制台.", "color:white; background-color:#4f90d9", ""));

  setTimeout(
    console.warn.bind(console, "%c S013-782 %c 你现在正处于监控中.", "color:white; background-color:#d9534f", "")
  );
});</script><script async src="/anzhiyu/random.js"></script><script async="async">(function () {
  var grt = new Date("04/01/2023 00:00:00"); //设置网站上线时间
  var now = new Date();
  var dnum;
  var hnum;
  var mnum;
  var snum;
  var nowHour;

  // 计算并更新天数、小时数、分钟数和秒数
  function updateTime() {
    now = new Date(); // 更新 now 的值
    nowHour = now.getHours(); // 更新 nowHour 的值
    var days = (now - grt) / 1000 / 60 / 60 / 24;
    dnum = Math.floor(days);
    var hours = (now - grt) / 1000 / 60 / 60 - 24 * dnum;
    hnum = Math.floor(hours);
    if (String(hnum).length == 1) {
      hnum = "0" + hnum;
    }
    var minutes = (now - grt) / 1000 / 60 - 24 * 60 * dnum - 60 * hnum;
    mnum = Math.floor(minutes);
    if (String(mnum).length == 1) {
      mnum = "0" + mnum;
    }
    var seconds = (now - grt) / 1000 - 24 * 60 * 60 * dnum - 60 * 60 * hnum - 60 * mnum;
    snum = Math.round(seconds);
    if (String(snum).length == 1) {
      snum = "0" + snum;
    }
  }

  // 更新网页中显示的网站运行时间
  function updateHtml() {
    const footer = document.getElementById("footer");
    if (!footer) return
    let currentTimeHtml = "";
    if (nowHour < 18 && nowHour >= 9) {
      // 如果是上班时间，默认就是"安知鱼-上班摸鱼中.svg"图片，不需要更改
      currentTimeHtml = `本站居然运行了 ${dnum} 天<span id='runtime'> ${hnum} 小时 ${mnum} 分 ${snum} 秒 </span><i class='anzhiyufont anzhiyu-icon-heartbeat' style='color:red'></i>`;
    } else {
      // 如果是下班时间，插入"安知鱼-下班啦.svg"图片
      let img = document.querySelector("#workboard .workSituationImg");
      img.src = "";
      img.title = "";
      img.alt = "";

      currentTimeHtml = `本站居然运行了 ${dnum} 天<span id='runtime'> ${hnum} 小时 ${mnum} 分 ${snum} 秒 </span><i class='anzhiyufont anzhiyu-icon-heartbeat' style='color:red'></i>`;
    }

    if (document.getElementById("runtimeTextTip")) {
      document.getElementById("runtimeTextTip").innerHTML = currentTimeHtml;
    }
  }

  setInterval(() => {
    updateTime();
    updateHtml();
  }, 1000);
})();</script><div class="js-pjax"><script>(() => {
  const initValine = () => {
    const valine = new Valine(Object.assign({
      el: '#vcomment',
      appId: '4GK2IcRZ0PX28gP4kGsW08qs-gzGzoHsz',
      appKey: 'TjKeHNK7GJrGTYuKYzGzh8yg',
      avatar: 'mp',
      serverURLs: '',
      emojiMaps: {"tv_doge":"6ea59c827c414b4a2955fe79e0f6fd3dcd515e24.png","tv_亲亲":"a8111ad55953ef5e3be3327ef94eb4a39d535d06.png","tv_偷笑":"bb690d4107620f1c15cff29509db529a73aee261.png","tv_再见":"180129b8ea851044ce71caf55cc8ce44bd4a4fc8.png","tv_冷漠":"b9cbc755c2b3ee43be07ca13de84e5b699a3f101.png","tv_发怒":"34ba3cd204d5b05fec70ce08fa9fa0dd612409ff.png","tv_发财":"34db290afd2963723c6eb3c4560667db7253a21a.png","tv_可爱":"9e55fd9b500ac4b96613539f1ce2f9499e314ed9.png","tv_吐血":"09dd16a7aa59b77baa1155d47484409624470c77.png","tv_呆":"fe1179ebaa191569b0d31cecafe7a2cd1c951c9d.png","tv_呕吐":"9f996894a39e282ccf5e66856af49483f81870f3.png","tv_困":"241ee304e44c0af029adceb294399391e4737ef2.png","tv_坏笑":"1f0b87f731a671079842116e0991c91c2c88645a.png","tv_大佬":"093c1e2c490161aca397afc45573c877cdead616.png","tv_大哭":"23269aeb35f99daee28dda129676f6e9ea87934f.png","tv_委屈":"d04dba7b5465779e9755d2ab6f0a897b9b33bb77.png","tv_害羞":"a37683fb5642fa3ddfc7f4e5525fd13e42a2bdb1.png","tv_尴尬":"7cfa62dafc59798a3d3fb262d421eeeff166cfa4.png","tv_微笑":"70dc5c7b56f93eb61bddba11e28fb1d18fddcd4c.png","tv_思考":"90cf159733e558137ed20aa04d09964436f618a1.png","tv_惊吓":"0d15c7e2ee58e935adc6a7193ee042388adc22af.png"},
      path: window.location.pathname,
      visitor: false
    }, null))
  }

  const loadValine = async () => {
    if (typeof Valine === 'function') initValine()
    else {
      await getScript('https://cdn.cbd.int/valine@1.5.1/dist/Valine.min.js')
      initValine()
    }
  }

  if ('Valine' === 'Valine' || !false) {
    if (false) anzhiyu.loadComment(document.getElementById('vcomment'),loadValine)
    else setTimeout(loadValine, 0)
  } else {
    window.loadOtherComment = loadValine
  }
})()</script><input type="hidden" name="page-type" id="page-type" value="post"></div><script src="https://cdn.cbd.int/blueimp-md5@2.19.0/js/md5.min.js"></script><script>window.addEventListener('load', () => {
  const changeContent = (content) => {
    if (content === '') return content

    content = content.replace(/<img.*?src="(.*?)"?[^\>]+>/ig, '[图片]') // replace image link
    content = content.replace(/<a[^>]+?href=["']?([^"']+)["']?[^>]*>([^<]+)<\/a>/gi, '[链接]') // replace url
    content = content.replace(/<pre><code>.*?<\/pre>/gi, '[代码]') // replace code
    content = content.replace(/<[^>]+>/g,"") // remove html tag

    if (content.length > 150) {
      content = content.substring(0,150) + '...'
    }
    return content
  }

  const getIcon = (icon, mail) => {
    if (icon) return icon
    let defaultIcon = '?d=mp'
    let iconUrl = `https://gravatar.loli.net/avatar/${md5(mail.toLowerCase()) + defaultIcon}`
    return iconUrl
  }

  const generateHtml = array => {
    let result = ''

    if (array.length) {
      for (let i = 0; i < array.length; i++) {
        result += '<div class=\'aside-list-item\'>'

        if (true) {
          const name = 'data-lazy-src'
          result += `<a href='${array[i].url}' class='thumbnail'><img ${name}='${array[i].avatar}' alt='${array[i].nick}'></a>`
        }

        result += `<div class='content'>
        <a class='comment' href='${array[i].url}' title='${array[i].content}'>${array[i].content}</a>
        <div class='name'><span>${array[i].nick} / </span><time datetime="${array[i].date}">${anzhiyu.diffDate(array[i].date, true)}</time></div>
        </div></div>`
      }
    } else {
      result += '没有评论'
    }

    let $dom = document.querySelector('#card-newest-comments .aside-list')
    $dom.innerHTML= result
    window.lazyLoadInstance && window.lazyLoadInstance.update()
    window.pjax && window.pjax.refresh($dom)
  }

  const getComment = () => {
    const serverURL = 'https://4GK2IcRZ.api.lncldglobal.com'

    var settings = {
      "method": "GET",
      "headers": {
        "X-LC-Id": '4GK2IcRZ0PX28gP4kGsW08qs-gzGzoHsz',
        "X-LC-Key": 'TjKeHNK7GJrGTYuKYzGzh8yg',
        "Content-Type": "application/json"
      },
    }

    fetch(`${serverURL}/1.1/classes/Comment?limit=6&order=-createdAt`,settings)
      .then(response => response.json())
      .then(data => {
        const valineArray = data.results.map(function (e) {
          return {
            'avatar': getIcon(e.QQAvatar, e.mail),
            'content': changeContent(e.comment),
            'nick': e.nick,
            'url': e.url + '#' + e.objectId,
            'date': e.updatedAt,
          }
        })
        saveToLocal.set('valine-newest-comments', JSON.stringify(valineArray), 10/(60*24))
        generateHtml(valineArray)
      }).catch(e => {
        const $dom = document.querySelector('#card-newest-comments .aside-list')
        $dom.textContent= "无法获取评论，请确认相关配置是否正确"
      }) 
  }

  const newestCommentInit = () => {
    if (document.querySelector('#card-newest-comments .aside-list')) {
      const data = saveToLocal.get('valine-newest-comments')
      if (data) {
        generateHtml(JSON.parse(data))
      } else {
        getComment()
      }
    }
  }

  newestCommentInit()
  document.addEventListener('pjax:complete', newestCommentInit)
})</script><script>var visitorMail = "visitor@anheyu.com";
</script><script async data-pjax src="https://cdn.cbd.int/anzhiyu-theme-static@1.0.0/waterfall/waterfall.js"></script><script src="https://lf3-cdn-tos.bytecdntp.com/cdn/expire-1-M/qrcodejs/1.0.0/qrcode.min.js"></script><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.1.9/icon/ali_iconfont_css.css"><script src="//code.tidio.co/4nifo6zdbrmyjsngh2yzxwbnlhrvshrf.js" async="async"></script><script>(() => {
  const isChatBtn = true
  const isChatHideShow = true

  if (isChatBtn) {
    let isShow = false
    const close = () => {
      window.tidioChatApi.hide()
      isShow = false
    }
    
    const open = () => {
      window.tidioChatApi.open()
      window.tidioChatApi.show()
      isShow = true
    }

    const onTidioChatApiReady = () => {
      window.tidioChatApi.hide()
      window.tidioChatApi.on("close", close)
    }
    if (window.tidioChatApi) {
      window.tidioChatApi.on("ready", onTidioChatApiReady)
    } else {
      document.addEventListener("tidioChat-ready", onTidioChatApiReady)
    }

    window.chatBtnFn = () => {
      if (!window.tidioChatApi) return
      isShow ? close() : open()
    }
  } else if (isChatHideShow) {
    window.chatBtn = {
      hide: () => {
        window.tidioChatApi && window.tidioChatApi.hide()
      },
      show: () => {
        window.tidioChatApi && window.tidioChatApi.show()
      }
    }
  }
})()</script><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.0.0/aplayer/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.cbd.int/anzhiyu-blog-static@1.0.1/js/APlayer.min.js"></script><script src="https://cdn.cbd.int/hexo-anzhiyu-music@1.0.1/assets/js/Meting2.min.js"></script><script src="https://cdn.cbd.int/pjax@0.2.8/pjax.min.js"></script><script>let pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]
var pjax = new Pjax({
  elements: 'a:not([target="_blank"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {
  // removeEventListener scroll 
  anzhiyu.removeGlobalFnEvent('pjax')
  anzhiyu.removeGlobalFnEvent('themeChange')

  document.getElementById('rightside').classList.remove('rightside-show')
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')
})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()
})

document.addEventListener('pjax:error', e => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script charset="UTF-8" src="https://cdn.cbd.int/anzhiyu-theme-static@1.1.5/accesskey/accesskey.js"></script></div><div id="popup-window"><div class="popup-window-title">通知</div><div class="popup-window-divider"></div><div class="popup-window-content"><div class="popup-tip">你好呀</div><div class="popup-link"><i class="anzhiyufont anzhiyu-icon-arrow-circle-right"></i></div></div></div></body></html>