<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no"><title>Spring | Wsk Blog</title><meta name="keywords" content="IOC,AOP"><meta name="author" content="Wsk,2047891093@qq.com"><meta name="copyright" content="Wsk"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#f7f9fe"><meta name="mobile-web-app-capable" content="yes"><meta name="apple-touch-fullscreen" content="yes"><meta name="apple-mobile-web-app-title" content="Spring"><meta name="application-name" content="Spring"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="#f7f9fe"><meta property="og:type" content="article"><meta property="og:title" content="Spring"><meta property="og:url" content="https://wsk0404.github.io/posts/6c92115f.html"><meta property="og:site_name" content="Wsk Blog"><meta property="og:description" content="🎯 面试题：聊聊你对 Spring 框架的理解 一、面试官考察点 是否理解 Spring 的核心思想与设计模式； 是否熟悉 IOC（控制反转）与 AOP（面向切面编程） 原理； 是否了解 Spring 的核心模块； 是否能结合项目场景（如 WMS 系统）说明 Spring 的使用价值； 是否能提到"><meta property="og:locale" content="zh-CN"><meta property="og:image" content="https://s2.loli.net/2025/10/23/g4UkwyDri9BWZtE.jpg?_r_=95828ad5-7d6d-d56f-f27a-6610327ee6f0"><meta property="article:author" content="Wsk"><meta property="article:tag" content="博客,笔记,学习"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://s2.loli.net/2025/10/23/g4UkwyDri9BWZtE.jpg?_r_=95828ad5-7d6d-d56f-f27a-6610327ee6f0"><meta name="description" content="🎯 面试题：聊聊你对 Spring 框架的理解 一、面试官考察点 是否理解 Spring 的核心思想与设计模式； 是否熟悉 IOC（控制反转）与 AOP（面向切面编程） 原理； 是否了解 Spring 的核心模块； 是否能结合项目场景（如 WMS 系统）说明 Spring 的使用价值； 是否能提到"><link rel="shortcut icon" href="/favicon.ico"><link rel="canonical" href="https://wsk0404.github.io/posts/6c92115f"><link rel="preconnect" href="//cdn.cbd.int"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><meta name="google-site-verification" content="xxx"/><meta name="baidu-site-verification" content="code-xxx"/><meta name="msvalidate.01" content="xxx"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.cbd.int/node-snackbar@0.1.16/dist/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.cbd.int/@fancyapps/ui@5.0.20/dist/fancybox/fancybox.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://npm.elemecdn.com/anzhiyu-theme-static@1.0.0/swiper/swiper.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  linkPageTop: undefined,
  peoplecanvas: {"enable":true,"img":"https://upload-bbs.miyoushe.com/upload/2023/09/03/125766904/ee23df8517f3c3e3efc4145658269c06_5714860933110284659.png"},
  postHeadAiDescription: undefined,
  diytitle: {"enable":true,"leaveTitle":"w(ﾟДﾟ)w 不要走！再看看嘛！","backTitle":"♪(^∇^*)欢迎肥来！"},
  LA51: undefined,
  greetingBox: {"enable":true,"default":"晚上好👋","list":[{"greeting":"晚安😴","startTime":0,"endTime":5},{"greeting":"早上好鸭👋, 祝你一天好心情！","startTime":6,"endTime":9},{"greeting":"上午好👋, 状态很好，鼓励一下～","startTime":10,"endTime":10},{"greeting":"11点多啦, 在坚持一下就吃饭啦～","startTime":11,"endTime":11},{"greeting":"午安👋, 宝贝","startTime":12,"endTime":14},{"greeting":"🌈充实的一天辛苦啦！","startTime":14,"endTime":18},{"greeting":"19点喽, 奖励一顿丰盛的大餐吧🍔。","startTime":19,"endTime":19},{"greeting":"晚上好👋, 在属于自己的时间好好放松😌~","startTime":20,"endTime":24}]},
  twikooEnvId: '',
  commentBarrageConfig:{"enable":true,"maxBarrage":1,"barrageTime":4000,"accessToken":"","mailMd5":"3932F24FA213E964B6B1B0FD091F88CE"},
  root: '/',
  preloader: {"source":3},
  friends_vue_info: {"apiurl":"https://friends.anheyu.com/"},
  navMusic: true,
  mainTone: {"mode":"both","api":"https://img2color-go.vercel.app/api?img=","cover_change":true},
  authorStatus: {"skills":["🤖️ 数码科技爱好者","🔍 分享与热心帮助","🔨 设计开发一条龙","🏃 脚踏实地行动派"]},
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简","rightMenuMsgToTraditionalChinese":"转为繁体","rightMenuMsgToSimplifiedChinese":"转为简体"},
  noticeOutdate: {"limitDay":365,"position":"top","messagePrev":"It has been","messageNext":"days since the last update, the content of the article may be outdated."},
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":330},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: true,
    simplehomepage: false,
    post: true
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"copy":true,"copyrightEbable":true,"limitCount":50,"languages":{"author":"作者: Wsk","link":"链接: ","source":"来源: Wsk Blog","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。","copySuccess":"复制成功，复制和转载请标注本文地址"}},
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#425AEF","bgDark":"#1f1f1f","position":"top-center"},
  source: {
    justifiedGallery: {
      js: 'https://cdn.cbd.int/flickr-justified-gallery@2.1.2/dist/fjGallery.min.js',
      css: 'https://cdn.cbd.int/flickr-justified-gallery@2.1.2/dist/fjGallery.css'
    }
  },
  isPhotoFigcaption: true,
  islazyload: true,
  isAnchor: false,
  shortcutKey: undefined,
  autoDarkmode: true
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  configTitle: 'Wsk Blog',
  title: 'Spring',
  postAI: '',
  pageFillDescription: '🎯 面试题：聊聊你对 Spring 框架的理解, 一、面试官考察点, 二、Spring 框架简介, 三、Spring 的核心理念, 1️⃣ IOC（Inversion of Control）控制反转, 2️⃣ AOP（Aspect-Oriented Programming）面向切面编程, 四、Spring 的核心模块, 五、Spring 框架常用设计模式, 六、Spring 在 WMS 系统中的应用（项目实战）, ✅ 入库模块示例, 七、性能与扩展机制, 八、面试高频追问, 九、高分总结模板（可直接背诵）, 🎯 面试题：@Autowired 和 @Resource 有什么区别？, 一、面试官考察点, 二、核心速答（30 秒答题模板）, 三、详细区别对比表, 四、注入机制详解, ✅ @Autowired 注入流程（按类型）, ✅ @Resource 注入流程（按名称）, 五、底层原理（源码层级）, 🔍 @Autowired, 🔍 @Resource, 六、实战场景（WMS 系统示例）, 七、常见错误与陷阱, 八、常见追问与答案, 九、性能与工程实践建议, 🔟 一分钟高分总结（可背诵）, 🎯 面试题：谈谈你对 IOC 和 AOP 的理解, 一、面试官考察点, 二、核心速答（30 秒模板）, 三、IOC（控制反转）详解, 1️⃣ 定义, 2️⃣ 核心思想, 3️⃣ 传统方式 vs IOC 方式, 4️⃣ IOC 容器核心组件, 5️⃣ 实现原理（IOC 运行流程）, 6️⃣ 涉及的设计模式, 7️⃣ 在项目中的应用（WMS 示例）, 四、AOP（面向切面编程）详解, 1️⃣ 定义, 2️⃣ 核心思想, 3️⃣ 典型场景, 4️⃣ 核心概念, 5️⃣ 示例：AOP 日志增强, 6️⃣ 底层实现原理, 7️⃣ 底层流程图（简述）, 五、IOC 与 AOP 的关系与区别, 六、常见追问与答案, 七、性能与实践建议, 八、高分总结模板（可背诵）, 🎯 面试题：Spring 中单例 Bean 的线程安全问题, 一、核心结论速答（面试开场回答模板）, 二、Spring Bean 的单例本质, 1️⃣ 默认作用域是 Singleton, 2️⃣ 单例作用域的生命周期, 三、单例 Bean 线程安全问题的根本原因, ❌ 错误示例（有状态 Bean）, ✅ 正确做法（无状态 Bean）, 四、单例 Bean 的分类与安全性分析, 五、Spring 为什么不自动保证线程安全？, 六、常见解决方案与实践建议, ✅ 方案 1：无状态设计（推荐）, ✅ 方案 2：使用局部变量, ✅ 方案 3：使用 ThreadLocal, ✅ 方案 4：更改 Bean 作用域, 七、Spring 内部的线程安全机制举例, 八、常见面试追问与答案, 九、底层实现原理（源码级）, 🔟 高分总结模板（可背诵）, 🔍 扩展话题（面试官可能深入追问）, 🎯 面试题：Spring 如何解决循环依赖问题？, 一、面试官考察点, 二、核心速答模板（面试开场版）, 三、什么是循环依赖？, 示例：, 四、Spring 解决循环依赖的前提与限制, 五、Spring 三级缓存核心机制, 六、循环依赖解决流程（重点核心）, 七、源码核心解析（简化版）, 八、AOP 代理与三级缓存的关系, 九、常见面试追问与答案, 🔟 实际项目案例（WMS 场景）, 🧩 十一、性能与安全性分析, 🧠 十二、高分总结模板（可背诵）, 🔍 十三、扩展话题（面试官可能继续追问）, 🎯 面试题：Spring Bean 的实例化和初始化过程, 一、面试官考察点, 二、核心速答（30 秒简版）, 三、Spring Bean 创建的完整流程（详细版）, 阶段 1：加载 Bean 定义（BeanDefinition）, 阶段 2：实例化 Bean（Instantiation）, 阶段 3：依赖注入（Populate Bean）, 阶段 4：初始化前置处理（BeanPostProcessor - before）, 阶段 5：初始化（Initialization）, 阶段 6：初始化后置处理（BeanPostProcessor - after）, 阶段 7：注册到单例池（singletonObjects）, 阶段 8：销毁阶段（Destruction）, 四、Bean 生命周期总览图（高频面试画图题）, 五、源码关键路径（简化总结）, 六、常见追问与标准答案, 七、高分总结模板（面试可直接复述）, 八、扩展问题（面试加分）, 🎯 面试题：Spring 中常用注解及其原理, 一、考察点概览, 二、Spring 注解体系总体分类, 三、核心注解详解（IOC 组件声明）, 1️⃣ @Component, 2️⃣ @Service、@Repository、@Controller, 四、依赖注入注解, 示例：, 五、配置类相关注解（取代 XML 配置）, 示例：, 六、AOP 与事务注解, 示例：, 七、Web 层常用注解（Spring MVC）, 示例：, 八、生命周期与回调注解, 示例：, 九、Spring Boot 注解体系（扩展）, 十、常见追问与标准答案, 十一、高分总结模板（可背诵）, 十二、扩展：面试官可能进一步追问, 🎯 面试题：Spring 声明式事务在什么情况下会失效？, 一、前置知识：Spring 声明式事务的原理, 二、常见的 8 种事务失效场景（含原理与解决方案）, ① 同类方法内部调用（Self Invocation）导致事务失效, ② 方法不是 public 导致事务失效, ③ 异常类型错误（非运行时异常不回滚）, ④ 异常被捕获导致事务失效, ⑤ 事务方法未被 Spring 管理, ⑥ 数据库不支持事务（或使用了错误的引擎）, ⑦ 多线程导致事务失效, ⑧ 事务传播行为配置不当, 三、事务失效问题定位技巧, 四、高分总结模板（面试可直接背诵）, 🎯 面试题：什么是嵌套事务？Spring 中是如何实现的？, 一、面试官考察点, 二、30 秒速答版（面试简答）, 三、详细解析（核心原理）, 1️⃣ 嵌套事务的定义, ⚙️ 2️⃣ Spring 的嵌套事务传播行为：Propagation.NESTED, 🔍 3️⃣ NESTED 与 REQUIRES_NEW 的区别（面试高频追问）, 🔧 4️⃣ 底层原理分析（源码层）, ⚠️ 5️⃣ 嵌套事务的失效场景（常见陷阱）, 📚 6️⃣ 嵌套事务的典型应用场景, 💡 示例代码（带回滚演示）, ⚙️ 7️⃣ 性能与事务深度分析, 八、面试加分总结（可背诵版）, 🎯 面试题：外部事务回滚子事务也必然会回滚吗？, 一、面试速答（标准答法）, 二、深入原理解析, 1️⃣ NESTED 的本质：同一事务、保存点机制, 2️⃣ 底层执行逻辑（伪源码）, 3️⃣ 与 REQUIRES_NEW 的对比（非常关键）, 4️⃣ 举个实际例子, 执行结果：, 5️⃣ 如果改成 REQUIRES_NEW, 执行结果：, 三、总结逻辑（面试可复述版）, 四、常见追问与陷阱, 五、高分总结（背诵模板）, 🎯 面试题：Spring 事务的实现原理（@Transactional 底层机制）, 一、面试官考察点, 二、30 秒速答（面试速答版）, 三、事务的整体执行流程, 四、核心组件与职责划分, 五、深入底层实现（源码级分析）, 1️⃣ AOP 动态代理机制, 2️⃣ 事务拦截器 TransactionInterceptor, 3️⃣ 事务管理器 PlatformTransactionManager, 4️⃣ JDBC 层事务控制, 5️⃣ ThreadLocal 线程绑定机制, 六、事务传播机制（Propagation）, 七、事务回滚机制, 1️⃣ 回滚条件, 2️⃣ 回滚流程（源码）, 八、事务失效的常见原因（面试高频陷阱）, 九、性能与设计分析, 🔥 十、一分钟高分总结（可背诵）, 🎯 面试题：Spring Task 定时任务失败了如何重试？, 一、面试官意图, 二、基础回答（30 秒面试速答版）, 三、Spring Task 执行原理, 四、Spring Task 任务失败的常见原因, 五、任务失败后的重试策略实现, ✅ 1️⃣ 手动重试（try-catch + 循环）, ✅ 2️⃣ 使用 @Retryable 注解（Spring Retry）, 示例代码：, ✅ 3️⃣ 使用消息队列重试（业务补偿机制）, ✅ 4️⃣ 使用分布式调度框架（XXL-Job x2F Quartz）, 六、最佳实践建议（工程级）, 七、常见追问与高分回答, ❓1️⃣ 追问：如果任务失败后整个应用重启了怎么办？, ❓2️⃣ 追问：任务执行中抛出异常Spring 会停止后续执行吗？, ❓3️⃣ 追问：Spring Task 支持集群模式下避免重复执行吗？, 八、性能分析与扩展话题, 🔥 九、总结（可背诵版）面试题聊聊你对框架的理解一面试官考察点是否理解的核心思想与设计模式是否熟悉控制反转与面向切面编程原理是否了解的核心模块是否能结合项目场景如系统说明的使用价值是否能提到扩展机制与性能优化二框架简介是一个开源的轻量级企业级开发框架用于简化企业级应用的开发与维护它通过和两大核心机制帮助开发者实现低耦合高内聚可扩展易测试的架构创始人初衷解决企业级开发中对象依赖复杂配置繁琐测试困难的问题核心目标让开发更简单三的核心理念控制反转核心思想对象的创建与依赖关系的管理不再由开发者手动完成而是交由容器统一管理传统方式容器管理方式本质通过反射容器初始化实现对象创建与依赖注入优点降低模块间耦合度提升代码可维护性与可测试性面向切面编程核心思想将日志事务安全等横切关注点从业务逻辑中分离通过切面统一管理开始调用方法底层实现动态代理接口动态代理类应用场景日志记录事务控制性能监控权限校验四的核心模块模块主要功能核心容器提供和提供面向切面编程支持容器上下文管理数据访问抽象层整合层框架提供请求分发与视图解析单元测试支持集成自动化配置简化项目搭建微服务生态服务注册配置熔断网关五框架常用设计模式模式应用场景工厂模式创建单例模式默认单例管理代理模式底层实现模板方法模式观察者模式适配器模式处理控制器调用六在系统中的应用项目实战入库模块示例入库单保存成功说明管理注入管理事务解耦业务逻辑与资源管理提升系统的可维护性与扩展性七性能与扩展机制缓存机制单例仅初始化一次懒加载在第一次调用时才初始化三级缓存机制防止循环依赖扩展接口八面试高频追问追问高分回答容器的核心类负责的生命周期管理如何解决循环依赖通过三级缓存机制提早暴露单例引用底层是如何实现的使用动态代理或动态代理生成代理对象和的区别按类型注入按名称注入的生命周期实例化属性注入初始化使用销毁相比传统有哪些优势自动装配内嵌容器约定优于配置快速开发微服务九高分总结模板可直接背诵是一个轻量级企业级开发框架以和为核心通过实现对象解耦与依赖注入实现横切关注点分离框架模块包括等在实际开发中我常使用管理生命周期结合做日志事务控制在系统中通过实现模块解耦与快速开发的设计思想体现了面向接口编程和高内聚低耦合的架构原则面试题和有什么区别一面试官考察点是否理解容器的依赖注入原理是否清楚两者的注入方式区别是否了解注解的来源与能否结合实际开发如系统模块注入说明差异是否理解底层源码原理与优先级解析顺序二核心速答秒答题模板是提供的注解按类型自动注入是标准注解按名称注入当容器中存在多个同类型时可配合指定名称而默认优先按名称查找找不到再按类型查找简而言之专属按类型标准按名称三详细区别对比表对比项所属包依赖来源框架标准注入方式按类型按名称优先再按类型是否可与搭配可用指定注入名称不能与联用是否支持属性支持可选注入不支持是否支持构造方法注入支持推荐构造注入不支持常见应用场景应用第三方集成旧项目兼容可移植性特有不通用标准注解跨框架通用四注入机制详解注入流程按类型启动时扫描类上的字段根据字段类型从容器中查找如果存在多个同类型若加了按名称匹配若未加抛出异常若找不到报错除非设置示例按类型注入可选注入注入流程按名称解析时先根据字段名匹配同名如果找不到再按类型匹配若仍找不到抛出异常示例按名称注入若不指定默认按字段名查找五底层原理源码层级解析入口调用链支持多种注入方式字段注入构造器注入注入解析入口基于标准规范实现优先匹配名称再匹配类型六实战场景系统示例在系统中若我们有多个入库策略实现类使用使用两种方式效果相同但语义略有不同七常见错误与陷阱错误原因解决方案容器中存在多个同类型按类型注入冲突使用或指定找不到名称不匹配确保名称与字段名一致或指定属性想用构造方法注入但用不支持构造注入改用引入第三方包缺少移除了该包手动添加依赖八常见追问与答案面试官问题高分回答和如何配合使用按类型注入指定名称解决多实现冲突推荐哪种推荐使用官方维护更灵活且支持构造注入可不可以注入非不行注入对象必须由容器管理构造方法注入的好处提高代码可测试性线程安全不可变性推荐在实际项目中使用九性能与工程实践建议推荐使用官方推荐灵活性高结合构造注入保证依赖不可变在多实现类场景下使用在旧系统或跨框架时可用保持兼容建议统一规范注入方式团队约定构造注入一分钟高分总结可背诵是提供的注解按类型注入可配合使用属于标准注解按名称注入找不到再按类型注入在实际项目中官方更推荐使用尤其在环境下可支持构造方法注入可选注入懒加载等高级特性而更适用于标准化项目或第三方框架集成场景简而言之按类型按名称面试题谈谈你对和的理解一面试官考察点是否真正理解的核心思想是否能从原理应用层面解释与是否能结合设计模式与项目实践说明两者的意义是否能回答常见追问如如何实现底层基于什么是否能将理论与实际项目如系统结合二核心速答秒模板框架的核心是和是控制反转即将对象的创建与依赖管理交给容器实现解耦与灵活配置是面向切面编程用于将日志事务安全等横切逻辑与业务逻辑分离实现模块化增强简而言之管理对象之间的依赖关系管理代码运行过程中的横切逻辑三控制反转详解定义是的缩写意为控制反转即对象的控制权创建依赖注入生命周期管理从程序员手中反转到容器容器中核心思想程序员只需声明需要什么依赖通过注解或配置容器自动创建装配和管理它们传统方式方式传统方式强耦合直接容器方式解耦由注入变化对象由容器创建依赖关系通过配置或注解自动注入模块之间从硬编码依赖变为配置化依赖容器核心组件组件作用最基础的容器接口延迟加载懒加载的子接口支持国际化事件机制资源加载常用注解驱动容器实现原理运行流程读取配置注解解析实例化对象进行依赖注入调用处理初始化完成后放入单例池使用时由容器统一管理与销毁涉及的设计模式模式在中的体现工厂模式创建对象单例模式默认单例管理代理模式增强依赖注入后的模板方法模式生命周期管理在项目中的应用示例优点解耦模块易于扩展便于单元测试实现组件可插拔架构四面向切面编程详解定义是一种编程范式用于在不修改源代码的前提下动态地增强程序功能核心思想将与业务逻辑无关但横切多个模块的功能如日志事务安全抽取出来集中管理典型场景场景描述日志记录统一记录方法调用日志权限校验在业务前做安全认证性能监控记录接口执行时间异常处理统一捕获并处理异常事务管理在方法执行前后控制事务核心概念名称说明程序执行的特定点如方法调用切点定义在哪些应用增强通知定义增强的具体逻辑切面的组合代理对象通过生成将切面逻辑织入目标对象的过程示例日志增强调用方法方法执行结束效果在所有包的方法执行前后自动打印日志无需手动修改业务代码底层实现原理实现机制说明动态代理基于接口的代理实现动态代理基于类的代理继承目标类生成子类运行时织入轻量级默认基于代理机制编译时织入功能更强大可集成底层流程图简述目标类代理工厂生成代理对象调用增强逻辑执行业务方法五与的关系与区别对比项关注点对象的创建与依赖管理行为的横切逻辑增强实现方式反射动态代理作用阶段初始化时使用时运行期核心目标解耦依赖解耦行为设计模式工厂模式单例模式代理模式关系总结是的一个重要应用场景负责托管对象负责增强对象六常见追问与答案追问高分回答如何实现依赖注入通过反射注册类型匹配注入为什么使用动态代理为了不修改源码实现横切逻辑增强符合开闭原则与有何区别是运行时代理是编译时织入如何实现事务使用底层通过拦截方法调用并包裹事务逻辑和的区别是思想是实现依赖注入是实现控制反转的一种方式七性能与实践建议使用构造注入避免循环依赖控制单例的状态避免线程安全问题尽量只增强必要的切点避免在高频调用方法中过度使用环绕通知影响性能使用异步切面记录日志监控性能八高分总结模板可背诵的核心是和控制反转通过容器管理对象的创建与依赖注入解决模块间的强耦合问题实现组件解耦与灵活配置面向切面编程通过动态代理将横切关注点从业务逻辑中分离实现如日志事务权限等功能的统一管理管理对象关系管理行为增强两者结合实现了框架的高扩展性与可维护性面试题中单例的线程安全问题一核心结论速答面试开场回答模板在中默认的是单例的容器只会创建一个实例但并不会对这个单例做任何线程安全保证如果是无状态的例如这样的是线程安全的如果是有状态的例如在成员变量中保存请求数据或中间结果就会出现线程安全问题解决方案包括使用局部变量替代成员变量使用隔离线程数据或将定义为多例等作用域二的单例本质默认作用域是默认单例容器在启动时只会创建一个实例并将其放入单例池中全局共享单例作用域的生命周期容器启动实例化容器运行期间所有线程共享同一个实例容器关闭销毁关键点单例的对象是共享的若内部保存可变数据就可能产生线程安全问题三单例线程安全问题的根本原因错误示例有状态成员变量保存状态多个请求线程共享同一个实例线程设置王帅锴线程设置李四的返回值会互相干扰典型的线程不安全正确做法无状态使用局部变量代替成员变量结论只要不在成员变量中保存可变状态单例就是线程安全的四单例的分类与安全性分析类型是否有状态是否线程安全示例有状态若存储请求数据否通常无状态是调用层方法无状态是操作数据库连接池取决于设计视情况而定缓存工具类等五为什么不自动保证线程安全性能原因若对每个都加锁会严重影响性能职责分离容器负责生命周期管理不负责并发控制可控性线程安全问题取决于业务逻辑无法统一处理六常见解决方案与实践建议方案无状态设计推荐保持的无状态性不要在成员变量中存储用户请求数据最推荐的实践方式方案使用局部变量在方法内部使用局部变量保存临时状态线程独享局部变量方案使用适合存放与线程相关的上下文信息如用户请求信息中的事务管理请求上下文也大量使用实现线程隔离方案更改作用域通过注解更改的生命周期范围类型描述线程安全性全局单例线程不安全需无状态每次请求新建线程安全独立实例每次请求创建线程安全场景每个创建一次线程安全场景七内部的线程安全机制举例模块是否线程安全原理是启动后只读不修改注入是初始化阶段完成依赖装配是代理对象保证事务隔离否若保存状态多线程共享同一对象八常见面试追问与答案追问答案容器中的默认是线程安全的吗不是默认单例不是线程安全的单例一定不安全吗不一定若无状态则是线程安全的的是单例的吗是单例的若在中定义成员变量会产生线程安全问题如何避免出现线程安全问题不在中定义可变成员变量必要时使用局部变量或如何处理作用域通过代理模式为每个请求创建独立实例九底层实现原理源码级容器通过管理单例单例存放在中注意容器层面是线程安全的使用存放自身并不保证线程安全只保证容器操作的安全不保证内部逻辑的安全高分总结模板可背诵中默认的是单例模式容器会为每个创建一个共享实例并在应用中复用单例本身是线程共享的因此如果其中存在可变的成员变量就会产生线程安全问题一般来说无状态如是线程安全的有状态如保存请求信息是线程不安全的解决方式包括无状态设计局部变量或调整作用域容器本身是线程安全的但的线程安全需要开发者自行保证扩展话题面试官可能深入追问如何解决循环依赖涉及三级缓存在中的典型应用有哪些为什么是单例的为什么不默认设为如何保证事务隔离事务与线程安全的关系面试题如何解决循环依赖问题一面试官考察点是否理解的生命周期与依赖注入机制是否了解容器三级缓存的作用能否区分构造器注入与注入在循环依赖下的差异是否知道在场景下如何处理代理对象的提前暴露二核心速答模板面试开场版通过三级缓存机制解决了单例的循环依赖问题当依赖而又依赖时在实例化阶段还未初始化完成就会提前将的引用暴露到三级缓存中这样在创建另一个时可以获取到该半成品对象从而完成依赖注入三级缓存结构一级缓存已完全初始化的单例二级缓存已实例化但未初始化的早期三级缓存存放创建提前暴露对象的工厂用于解决代理问题三什么是循环依赖循环依赖指的是多个之间互相依赖形成环状结构导致容器无法正常完成依赖注入示例此时需要先创建又依赖如果没有特殊机制就会陷入死循环四解决循环依赖的前提与限制类型是否支持构造器注入不支持会直接报错因为对象未创建注入字段注入支持会通过三级缓存提前暴露引用原型作用域不支持无法缓存多个半成品对象五三级缓存核心机制通过管理这三层缓存缓存层级字段名说明一级缓存存放完全初始化的单例二级缓存存放实例化但未初始化的早期三级缓存存放可创建早期的工厂六循环依赖解决流程重点核心以为例实例化此时属性还未注入提前暴露的到三级缓存为填充属性发现依赖实例化提前暴露的工厂到三级缓存为填充属性发现依赖从缓存中获取一级缓存找不到二级缓存找不到三级缓存命中调用工厂返回半成品将早期放入二级缓存初始化完成放入一级缓存注入到初始化完成放入一级缓存关键点半成品提前暴露未完全初始化但可被依赖完成初始化后会升级到一级缓存三级缓存保证了代理对象也能被提前暴露七源码核心解析简化版的核心逻辑在一级缓存已完全初始化的二级缓存提前曝光但未完成初始化的三级缓存通过工厂创建早期关键逻辑当还未完成初始化时会调用三级缓存中的提前生成一个早期引用初始化完成后再替换为完整若涉及代理对象则工厂中生成的是代理后的对象八代理与三级缓存的关系在场景下若不使用三级缓存循环依赖会出现代理对象注入异常原因是需要在初始化后创建代理若提前暴露的是原始对象注入的将不是代理对象因此三级缓存的工厂中存放的是生成代理对象的逻辑举例这样即使提前暴露也能拿到代理对象引用九常见面试追问与答案追问答案为什么要用三级缓存而不是二级因为二级缓存只能保存实例对象而无法支持代理对象的提前暴露三级缓存通过动态生成代理对象构造器注入能解决循环依赖吗不能因为构造器注入在实例化阶段就需要依赖对象而对象还未创建完成原型作用域能解决循环依赖吗不能因为每次创建新实例无法缓存半成品对象为什么要有二级缓存避免多次调用导致重复创建代理对象保证同一个早期引用复用代理下的循环依赖如何处理提前暴露的是代理对象引用通过获取实际项目案例场景假设在系统中可正常启动因为使用的是字段注入通过三级缓存解决若改成构造函数注入会直接抛出十一性能与安全性分析循环依赖解决方案性能开销低基于缓存引用不加锁但若循环关系复杂多层循环可读性差维护成本高推荐通过重构消除循环依赖例如通过事件驱动或中间层解耦十二高分总结模板可背诵通过三级缓存机制解决了单例的循环依赖问题在创建过程中会在实例化后初始化前将该的引用提前暴露到三级缓存中当另一个依赖它时可以从缓存中获取该早期引用从而打破循环三级缓存结构一级缓存已初始化完成的二级缓存早期实例三级缓存可生成早期的工厂用于支持代理仅支持单例的注入循环依赖对于构造器注入或不支持循环依赖十三扩展话题面试官可能继续追问为什么选择三级缓存而不是二级如果我用注解能否解决循环依赖构造器注入导致循环依赖会如何处理环境下代理对象如何在循环依赖中正确注入的三级缓存机制与三级单例缓存之间的区别面试题的实例化和初始化过程一面试官考察点是否理解的完整生命周期能否区分实例化和初始化的概念是否了解中涉及的关键接口等是否能说清楚依赖注入增强三级缓存循环依赖处理的流程二核心速答秒简版在容器中的创建大致分为两大阶段实例化通过反射创建对象只分配内存执行构造函数初始化依赖注入调用初始化方法执行代理触发生命周期回调整个过程由负责期间涉及三级缓存解决循环依赖并通过执行的前置后置增强逻辑三创建的完整流程详细版我们从开始逐步梳理整个过程阶段加载定义启动时会解析配置类或将每个的元信息加载到中包括类全限定名作用域自动注入模式初始化销毁方法依赖关系等对应源码阶段实例化负责创建对象类似于执行操作调用方法通过反射或工厂方法创建对象主要执行逻辑若存在工厂方法调用工厂方法创建否则使用反射或实例化实例化完成后进入三级缓存该阶段仅有空壳对象属性尚未注入源码位置阶段依赖注入负责填充属性调用为实例化的注入依赖主要流程解析字段注入从容器中获取依赖如果依赖尚未完全初始化则通过三级缓存提前暴露早期引用解决循环依赖完成属性装配源码位置阶段初始化前置处理的第一次回调在完成依赖注入后但在调用初始化方法前会让所有注册的对进行预处理比如代理的预检测检查处理资源注入等示例可对属性进行修改阶段初始化初始化是指执行自定义的初始化逻辑提供多种方式定义的初始化逻辑方式示例执行顺序实现接口先执行注解在中触发注解指定或最后执行源码位置阶段初始化后置处理第二次回调此时已初始化完成若需要增强如则在此阶段生成代理对象示例返回代理对象最终返回的可能不是原始而是代理增强后的对象阶段注册到单例池初始化完成后将存入一级缓存供全局复用此时二级三级缓存中的引用被清除生命周期进入可使用阶段若实现了则上下文已注入阶段销毁阶段当容器关闭时如调用调用注解方法调用中定义的销毁逻辑四生命周期总览图高频面试画图题生命周期读取配置加载创建实例实例化构造函数属性填充依赖注入初始化生成代理注册到单例池可被容器使用容器关闭销毁五源码关键路径简化总结实例化依赖注入初始化六常见追问与标准答案追问高分回答实例化与初始化的区别实例化是创建对象分配内存调用构造函数初始化是填充属性并执行自定义逻辑在哪执行在属性注入后前执行在初始化后执行与区别前者在实例化前修改后者在实例化后修改实例代理在何时生成通常在阶段生成如何保证单例的线程安全不保证业务线程安全需自行同步只保证单例的唯一性七高分总结模板面试可直接复述的创建分为两大阶段实例化反射创建对象与初始化依赖注入生命周期回调增强流程包括解析实例化属性注入调用前置执行初始化方法调用后置生成代理对象注册单例其中通过三级缓存机制解决循环依赖问题通过实现依赖注入等扩展功能八扩展问题面试加分中如何处理循环依赖三级缓存机制如果一个是原型作用域循环依赖还能解决吗与接口的执行顺序自动装配与创建过程的关系初始化时如何处理事务注解非常好王帅锴常用注解及其作用机制是中高级面试的基础高频题如果你能在面试中不仅背出注解名称还能说明底层原理执行阶段常见组合与陷阱那就能体现出你是真正理解框架的工程师而不是仅仅会用面试题中常用注解及其原理一考察点概览面试官主要考察以下几个方面是否能系统分类常用注解核心等是否理解注解与容器的关系是否能解释注解背后的原理如是否知道注解在生命周期中的执行顺序如依赖注入阶段是否清楚常见注解的使用陷阱与组合如二注解体系总体分类分类代表注解作用核心注解容器相关声明并由管理自动装配相关实现依赖注入配置与声明类声明配置类加载导入外部配置与事务切面编程与事务管理层注解控制器层注解生命周期与回调初始化与销毁钩子扩展自动装配与条件注入三核心注解详解组件声明表示当前类是一个组件由容器管理原理在扫描时被扫描的类会被解析成注册到容器中它们本质上都是的派生注解只是用于不同的分层语义业务数据控制层原理具备额外的异常转换功能会被识别为控制器返回数据四依赖注入注解注解作用特点与区别自动按类型注入提供支持构造器字段配合指定名称按名称精确注入标准注解默认按名称注入兼容性好可与非框架集成示例常见陷阱同类型多个未使用时会报构造器注入推荐使用字段注入易于滥用五配置类相关注解取代配置注解作用声明配置类等价于配置文件指定扫描包路径自动发现定义的创建方法适合外部类或第三方对象导入额外的配置类或加载外部属性文件注入配置文件中的属性值示例原理会通过解析类方法在容器启动时执行返回对象会注册进六与事务注解注解功能声明一个切面类定义切点表达式定义通知逻辑开启自动代理声明事务管理示例原理通过在初始化后创建代理通过与动态代理实现事务切面七层常用注解注解作用返回的控制器定义请求路径与方法映射快捷请求映射将请求体反序列化为对象将返回值序列化为绑定路径参数绑定请求参数允许跨域请求示例八生命周期与回调注解注解阶段说明初始化前在依赖注入完成后执行初始化逻辑容器关闭前在销毁前执行清理逻辑示例初始化完成即将销毁九注解体系扩展注解说明组合注解自动装配机制核心条件装配控制如绑定配置文件属性到十常见追问与标准答案面试官追问高分回答和有何区别是特有默认按类型注入属于标准默认按名称注入和区别用于返回和的区别声明配置类支持方法代理仅是普通的原理通过加载自动配置类机制如何自定义注解使用声明作用范围与生命周期再结合实现逻辑十一高分总结模板可背诵注解体系主要围绕四大模块构建系定义系实现依赖注入系定义配置类与系实现增强系构建层控制器它们的实现依赖于的后置处理器机制如通过反射与动态代理实现自动扫描注入与增强十二扩展面试官可能进一步追问是如何识别这些注解的通过扫描元注解如何处理组合注解如利用元注解机制与的原理基于接口在解析阶段动态判断面试题声明式事务在什么情况下会失效一前置知识声明式事务的原理声明式事务的核心机制基于动态代理当你在方法上使用注解时会创建一个代理对象动态代理或代理在方法调用前后进行事务增强调用前开启事务调用后提交事务或回滚事务注意只有通过代理对象调用方法时才能在方法前后织入事务逻辑如果方法是由本类直接调用则事务逻辑会被绕过这正是事务失效的根源之一二常见的种事务失效场景含原理与解决方案同类方法内部调用导致事务失效开启事务本类调用本类方法没有经过代理原理通过代理类增强但调用是直接调用自身方法没有经过代理对象因此事务增强逻辑开启提交回滚根本不会触发解决方案把移到另一个中由代理对象调用或者在容器中获取自己前提方法不是导致事务失效原理只能代理方法非方法不会被代理事务逻辑不会织入解决方案保证带有的方法是异常类型错误非运行时异常不回滚原理默认只对运行时异常或回滚检查型异常不会触发回滚解决方案显式指定回滚异常类型或统一封装异常为运行时异常异常被捕获导致事务失效出错吞掉异常异常被捕获原理通过代理判断是否需要回滚若异常被捕获外层代理检测不到异常事务正常提交解决方案不要捕获异常或在捕获后手动标记回滚事务方法未被管理原理如果未被容器托管例如自己出来的对象无法生成代理对象没有事务增强逻辑解决方案保证类上有且由容器注入使用数据库不支持事务或使用了错误的引擎原理如果使用引擎它不支持事务或者操作跨多个数据源但未使用分布式事务管理器解决方案使用支持事务的引擎如跨库事务需配置分布式事务如多线程导致事务失效原理新线程与当前事务上下文无关事务是基于存储的新线程不会继承主线程的事务状态解决方案不要在事务方法中创建新线程或使用异步事务框架消息队列解耦事务传播行为配置不当不开启事务原理等传播属性会禁止事务若嵌套调用时外层事务被挂起或关闭也会失效解决方案确保传播行为满足业务逻辑如三事务失效问题定位技巧工具方法日志调试打开日志级别为检查确认方法是否通过代理对象调用事务传播链分析查看多层调用传播属性是否冲突事务管理器配置检查是否正确配置了或四高分总结模板面试可直接背诵在中声明式事务是基于动态代理实现的因此事务只有在通过代理对象调用方法时才会生效常见的事务失效场景包括同类方法内部调用未经过代理方法非异常类型错误非不回滚异常被捕获未重新抛出方法未被管理数据库不支持事务多线程导致隔离传播属性设置错误核心本质事务依赖代理机制只能在代理边界内生效面试题什么是嵌套事务中是如何实现的一面试官考察点考察你是否理解事务的传播机制嵌套事务与独立事务的区别如何实现嵌套事务基于嵌套事务的失效与回滚规则二秒速答版面试简答嵌套事务是指在一个事务内部再开启一个子事务当子事务回滚时不影响外层事务但外层事务回滚时会导致子事务一并回滚在中通过实现底层是基于数据库的保存点机制实现的三详细解析核心原理嵌套事务的定义假设有两个方法外层事务内层事务也加了事务注解执行逻辑启动一个事务当执行到时如果当前事务存在则在当前事务中创建一个保存点内层事务出错时会回滚到保存点而不是整个外层事务外层事务仍然可以继续提交但如果外层事务回滚内层事务也必须随之回滚嵌套事务外层事务子的嵌套事务传播行为中事务传播行为一共有种传播行为含义如果存在事务则加入否则新建一个最常用每次都新建一个独立事务暂停外层事务如果存在事务则在当前事务中创建保存点否则新建事务支持当前事务无则非事务执行非事务执行若有事务则挂起必须在事务中执行否则抛异常禁止事务执行有事务则异常与的区别面试高频追问对比点是否新建事务否创建保存点是新建一个独立事务外层事务回滚是否影响内层是否内层事务回滚是否影响外层否仅回滚到保存点否各自独立实现机制同一连接新事务新连接性能较高共用连接较低切换连接典型场景局部失败可恢复的业务完全独立的业务逻辑示例外层事务内层嵌套事务嵌套事务操作执行时会创建一个异常时仅回滚的修改底层原理分析源码层在中创建保存点说明嵌套事务通过底层数据库连接的来实现回滚局部事务嵌套事务的失效场景常见陷阱使用非支持保存点的数据库比如某些引擎不支持事务保存点只能使用不同事务管理器不同数据源嵌套事务要求使用同一个否则无法共用连接嵌套调用在同类中自调用的事务是基于代理的同类内部方法直接调用不会触发代理事务失效解决方案使用调用或者通过另一个注入自身调用异常未被感知如果子事务抛出异常被捕获且未抛出事务不会回滚嵌套事务的典型应用场景场景说明局部业务可回滚某部分失败不影响主事务如订单部分失败但主流程继续批量处理部分回滚批处理任务单条失败可回滚到保存点工作流多步骤任务局部异常只回滚该节点示例代码带回滚演示外层事务内层嵌套事务支付失败订单继续模拟支付异常输出支付失败订单继续外层事务成功提交内层事务自动回滚到保存点性能与事务深度分析层次事务类型性能数据库连接备注新事务中等新连接完全独立保存点高共享连接可局部回滚嵌套事务是轻量级的局部回滚而非完全独立的事务八面试加分总结可背诵版嵌套事务是指在一个事务中创建子事务在中通过实现底层基于数据库的机制子事务回滚时仅回滚到保存点不影响外层事务外层事务回滚会连带子事务一起回滚它与最大的区别是共用连接性能高可局部回滚新建事务完全独立但成本更高在批处理局部回滚等业务中非常有用面试题外部事务回滚子事务也必然会回滚吗一面试速答标准答法是的如果使用的是嵌套事务外部事务回滚时子事务一定会回滚因为嵌套事务与外部事务共用同一个数据库连接子事务的保存点是在外层事务中创建的一旦外层事务回滚整个事务上下文会回滚到事务开始前的状态包括子事务的修改二深入原理解析的本质同一事务保存点机制在处理时不会创建一个全新的事务而是在外层事务中创建一个保存点在执行子事务时数据库会记录此保存点之前的状态如果子事务异常可以回滚到该保存点但如果外层事务回滚整个事务上下文都会被回滚包括所有保存点底层执行逻辑伪源码在中在当前事务中创建保存点执行子事务逻辑当外层事务回滚时会调用这会直接撤销整个连接上的所有修改包括之前的保存点与的对比非常关键传播类型是否共享事务连接外层回滚对子事务影响子事务异常对外层影响实现机制同一事务连接必然回滚可回滚到保存点独立连接不影响独立提交新事务独立连接因此只有会被外层事务联动回滚而是完全独立的事务外层失败不会影响它举个实际例子外层事务异常执行结果创建了一个保存点当外层抛出异常回滚整个事务包括保存点所以的数据也被回滚如果改成执行结果外层失败内层事务因为是新事务已经独立提交外层事务回滚不会影响它依旧提交成功三总结逻辑面试可复述版嵌套事务与外层事务共用同一连接通过实现局部回滚外层事务回滚时整个事务链包括子事务保存点都会被回滚子事务回滚不会影响外层事务外层事务仍可继续执行与之相反启动一个全新事务互不影响四常见追问与陷阱追问答案数据库是否必须支持是必须使用引擎嵌套事务在不同事务管理器中会怎样不支持会退化为普通嵌套事务在自调用中失效的原因同类内部方法不会经过代理事务不生效异步任务中嵌套事务是否生效不会生效因为线程切换导致事务上下文丢失五高分总结背诵模板嵌套事务与外层事务共用同一个连接基于实现当外层事务回滚时所有保存点都会被清除因此子事务必然回滚当子事务回滚时只会回滚到保存点不影响外层事务与之不同的是会新建一个独立事务外层回滚不会影响内层嵌套事务适用于局部失败可恢复的业务逻辑例如批处理分步保存局部回滚等场景面试题事务的实现原理底层机制一面试官考察点考察开发者是否理解是如何生效的是如何代理事务方法的如何在方法执行前后开启提交或回滚事务事务传播回滚机制与数据库连接控制的关系二秒速答面试速答版的事务实现原理是基于动态代理事务管理器当方法被注解标记时会在运行时为该类生成代理对象在方法执行前后通过拦截器进行拦截在方法执行前开启事务正常执行则提交事务发生异常则回滚事务事务的具体操作开启提交回滚由调用底层数据库的连接对象完成三事务的整体执行流程事务的核心流程如下方法调用代理拦截拦截器获取事务状态判断传播行为调用事务管理器开启事务执行业务方法正常结束提交事务发生异常回滚事务四核心组件与职责划分组件作用关键类声明事务边界注解驱动拦截器负责事务增强事务增强逻辑核心类控制开启提交回滚事务管理器接口核心事务操作定义基于的事务管理器实现真正调用数据库连接控制管理线程绑定的事务资源用保存连接与状态五深入底层实现源码级分析动态代理机制当容器启动时会扫描注解的并通过解析注解元信息为这些创建代理对象若实现接口使用动态代理否则使用子类代理代理对象的方法调用会被拦截事务拦截器核心逻辑简化版获取事务属性获取事务管理器开启事务执行业务方法正常则提交事务异常则回滚事务在方法执行前开启事务在方法结束后决定提交或回滚所有逻辑都在拦截器中完成事务管理器通过提供统一的事务接口常见实现实现类说明数据源事务最常用实现实现分布式事务层事务控制以为例开启事务提交事务回滚事务实际是通过操作的自动提交模式来控制事务边界线程绑定机制事务是线程级别的每个事务在当前线程中绑定一个数据库连接当方法嵌套调用时通过获取当前事务状态从而实现事务传播行为因此在使用多线程或异步执行时事务上下文无法传播事务会失效六事务传播机制支持种传播行为枚举核心在于当前线程是否存在事务类型含义是否新建事务有事务加入无则新建否默认始终新建新事务挂起当前事务是同连接创建保存点否有事务则加入无则非事务执行否非事务执行挂起事务否必须在事务中否则异常否禁止事务有事务则异常否七事务回滚机制回滚条件默认情况下仅在发生或时才回滚不会触发回滚可通过注解配置改变回滚流程源码调用的回滚方法实现真正的数据库回滚八事务失效的常见原因面试高频陷阱场景原因解决方案同类内部方法调用未经过代理通过调用异步方法中执行新线程无事务上下文需手动传递事务或使用分布式事务异常被捕获未抛出感知不到异常手动方法非无法代理必须为事务管理器错误不同数据源未绑定指定正确的九性能与设计分析特性说明事务粒度方法级别通过代理增强性能优化使用代理和连接缓存减少开销线程安全基于实现可扩展性自定义事务拦截器注解传播机制十一分钟高分总结可背诵的事务实现是基于动态代理与的当调用带的方法时创建代理对象并在方法执行前后进行增强前置增强获取连接开启事务后置增强提交或回滚事务实际的事务控制是通过调用的与完成事务信息通过绑定到当前线程实现事务传播这种机制让我们能用简单注解实现复杂的事务控制逻辑同时保持解耦与灵活性面试题定时任务失败了如何重试一面试官意图通过这个问题考察候选人是否了解的底层线程模型明白默认的失败处理逻辑能设计出可自动重试可监控可恢复的任务执行机制能权衡可靠性性能的实现方式二基础回答秒面试速答版本身不会自动重试失败任务如果定时任务执行过程中抛出异常默认只是记录日志并结束执行不会重试若要实现重试机制可以通过以下几种方式实现在任务内部使用重试逻辑使用的注解结合实现自动重试使用或任务表做失败补偿机制手动调度重试使用分布式任务调度框架如实现持久化与重试管理三执行原理的核心组件为默认使用执行流程注解解析注册任务提交到线程池执行任务执行抛异常时线程终止不会重试默认线程池不具备任务重试与失败恢复能力如果任务在执行过程中发生异常下次执行会按照表达式正常触发但当前这次任务不会重试四任务失败的常见原因失败原因说明典型表现业务异常未捕获异常中断执行任务提前结束线程池被阻塞核心线程用尽后续任务延迟甚至跳过表达式错误执行计划丢失任务未执行内存溢出死锁线程无法释放所有任务停滞网络超时外部接口失败重试逻辑失效五任务失败后的重试策略实现手动重试循环适用于简单任务或接口调用失败场景调用外部接口成功则退出第次任务执行失败任务重试次仍失败记录数据库等待人工处理优点简单直接缺点代码冗余不可配置重试粒度粗使用注解是官方推荐的声明式重试机制可以优雅地为定时任务增加自动重试功能示例代码启用重试机制执行定时任务可能抛异常任务重试次后仍失败进入补偿逻辑异常可记录数据库或发告警通知模拟失败原理会为该方法生成代理对象调用时若抛出异常会根据配置自动重试最终失败后调用标注的方法进行补偿使用消息队列重试业务补偿机制如果任务结果很重要如订单同步账务对账建议采用数据库状态表的方式实现可靠重试思路将任务执行状态记录到数据库失败时发送到重试队列消费端监听并执行重试任务成功则更新状态优点持久化可追踪可分布式部署使用分布式调度框架如果任务较多需要监控与可视化重试推荐使用或例如提供了可在任务失败后重新触发支持六最佳实践建议工程级场景建议方案简单任务手动重试中等复杂度任务核心任务对外接口补偿表分布式系统使用分布式调度框架高可用任务增加监控告警七常见追问与高分回答追问如果任务失败后整个应用重启了怎么办是内存级调度重启后任务状态会丢失若需任务状态持久化建议使用等可存储任务执行记录的调度器追问任务执行中抛出异常会停止后续执行吗不会默认只记录日志下一次任务仍会根据继续执行但如果线程池被阻塞或线程异常退出可能导致任务跳过或延迟追问支持集群模式下避免重复执行吗默认不支持需要借助分布式锁实现单节点任务执行八性能分析与扩展话题方面内容性能影响重试次数多会增加线程占用应控制最大次数与等待时间可观察性建议结合日志与任务表追踪任务状态幂等性任务必须具备幂等特性否则重试可能导致重复操作监控方案结合监控任务执行率与失败率九总结可背诵版默认不具备自动重试机制当任务执行失败时只会打印异常日志不会重新执行若要实现可靠重试可通过以下方式手动重试使用注解自动重试补偿机制或分布式调度框架在工程中还应配合幂等性设计失败记录与告警分布式锁控制执行唯一性',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2025-11-17 16:54:36',
  postMainColor: '',
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#18171d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#f7f9fe')
        }
      }
      const t = saveToLocal.get('theme')
    
          const isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
          const isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
          const isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
          const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

          if (t === undefined) {
            if (isLightMode) activateLightMode()
            else if (isDarkMode) activateDarkMode()
            else if (isNotSpecified || hasNoSupport) {
              const now = new Date()
              const hour = now.getHours()
              const isNight = hour <= 6 || hour >= 18
              isNight ? activateDarkMode() : activateLightMode()
            }
            window.matchMedia('(prefers-color-scheme: dark)').addListener(e => {
              if (saveToLocal.get('theme') === undefined) {
                e.matches ? activateDarkMode() : activateLightMode()
              }
            })
          } else if (t === 'light') activateLightMode()
          else activateDarkMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.3.0"></head><body data-type="anzhiyu"><div id="web_bg"></div><div id="an_music_bg"></div><div id="loading-box" onclick="document.getElementById(&quot;loading-box&quot;).classList.add(&quot;loaded&quot;)"><div class="loading-bg"><img class="loading-img nolazyload" alt="加载头像" src="https://s2.loli.net/2022/11/07/QVWvrnAsuGxelbS.jpg"/><div class="loading-image-dot"></div></div></div><script>const preloader = {
  endLoading: () => {
    document.getElementById('loading-box').classList.add("loaded");
  },
  initLoading: () => {
    document.getElementById('loading-box').classList.remove("loaded")
  }
}
window.addEventListener('load',()=> { preloader.endLoading() })
setTimeout(function(){preloader.endLoading();},10000)

if (true) {
  document.addEventListener('pjax:send', () => { preloader.initLoading() })
  document.addEventListener('pjax:complete', () => { preloader.endLoading() })
}</script><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.1.10/progress_bar/progress_bar.css"/><script async="async" src="https://cdn.cbd.int/pace-js@1.2.4/pace.min.js" data-pace-options="{ &quot;restartOnRequestAfter&quot;:false,&quot;eventLag&quot;:false}"></script><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><div id="nav-group"><span id="blog_name"><a id="site-name" href="/" accesskey="h"><div class="title">Wsk Blog</div><i class="anzhiyufont anzhiyu-icon-house-chimney"></i></a></span><div class="mask-name-container"><div id="name-container"><a id="page-name" href="javascript:anzhiyu.scrollToDest(0, 500)">PAGE_NAME</a></div></div><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 文章</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/archives/"><i class="anzhiyufont anzhiyu-icon-box-archive faa-tada" style="font-size: 0.9em;"></i><span> 隧道</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/categories/"><i class="anzhiyufont anzhiyu-icon-shapes faa-tada" style="font-size: 0.9em;"></i><span> 分类</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/tags/"><i class="anzhiyufont anzhiyu-icon-tags faa-tada" style="font-size: 0.9em;"></i><span> 标签</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 友链</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/link/"><i class="anzhiyufont anzhiyu-icon-link faa-tada" style="font-size: 0.9em;"></i><span> 友人帐</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/fcircle/"><i class="anzhiyufont anzhiyu-icon-artstation faa-tada" style="font-size: 0.9em;"></i><span> 朋友圈</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/comments/"><i class="anzhiyufont anzhiyu-icon-envelope faa-tada" style="font-size: 0.9em;"></i><span> 留言板</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 我的</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/music/?id=2898229193&amp;server=netease"><i class="anzhiyufont anzhiyu-icon-music faa-tada" style="font-size: 0.9em;"></i><span> 音乐馆</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/album/"><i class="anzhiyufont anzhiyu-icon-images faa-tada" style="font-size: 0.9em;"></i><span> 相册集</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/air-conditioner/"><i class="anzhiyufont anzhiyu-icon-fan faa-tada" style="font-size: 0.9em;"></i><span> 小空调</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 关于</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/about/"><i class="anzhiyufont anzhiyu-icon-paper-plane faa-tada" style="font-size: 0.9em;"></i><span> 关于本人</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/essay/"><i class="anzhiyufont anzhiyu-icon-lightbulb faa-tada" style="font-size: 0.9em;"></i><span> 闲言碎语</span></a></li></ul></div></div></div><div id="nav-right"><div class="nav-button" id="randomPost_button"><a class="site-page" onclick="toRandomPost()" title="随机前往一个文章" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-dice"></i></a></div><input id="center-console" type="checkbox"/><label class="widget" for="center-console" title="中控台" onclick="anzhiyu.switchConsole();"><i class="left"></i><i class="widget center"></i><i class="widget right"></i></label><div id="console"><div class="console-card-group-reward"><ul class="reward-all console-card"><li class="reward-item"><a href="/./img/wechat.jpg" target="_blank"><img class="post-qr-code-img" alt="微信" src="/./img/wechat.jpg"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="/./img/alipay.jpg" target="_blank"><img class="post-qr-code-img" alt="支付宝" src="/./img/alipay.jpg"/></a><div class="post-qr-code-desc">支付宝</div></li></ul></div><div class="console-card-group"><div class="console-card-group-left"><div class="console-card" id="card-newest-comments"><div class="card-content"><div class="author-content-item-tips">互动</div><span class="author-content-item-title"> 最新评论</span></div><div class="aside-list"><span>正在加载中...</span></div></div></div><div class="console-card-group-right"><div class="console-card tags"><div class="card-content"><div class="author-content-item-tips">兴趣点</div><span class="author-content-item-title">寻找你感兴趣的领域</span><div class="card-tags"><div class="item-headline"></div><div class="card-tag-cloud"><a href="/tags/AOP/" style="font-size: 1.05rem;">AOP<sup>2</sup></a><a href="/tags/IO/" style="font-size: 1.05rem;">IO<sup>1</sup></a><a href="/tags/IOC/" style="font-size: 1.05rem;">IOC<sup>2</sup></a><a href="/tags/JVM/" style="font-size: 1.05rem;">JVM<sup>1</sup></a><a href="/tags/JVM%E8%B0%83%E4%BC%98/" style="font-size: 1.05rem;">JVM调优<sup>1</sup></a><a href="/tags/java%E5%90%8E%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%B8%88/" style="font-size: 1.05rem;">java后端工程师<sup>1</sup></a><a href="/tags/java%E5%9F%BA%E7%A1%80/" style="font-size: 1.05rem;">java基础<sup>1</sup></a><a href="/tags/mysql/" style="font-size: 1.05rem;">mysql<sup>1</sup></a><a href="/tags/%E4%BC%98%E6%83%A0%E5%8D%B7/" style="font-size: 1.05rem;">优惠卷<sup>1</sup></a><a href="/tags/%E5%95%86%E5%93%81/" style="font-size: 1.05rem;">商品<sup>1</sup></a><a href="/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/" style="font-size: 1.05rem;">多线程<sup>1</sup></a><a href="/tags/%E5%B9%B6%E5%8F%91/" style="font-size: 1.05rem;">并发<sup>1</sup></a><a href="/tags/%E5%BA%8F%E5%88%97%E5%8C%96/" style="font-size: 1.05rem;">序列化<sup>1</sup></a><a href="/tags/%E5%BC%82%E5%B8%B8/" style="font-size: 1.05rem;">异常<sup>1</sup></a><a href="/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/" style="font-size: 1.05rem;">数据库<sup>1</sup></a><a href="/tags/%E6%B3%9B%E5%9E%8B/" style="font-size: 1.05rem;">泛型<sup>1</sup></a><a href="/tags/%E7%94%B5%E5%95%86/" style="font-size: 1.05rem;">电商<sup>1</sup></a><a href="/tags/%E7%94%B5%E5%95%86-%E8%AE%A2%E5%8D%95/" style="font-size: 1.05rem;">电商,订单<sup>1</sup></a><a href="/tags/%E7%A7%92%E6%9D%80/" style="font-size: 1.05rem;">秒杀<sup>1</sup></a><a href="/tags/%E7%AE%80%E5%8E%86/" style="font-size: 1.05rem;">简历<sup>1</sup></a><a href="/tags/%E8%87%AA%E5%8A%A8%E8%A3%85%E9%85%8D/" style="font-size: 1.05rem;">自动装配<sup>1</sup></a><a href="/tags/%E8%AE%A2%E5%8D%95/" style="font-size: 1.05rem;">订单<sup>1</sup></a><a href="/tags/%E8%B6%85%E5%8D%96-%E5%BA%93%E5%AD%98/" style="font-size: 1.05rem;">超卖 , 库存<sup>1</sup></a><a href="/tags/%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/" style="font-size: 1.05rem;">集合框架<sup>1</sup></a></div></div><hr/></div></div><div class="console-card history"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-box-archiv"></i><span>文章</span></div><div class="card-archives"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-archive"></i><span>归档</span></div><ul class="card-archive-list"><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2025/11/"><span class="card-archive-list-date">十一月 2025</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">12</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2025/10/"><span class="card-archive-list-date">十月 2025</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">4</span><span>篇</span></div></a></li></ul></div><hr/></div></div></div><div class="button-group"><div class="console-btn-item"><a class="darkmode_switchbutton" title="显示模式切换" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-moon"></i></a></div><div class="console-btn-item" id="consoleHideAside" onclick="anzhiyu.hideAsideBtn()" title="边栏显示控制"><a class="asideSwitch"><i class="anzhiyufont anzhiyu-icon-arrows-left-right"></i></a></div><div class="console-btn-item on" id="consoleCommentBarrage" onclick="anzhiyu.switchCommentBarrage()" title="热评开关"><a class="commentBarrage"><i class="anzhiyufont anzhiyu-icon-message"></i></a></div><div class="console-btn-item" id="consoleMusic" onclick="anzhiyu.musicToggle()" title="音乐开关"><a class="music-switch"><i class="anzhiyufont anzhiyu-icon-music"></i></a></div></div><div class="console-mask" onclick="anzhiyu.hideConsole()" href="javascript:void(0);"></div></div><div class="nav-button" id="nav-totop"><a class="totopbtn" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i><span id="percent" onclick="anzhiyu.scrollToDest(0,500)">0</span></a></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);" title="切换"><i class="anzhiyufont anzhiyu-icon-bars"></i></a></div></div></div></nav><div id="post-info"><div id="post-firstinfo"><div class="meta-firstline"><a class="post-meta-original">原创</a><span class="post-meta-categories"><span class="post-meta-separator"></span><i class="anzhiyufont anzhiyu-icon-inbox post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E9%9D%A2%E8%AF%95%E9%A2%98/" itemprop="url">面试题</a></span><span class="article-meta tags"><a class="article-meta__tags" href="/tags/IOC/" tabindex="-1" itemprop="url"> <span> <i class="anzhiyufont anzhiyu-icon-hashtag"></i>IOC</span></a><a class="article-meta__tags" href="/tags/AOP/" tabindex="-1" itemprop="url"> <span> <i class="anzhiyufont anzhiyu-icon-hashtag"></i>AOP</span></a></span></div></div><h1 class="post-title" itemprop="name headline">Spring</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="anzhiyufont anzhiyu-icon-calendar-days post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" itemprop="dateCreated datePublished" datetime="2025-11-03T09:31:36.000Z" title="发表于 2025-11-03 17:31:36">2025-11-03</time><span class="post-meta-separator"></span><i class="anzhiyufont anzhiyu-icon-history post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" itemprop="dateCreated datePublished" datetime="2025-11-17T08:54:36.532Z" title="更新于 2025-11-17 16:54:36">2025-11-17</time></span></div><div class="meta-secondline"><span class="post-meta-separator"></span><span class="post-meta-pv-cv" id="" data-flag-title="Spring"><i class="anzhiyufont anzhiyu-icon-fw-eye post-meta-icon"></i><span class="post-meta-label" title="阅读量">阅读量:</span><span id="busuanzi_value_page_pv"><i class="anzhiyufont anzhiyu-icon-spinner anzhiyu-spin"></i></span></span><span class="post-meta-separator">       </span><span class="post-meta-position" title="作者IP属地为新乡"><i class="anzhiyufont anzhiyu-icon-location-dot"></i>新乡</span><span class="post-meta-separator"></span><span class="post-meta-commentcount"><i class="anzhiyufont anzhiyu-icon-comments post-meta-icon"></i><span class="post-meta-label">评论数:</span><a href="/posts/6c92115f.html#post-comment" itemprop="discussionUrl"><span class="valine-comment-count" data-xid="/posts/6c92115f.html" itemprop="commentCount"><i class="anzhiyufont anzhiyu-icon-spinner anzhiyu-spin"></i></span></a></span></div></div></div><section class="main-hero-waves-area waves-area"><svg class="waves-svg" xmlns="http://www.w3.org/2000/svg" xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M -160 44 c 30 0 58 -18 88 -18 s 58 18 88 18 s 58 -18 88 -18 s 58 18 88 18 v 44 h -352 Z"></path></defs><g class="parallax"><use href="#gentle-wave" x="48" y="0"></use><use href="#gentle-wave" x="48" y="3"></use><use href="#gentle-wave" x="48" y="5"></use><use href="#gentle-wave" x="48" y="7"></use></g></svg></section><div id="post-top-cover"><img class="nolazyload" id="post-top-bg" src="https://s2.loli.net/2025/10/23/g4UkwyDri9BWZtE.jpg?_r_=95828ad5-7d6d-d56f-f27a-6610327ee6f0"></div></header><main id="blog-container"><div class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container" itemscope itemtype="https://wsk0404.github.io/posts/6c92115f.html"><header><a class="post-meta-categories" href="/categories/%E9%9D%A2%E8%AF%95%E9%A2%98/" itemprop="url">面试题</a><a href="/tags/IOC/" tabindex="-1" itemprop="url">IOC</a><a href="/tags/AOP/" tabindex="-1" itemprop="url">AOP</a><h1 id="CrawlerTitle" itemprop="name headline">Spring</h1><span itemprop="author" itemscope itemtype="http://schema.org/Person">Wsk</span><time itemprop="dateCreated datePublished" datetime="2025-11-03T09:31:36.000Z" title="发表于 2025-11-03 17:31:36">2025-11-03</time><time itemprop="dateCreated datePublished" datetime="2025-11-17T08:54:36.532Z" title="更新于 2025-11-17 16:54:36">2025-11-17</time></header><h1 id="🎯-面试题：聊聊你对-Spring-框架的理解"><a href="#🎯-面试题：聊聊你对-Spring-框架的理解" class="headerlink" title="🎯 面试题：聊聊你对 Spring 框架的理解"></a>🎯 面试题：聊聊你对 Spring 框架的理解</h1><hr>
<h2 id="一、面试官考察点"><a href="#一、面试官考察点" class="headerlink" title="一、面试官考察点"></a>一、面试官考察点</h2><ol>
<li>是否理解 <strong>Spring 的核心思想与设计模式</strong>；</li>
<li>是否熟悉 <strong>IOC（控制反转）与 AOP（面向切面编程）</strong> 原理；</li>
<li>是否了解 <strong>Spring 的核心模块</strong>；</li>
<li>是否能结合项目场景（如 WMS 系统）说明 <strong>Spring 的使用价值</strong>；</li>
<li>是否能提到 <strong>扩展机制与性能优化</strong>。</li>
</ol>
<hr>
<h2 id="二、Spring-框架简介"><a href="#二、Spring-框架简介" class="headerlink" title="二、Spring 框架简介"></a>二、Spring 框架简介</h2><blockquote>
<p><strong>Spring 是一个开源的轻量级 Java 企业级开发框架</strong>，用于简化企业级应用的开发与维护。<br> 它通过 IOC 和 AOP 两大核心机制，帮助开发者实现 <strong>低耦合、高内聚、可扩展、易测试的架构</strong>。</p>
</blockquote>
<ul>
<li>创始人：Rod Johnson</li>
<li>初衷：解决企业级开发中对象依赖复杂、配置繁琐、测试困难的问题</li>
<li>核心目标：<strong>让 Java EE 开发更简单</strong></li>
</ul>
<hr>
<h2 id="三、Spring-的核心理念"><a href="#三、Spring-的核心理念" class="headerlink" title="三、Spring 的核心理念"></a>三、Spring 的核心理念</h2><h3 id="1️⃣-IOC（Inversion-of-Control）控制反转"><a href="#1️⃣-IOC（Inversion-of-Control）控制反转" class="headerlink" title="1️⃣ IOC（Inversion of Control）控制反转"></a>1️⃣ IOC（Inversion of Control）控制反转</h3><p><strong>核心思想</strong>：对象的创建与依赖关系的管理不再由开发者手动完成，而是交由 Spring 容器统一管理。</p>
<ul>
<li><p><strong>传统方式</strong>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">UserService</span> <span class="variable">userService</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UserServiceImpl</span>();</span><br><span class="line"><span class="type">OrderService</span> <span class="variable">orderService</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OrderServiceImpl</span>(userService);</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>Spring IOC 容器管理方式</strong>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OrderService</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserService userService;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p>📌 <strong>本质</strong>：通过 <strong>反射 + BeanDefinition + 容器初始化</strong> 实现对象创建与依赖注入。</p>
<p>📌 <strong>优点</strong>：降低模块间耦合度、提升代码可维护性与可测试性。</p>
<hr>
<h3 id="2️⃣-AOP（Aspect-Oriented-Programming）面向切面编程"><a href="#2️⃣-AOP（Aspect-Oriented-Programming）面向切面编程" class="headerlink" title="2️⃣ AOP（Aspect-Oriented Programming）面向切面编程"></a>2️⃣ AOP（Aspect-Oriented Programming）面向切面编程</h3><p><strong>核心思想</strong>：将日志、事务、安全等横切关注点从业务逻辑中分离，通过切面统一管理。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LogAspect</span> &#123;</span><br><span class="line">    <span class="meta">@Before(&quot;execution(* com.wms.service.*.*(..))&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">logBefore</span><span class="params">(JoinPoint jp)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;开始调用方法：&quot;</span> + jp.getSignature().getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>📌 <strong>底层实现</strong>：</p>
<ul>
<li>JDK 动态代理（接口）</li>
<li>CGLIB 动态代理（类）</li>
</ul>
<p>📌 <strong>应用场景</strong>：</p>
<ul>
<li>日志记录</li>
<li>事务控制</li>
<li>性能监控</li>
<li>权限校验</li>
</ul>
<hr>
<h2 id="四、Spring-的核心模块"><a href="#四、Spring-的核心模块" class="headerlink" title="四、Spring 的核心模块"></a>四、Spring 的核心模块</h2><table>
<thead>
<tr>
<th>模块</th>
<th>主要功能</th>
</tr>
</thead>
<tbody><tr>
<td><strong>Spring Core</strong></td>
<td>核心容器，提供 BeanFactory 和 ApplicationContext</td>
</tr>
<tr>
<td><strong>Spring AOP</strong></td>
<td>提供面向切面编程支持</td>
</tr>
<tr>
<td><strong>Spring Context</strong></td>
<td>IOC 容器上下文管理</td>
</tr>
<tr>
<td><strong>Spring JDBC &#x2F; ORM</strong></td>
<td>数据访问抽象层，整合 MyBatis、Hibernate</td>
</tr>
<tr>
<td><strong>Spring MVC</strong></td>
<td>Web 层框架，提供请求分发与视图解析</td>
</tr>
<tr>
<td><strong>Spring Test</strong></td>
<td>单元测试支持，集成 JUnit</td>
</tr>
<tr>
<td><strong>Spring Boot</strong></td>
<td>自动化配置，简化项目搭建</td>
</tr>
<tr>
<td><strong>Spring Cloud</strong></td>
<td>微服务生态，服务注册、配置、熔断、网关</td>
</tr>
</tbody></table>
<hr>
<h2 id="五、Spring-框架常用设计模式"><a href="#五、Spring-框架常用设计模式" class="headerlink" title="五、Spring 框架常用设计模式"></a>五、Spring 框架常用设计模式</h2><table>
<thead>
<tr>
<th>模式</th>
<th>应用场景</th>
</tr>
</thead>
<tbody><tr>
<td>工厂模式</td>
<td>BeanFactory &#x2F; ApplicationContext 创建 Bean</td>
</tr>
<tr>
<td>单例模式</td>
<td>Bean 默认单例管理</td>
</tr>
<tr>
<td>代理模式</td>
<td>AOP 底层实现</td>
</tr>
<tr>
<td>模板方法模式</td>
<td>JdbcTemplate &#x2F; RestTemplate</td>
</tr>
<tr>
<td>观察者模式</td>
<td>ApplicationEvent &#x2F; Listener</td>
</tr>
<tr>
<td>适配器模式</td>
<td>HandlerAdapter 处理控制器调用</td>
</tr>
</tbody></table>
<hr>
<h2 id="六、Spring-在-WMS-系统中的应用（项目实战）"><a href="#六、Spring-在-WMS-系统中的应用（项目实战）" class="headerlink" title="六、Spring 在 WMS 系统中的应用（项目实战）"></a>六、Spring 在 WMS 系统中的应用（项目实战）</h2><h3 id="✅-入库模块示例"><a href="#✅-入库模块示例" class="headerlink" title="✅ 入库模块示例"></a>✅ 入库模块示例</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InboundService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> InboundRepository inboundRepository;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Transactional</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">processInbound</span><span class="params">(InboundOrder order)</span> &#123;</span><br><span class="line">        inboundRepository.save(order);</span><br><span class="line">        log.info(<span class="string">&quot;入库单保存成功：&quot;</span> + order.getOrderNo());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>说明</strong>：</p>
<ul>
<li>IOC 管理 <code>InboundRepository</code> 注入</li>
<li>AOP 管理 <code>@Transactional</code> 事务</li>
<li>解耦业务逻辑与资源管理</li>
<li>提升系统的可维护性与扩展性</li>
</ul>
<hr>
<h2 id="七、性能与扩展机制"><a href="#七、性能与扩展机制" class="headerlink" title="七、性能与扩展机制"></a>七、性能与扩展机制</h2><ol>
<li><strong>Bean 缓存机制</strong>：单例 Bean 仅初始化一次</li>
<li><strong>懒加载（lazy-init）</strong>：在第一次调用时才初始化</li>
<li><strong>三级缓存机制</strong>（防止循环依赖）：<ul>
<li>singletonObjects</li>
<li>earlySingletonObjects</li>
<li>singletonFactories</li>
</ul>
</li>
<li><strong>扩展接口</strong>：<ul>
<li>BeanPostProcessor</li>
<li>BeanFactoryPostProcessor</li>
<li>ApplicationListener</li>
</ul>
</li>
</ol>
<hr>
<h2 id="八、面试高频追问"><a href="#八、面试高频追问" class="headerlink" title="八、面试高频追问"></a>八、面试高频追问</h2><table>
<thead>
<tr>
<th>追问</th>
<th>高分回答</th>
</tr>
</thead>
<tbody><tr>
<td>IOC 容器的核心类？</td>
<td>ApplicationContext，负责 Bean 的生命周期管理</td>
</tr>
<tr>
<td>Spring 如何解决循环依赖？</td>
<td>通过三级缓存机制提早暴露单例 Bean 引用</td>
</tr>
<tr>
<td>AOP 底层是如何实现的？</td>
<td>使用 JDK 动态代理或 CGLIB 动态代理生成代理对象</td>
</tr>
<tr>
<td>@Autowired 和 @Resource 的区别？</td>
<td>@Autowired 按类型注入，@Resource 按名称注入</td>
</tr>
<tr>
<td>Spring Bean 的生命周期？</td>
<td>实例化 → 属性注入 → 初始化（init）→ 使用 → 销毁（destroy）</td>
</tr>
<tr>
<td>Spring Boot 相比传统 Spring 有哪些优势？</td>
<td>自动装配、内嵌容器、约定优于配置、快速开发微服务</td>
</tr>
</tbody></table>
<hr>
<h2 id="九、高分总结模板（可直接背诵）"><a href="#九、高分总结模板（可直接背诵）" class="headerlink" title="九、高分总结模板（可直接背诵）"></a>九、高分总结模板（可直接背诵）</h2><blockquote>
<p>Spring 是一个轻量级企业级开发框架，以 IOC 和 AOP 为核心。<br> 通过 IOC 实现对象解耦与依赖注入，AOP 实现横切关注点分离。<br> 框架模块包括 Core、Context、AOP、MVC、JDBC、Boot、Cloud 等。<br> 在实际开发中，我常使用 Spring 管理 Bean 生命周期，结合 AOP 做日志、事务控制。<br> 在 WMS 系统中，通过 Spring Boot + Spring Data 实现模块解耦与快速开发。<br> Spring 的设计思想体现了面向接口编程和高内聚低耦合的架构原则。</p>
</blockquote>
<h1 id="🎯-面试题：-Autowired-和-Resource-有什么区别？"><a href="#🎯-面试题：-Autowired-和-Resource-有什么区别？" class="headerlink" title="🎯 面试题：@Autowired 和 @Resource 有什么区别？"></a>🎯 面试题：@Autowired 和 @Resource 有什么区别？</h1><hr>
<h2 id="一、面试官考察点-1"><a href="#一、面试官考察点-1" class="headerlink" title="一、面试官考察点"></a>一、面试官考察点</h2><ol>
<li>是否理解 <strong>Spring IOC 容器的依赖注入原理</strong>；</li>
<li>是否清楚两者的 <strong>注入方式（byType &#x2F; byName）</strong> 区别；</li>
<li>是否了解 <strong>注解的来源（Spring 与 JSR-250）</strong>；</li>
<li>能否结合实际开发（如 WMS 系统模块注入）说明差异；</li>
<li>是否理解底层源码原理与优先级解析顺序。</li>
</ol>
<hr>
<h2 id="二、核心速答（30-秒答题模板）"><a href="#二、核心速答（30-秒答题模板）" class="headerlink" title="二、核心速答（30 秒答题模板）"></a>二、核心速答（30 秒答题模板）</h2><blockquote>
<p><code>@Autowired</code> 是 Spring 提供的注解，按 <strong>类型（byType）</strong> 自动注入，<br> <code>@Resource</code> 是 JSR-250（Java 标准）注解，按 <strong>名称（byName）</strong> 注入。</p>
<p>当容器中存在多个同类型 Bean 时，<code>@Autowired</code> 可配合 <code>@Qualifier</code> 指定 Bean 名称，<br> 而 <code>@Resource</code> 默认优先按名称查找，找不到再按类型查找。</p>
<p>简而言之：</p>
<ul>
<li><code>@Autowired</code>：Spring 专属，按类型；</li>
<li><code>@Resource</code>：Java 标准，按名称。</li>
</ul>
</blockquote>
<hr>
<h2 id="三、详细区别对比表"><a href="#三、详细区别对比表" class="headerlink" title="三、详细区别对比表"></a>三、详细区别对比表</h2><table>
<thead>
<tr>
<th>对比项</th>
<th>@Autowired</th>
<th>@Resource</th>
</tr>
</thead>
<tbody><tr>
<td>所属包</td>
<td><code>org.springframework.beans.factory.annotation.Autowired</code></td>
<td><code>javax.annotation.Resource</code></td>
</tr>
<tr>
<td>依赖来源</td>
<td>Spring 框架</td>
<td>JSR-250（Java 标准）</td>
</tr>
<tr>
<td>注入方式</td>
<td>按类型（byType）</td>
<td>按名称（byName）优先，再按类型</td>
</tr>
<tr>
<td>是否可与 @Qualifier 搭配</td>
<td>✅ 可用 @Qualifier 指定注入 Bean 名称</td>
<td>❌ 不能与 @Qualifier 联用</td>
</tr>
<tr>
<td>是否支持 required 属性</td>
<td>✅ 支持（<code>required=false</code> 可选注入）</td>
<td>❌ 不支持</td>
</tr>
<tr>
<td>是否支持构造方法注入</td>
<td>✅ 支持（推荐构造注入）</td>
<td>❌ 不支持</td>
</tr>
<tr>
<td>常见应用场景</td>
<td>SpringBoot &#x2F; Spring 应用</td>
<td>第三方集成、旧项目兼容</td>
</tr>
<tr>
<td>可移植性</td>
<td>Spring 特有，不通用</td>
<td>标准 JSR 注解，跨框架通用</td>
</tr>
</tbody></table>
<hr>
<h2 id="四、注入机制详解"><a href="#四、注入机制详解" class="headerlink" title="四、注入机制详解"></a>四、注入机制详解</h2><h3 id="✅-Autowired-注入流程（按类型）"><a href="#✅-Autowired-注入流程（按类型）" class="headerlink" title="✅ @Autowired 注入流程（按类型）"></a>✅ @Autowired 注入流程（按类型）</h3><p>Spring 启动时：</p>
<ol>
<li>扫描类上的 <code>@Autowired</code> 字段；</li>
<li>根据字段类型从 IOC 容器中查找 Bean；</li>
<li>如果存在多个同类型 Bean：<ul>
<li>若加了 <code>@Qualifier(&quot;beanName&quot;)</code> → 按名称匹配；</li>
<li>若未加 → 抛出异常；</li>
</ul>
</li>
<li>若找不到 → 报错（除非设置 <code>required=false</code>）。</li>
</ol>
<p><strong>示例：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InboundService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> InboundRepository inboundRepository; <span class="comment">// 按类型注入</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired(required = false)</span></span><br><span class="line">    <span class="keyword">private</span> LogService logService; <span class="comment">// 可选注入</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="✅-Resource-注入流程（按名称）"><a href="#✅-Resource-注入流程（按名称）" class="headerlink" title="✅ @Resource 注入流程（按名称）"></a>✅ @Resource 注入流程（按名称）</h3><p>Spring 解析时：</p>
<ol>
<li>先根据字段名匹配同名 Bean；</li>
<li>如果找不到，再按类型匹配；</li>
<li>若仍找不到 → 抛出异常。</li>
</ol>
<p><strong>示例：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InboundService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource(name = &quot;inboundRepositoryImpl&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> InboundRepository repository; <span class="comment">// 按名称注入</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>若不指定 <code>name</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Resource</span></span><br><span class="line"><span class="keyword">private</span> InboundRepository inboundRepository; <span class="comment">// 默认按字段名“inboundRepository”查找</span></span><br></pre></td></tr></table></figure>

<hr>
<h2 id="五、底层原理（源码层级）"><a href="#五、底层原理（源码层级）" class="headerlink" title="五、底层原理（源码层级）"></a>五、底层原理（源码层级）</h2><h3 id="🔍-Autowired"><a href="#🔍-Autowired" class="headerlink" title="🔍 @Autowired"></a>🔍 @Autowired</h3><ul>
<li>解析入口：<code>AutowiredAnnotationBeanPostProcessor</code></li>
<li>调用链：<br> <code>postProcessProperties()</code> → <code>DependencyDescriptor</code> → <code>doResolveDependency()</code></li>
<li>支持多种注入方式：<ul>
<li>字段注入（Field）</li>
<li>构造器注入（Constructor）</li>
<li>Setter 注入（Method）</li>
</ul>
</li>
</ul>
<h3 id="🔍-Resource"><a href="#🔍-Resource" class="headerlink" title="🔍 @Resource"></a>🔍 @Resource</h3><ul>
<li>解析入口：<code>CommonAnnotationBeanPostProcessor</code></li>
<li>基于 JSR-250 标准规范实现；</li>
<li>优先匹配名称，再匹配类型。</li>
</ul>
<hr>
<h2 id="六、实战场景（WMS-系统示例）"><a href="#六、实战场景（WMS-系统示例）" class="headerlink" title="六、实战场景（WMS 系统示例）"></a>六、实战场景（WMS 系统示例）</h2><p>在 WMS 系统中，若我们有多个入库策略实现类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">InboundStrategy</span> &#123;&#125;</span><br><span class="line"><span class="meta">@Service(&quot;fifoInboundStrategy&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FIFOInboundStrategy</span> <span class="keyword">implements</span> <span class="title class_">InboundStrategy</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service(&quot;lifoInboundStrategy&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LIFOInboundStrategy</span> <span class="keyword">implements</span> <span class="title class_">InboundStrategy</span> &#123;&#125;</span><br></pre></td></tr></table></figure>

<p>使用 <code>@Autowired</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="meta">@Qualifier(&quot;fifoInboundStrategy&quot;)</span></span><br><span class="line"><span class="keyword">private</span> InboundStrategy strategy;</span><br></pre></td></tr></table></figure>

<p>使用 <code>@Resource</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Resource(name = &quot;fifoInboundStrategy&quot;)</span></span><br><span class="line"><span class="keyword">private</span> InboundStrategy strategy;</span><br></pre></td></tr></table></figure>

<p>两种方式效果相同，但语义略有不同。</p>
<hr>
<h2 id="七、常见错误与陷阱"><a href="#七、常见错误与陷阱" class="headerlink" title="七、常见错误与陷阱"></a>七、常见错误与陷阱</h2><table>
<thead>
<tr>
<th>错误</th>
<th>原因</th>
<th>解决方案</th>
</tr>
</thead>
<tbody><tr>
<td>容器中存在多个同类型 Bean</td>
<td>按类型注入冲突</td>
<td>使用 <code>@Qualifier</code> 或指定 <code>@Resource(name=&quot;beanName&quot;)</code></td>
</tr>
<tr>
<td>@Resource 找不到 Bean</td>
<td>名称不匹配</td>
<td>确保 Bean 名称与字段名一致或指定 <code>name</code> 属性</td>
</tr>
<tr>
<td>想用构造方法注入但用 @Resource</td>
<td>@Resource 不支持构造注入</td>
<td>改用 <code>@Autowired</code></td>
</tr>
<tr>
<td>引入第三方包缺少 javax.annotation</td>
<td>JDK 9+ 移除了该包</td>
<td>手动添加依赖（<code>javax.annotation-api</code>）</td>
</tr>
</tbody></table>
<hr>
<h2 id="八、常见追问与答案"><a href="#八、常见追问与答案" class="headerlink" title="八、常见追问与答案"></a>八、常见追问与答案</h2><table>
<thead>
<tr>
<th>面试官问题</th>
<th>高分回答</th>
</tr>
</thead>
<tbody><tr>
<td>@Autowired 和 @Qualifier 如何配合使用？</td>
<td>@Autowired 按类型注入，@Qualifier 指定 Bean 名称解决多实现冲突。</td>
</tr>
<tr>
<td>Spring Boot 推荐哪种？</td>
<td>推荐使用 <code>@Autowired</code>（Spring 官方维护，更灵活且支持构造注入）。</td>
</tr>
<tr>
<td>@Resource 可不可以注入非 Spring Bean？</td>
<td>不行，注入对象必须由 IOC 容器管理。</td>
</tr>
<tr>
<td>构造方法注入的好处？</td>
<td>提高代码可测试性、线程安全、不可变性（推荐在实际项目中使用）。</td>
</tr>
</tbody></table>
<hr>
<h2 id="九、性能与工程实践建议"><a href="#九、性能与工程实践建议" class="headerlink" title="九、性能与工程实践建议"></a>九、性能与工程实践建议</h2><ol>
<li>✅ 推荐使用 <code>@Autowired</code>（官方推荐、灵活性高）；</li>
<li>✅ 结合构造注入（保证依赖不可变）；</li>
<li>✅ 在多实现类场景下，使用 <code>@Qualifier</code>；</li>
<li>✅ 在旧系统或跨框架时，可用 <code>@Resource</code> 保持兼容；</li>
<li>✅ 建议统一规范注入方式（团队约定：构造注入 + <code>@Autowired</code>）。</li>
</ol>
<hr>
<h2 id="🔟-一分钟高分总结（可背诵）"><a href="#🔟-一分钟高分总结（可背诵）" class="headerlink" title="🔟 一分钟高分总结（可背诵）"></a>🔟 一分钟高分总结（可背诵）</h2><blockquote>
<p><code>@Autowired</code> 是 Spring 提供的注解，按类型注入，可配合 <code>@Qualifier</code> 使用；<br> <code>@Resource</code> 属于 JSR-250 标准注解，按名称注入，找不到再按类型注入。</p>
<p>在实际项目中，Spring 官方更推荐使用 <code>@Autowired</code>，尤其在 Spring Boot 环境下，<br> 可支持构造方法注入、可选注入、懒加载等高级特性。<br> 而 <code>@Resource</code> 更适用于标准化项目或第三方框架集成场景。</p>
<p>简而言之：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Autowired —— 按类型；</span><br><span class="line">@Resource —— 按名称；</span><br></pre></td></tr></table></figure>
</blockquote>
<h1 id="🎯-面试题：谈谈你对-IOC-和-AOP-的理解"><a href="#🎯-面试题：谈谈你对-IOC-和-AOP-的理解" class="headerlink" title="🎯 面试题：谈谈你对 IOC 和 AOP 的理解"></a>🎯 面试题：谈谈你对 IOC 和 AOP 的理解</h1><hr>
<h2 id="一、面试官考察点-2"><a href="#一、面试官考察点-2" class="headerlink" title="一、面试官考察点"></a>一、面试官考察点</h2><ol>
<li>是否真正理解 Spring 的核心思想；</li>
<li>是否能从“原理 + 应用”层面解释 IOC 与 AOP；</li>
<li>是否能结合设计模式与项目实践说明两者的意义；</li>
<li>是否能回答常见追问（如 IOC 如何实现、AOP 底层基于什么）；</li>
<li>是否能将理论与实际项目（如 WMS 系统）结合。</li>
</ol>
<hr>
<h2 id="二、核心速答（30-秒模板）"><a href="#二、核心速答（30-秒模板）" class="headerlink" title="二、核心速答（30 秒模板）"></a>二、核心速答（30 秒模板）</h2><blockquote>
<p>Spring 框架的核心是 IOC 和 AOP。<br> IOC（Inversion of Control）是<strong>控制反转</strong>，即将对象的创建与依赖管理交给 Spring 容器，实现<strong>解耦与灵活配置</strong>。<br> AOP（Aspect-Oriented Programming）是<strong>面向切面编程</strong>，用于将日志、事务、安全等横切逻辑与业务逻辑分离，实现<strong>模块化增强</strong>。</p>
<p>简而言之：</p>
<ul>
<li>IOC 管理对象之间的“依赖关系”；</li>
<li>AOP 管理代码运行过程中的“横切逻辑”。</li>
</ul>
</blockquote>
<hr>
<h2 id="三、IOC（控制反转）详解"><a href="#三、IOC（控制反转）详解" class="headerlink" title="三、IOC（控制反转）详解"></a>三、IOC（控制反转）详解</h2><h3 id="1️⃣-定义"><a href="#1️⃣-定义" class="headerlink" title="1️⃣ 定义"></a>1️⃣ 定义</h3><p>IOC 是 <strong>Inversion of Control</strong> 的缩写，意为“控制反转”，<br> 即对象的控制权（创建、依赖注入、生命周期管理）从程序员手中“反转”到容器（Spring IOC 容器）中。</p>
<h3 id="2️⃣-核心思想"><a href="#2️⃣-核心思想" class="headerlink" title="2️⃣ 核心思想"></a>2️⃣ 核心思想</h3><blockquote>
<p>程序员只需声明需要什么依赖（通过注解或配置），Spring 容器自动创建、装配和管理它们。</p>
</blockquote>
<hr>
<h3 id="3️⃣-传统方式-vs-IOC-方式"><a href="#3️⃣-传统方式-vs-IOC-方式" class="headerlink" title="3️⃣ 传统方式 vs IOC 方式"></a>3️⃣ 传统方式 vs IOC 方式</h3><p><strong>传统方式（强耦合）：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OrderService</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">UserService</span> <span class="variable">userService</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UserService</span>(); <span class="comment">// 直接 new</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>IOC 容器方式（解耦）：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OrderService</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserService userService; <span class="comment">// 由 Spring 注入</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>📌 <strong>变化</strong>：</p>
<ul>
<li>对象由 Spring 容器创建；</li>
<li>依赖关系通过配置或注解自动注入；</li>
<li>模块之间从“硬编码依赖”变为“配置化依赖”。</li>
</ul>
<hr>
<h3 id="4️⃣-IOC-容器核心组件"><a href="#4️⃣-IOC-容器核心组件" class="headerlink" title="4️⃣ IOC 容器核心组件"></a>4️⃣ IOC 容器核心组件</h3><table>
<thead>
<tr>
<th>组件</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td><code>BeanFactory</code></td>
<td>最基础的 IOC 容器接口，延迟加载（懒加载）</td>
</tr>
<tr>
<td><code>ApplicationContext</code></td>
<td>BeanFactory 的子接口，支持国际化、事件机制、资源加载</td>
</tr>
<tr>
<td><code>AnnotationConfigApplicationContext</code></td>
<td>Spring Boot 常用注解驱动 IOC 容器</td>
</tr>
</tbody></table>
<hr>
<h3 id="5️⃣-实现原理（IOC-运行流程）"><a href="#5️⃣-实现原理（IOC-运行流程）" class="headerlink" title="5️⃣ 实现原理（IOC 运行流程）"></a>5️⃣ 实现原理（IOC 运行流程）</h3><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">1. 读取配置（XML / 注解） → 解析 BeanDefinition；</span><br><span class="line">2. 实例化 Bean 对象；</span><br><span class="line">3. 进行依赖注入（byType / byName）；</span><br><span class="line">4. 调用 BeanPostProcessor 处理；</span><br><span class="line">5. 初始化完成后放入单例池；</span><br><span class="line">6. 使用时由容器统一管理与销毁。</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="6️⃣-涉及的设计模式"><a href="#6️⃣-涉及的设计模式" class="headerlink" title="6️⃣ 涉及的设计模式"></a>6️⃣ 涉及的设计模式</h3><table>
<thead>
<tr>
<th>模式</th>
<th>在 IOC 中的体现</th>
</tr>
</thead>
<tbody><tr>
<td>工厂模式</td>
<td>BeanFactory 创建对象</td>
</tr>
<tr>
<td>单例模式</td>
<td>Bean 默认单例管理</td>
</tr>
<tr>
<td>代理模式</td>
<td>AOP 增强依赖注入后的 Bean</td>
</tr>
<tr>
<td>模板方法模式</td>
<td>Bean 生命周期管理</td>
</tr>
</tbody></table>
<hr>
<h3 id="7️⃣-在项目中的应用（WMS-示例）"><a href="#7️⃣-在项目中的应用（WMS-示例）" class="headerlink" title="7️⃣ 在项目中的应用（WMS 示例）"></a>7️⃣ 在项目中的应用（WMS 示例）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InboundService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> InboundRepository inboundRepository;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">processInbound</span><span class="params">()</span> &#123;</span><br><span class="line">        inboundRepository.save();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>📌 <strong>优点</strong>：</p>
<ul>
<li>解耦模块；</li>
<li>易于扩展；</li>
<li>便于单元测试；</li>
<li>实现组件可插拔架构。</li>
</ul>
<hr>
<h2 id="四、AOP（面向切面编程）详解"><a href="#四、AOP（面向切面编程）详解" class="headerlink" title="四、AOP（面向切面编程）详解"></a>四、AOP（面向切面编程）详解</h2><h3 id="1️⃣-定义-1"><a href="#1️⃣-定义-1" class="headerlink" title="1️⃣ 定义"></a>1️⃣ 定义</h3><p>AOP（Aspect-Oriented Programming）是一种<strong>编程范式</strong>，用于在不修改源代码的前提下，动态地增强程序功能。</p>
<h3 id="2️⃣-核心思想-1"><a href="#2️⃣-核心思想-1" class="headerlink" title="2️⃣ 核心思想"></a>2️⃣ 核心思想</h3><blockquote>
<p>将与业务逻辑无关但横切多个模块的功能（如日志、事务、安全）抽取出来，集中管理。</p>
</blockquote>
<hr>
<h3 id="3️⃣-典型场景"><a href="#3️⃣-典型场景" class="headerlink" title="3️⃣ 典型场景"></a>3️⃣ 典型场景</h3><table>
<thead>
<tr>
<th>场景</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>日志记录</td>
<td>统一记录方法调用日志</td>
</tr>
<tr>
<td>权限校验</td>
<td>在业务前做安全认证</td>
</tr>
<tr>
<td>性能监控</td>
<td>记录接口执行时间</td>
</tr>
<tr>
<td>异常处理</td>
<td>统一捕获并处理异常</td>
</tr>
<tr>
<td>事务管理</td>
<td>在方法执行前后控制事务</td>
</tr>
</tbody></table>
<hr>
<h3 id="4️⃣-核心概念"><a href="#4️⃣-核心概念" class="headerlink" title="4️⃣ 核心概念"></a>4️⃣ 核心概念</h3><table>
<thead>
<tr>
<th>名称</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>JoinPoint</td>
<td>程序执行的特定点（如方法调用）</td>
</tr>
<tr>
<td>Pointcut</td>
<td>切点，定义在哪些 JoinPoint 应用增强</td>
</tr>
<tr>
<td>Advice</td>
<td>通知，定义增强的具体逻辑（Before、After、Around）</td>
</tr>
<tr>
<td>Aspect</td>
<td>切面，Pointcut + Advice 的组合</td>
</tr>
<tr>
<td>Proxy</td>
<td>代理对象，通过 JDK&#x2F;CGLIB 生成</td>
</tr>
<tr>
<td>Weaving</td>
<td>将切面逻辑织入目标对象的过程</td>
</tr>
</tbody></table>
<hr>
<h3 id="5️⃣-示例：AOP-日志增强"><a href="#5️⃣-示例：AOP-日志增强" class="headerlink" title="5️⃣ 示例：AOP 日志增强"></a>5️⃣ 示例：AOP 日志增强</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LogAspect</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Before(&quot;execution(* com.wms.service.*.*(..))&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">logBefore</span><span class="params">(JoinPoint joinPoint)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;调用方法：&quot;</span> + joinPoint.getSignature().getName());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@AfterReturning(&quot;execution(* com.wms.service.*.*(..))&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">logAfter</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;方法执行结束&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>📌 效果：在所有 <code>com.wms.service</code> 包的方法执行前后自动打印日志，无需手动修改业务代码。</p>
<hr>
<h3 id="6️⃣-底层实现原理"><a href="#6️⃣-底层实现原理" class="headerlink" title="6️⃣ 底层实现原理"></a>6️⃣ 底层实现原理</h3><table>
<thead>
<tr>
<th>实现机制</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><strong>JDK 动态代理</strong></td>
<td>基于接口的代理（实现 InvocationHandler）</td>
</tr>
<tr>
<td><strong>CGLIB 动态代理</strong></td>
<td>基于类的代理（继承目标类生成子类）</td>
</tr>
<tr>
<td><strong>Spring AOP</strong></td>
<td>运行时织入，轻量级（默认基于代理机制）</td>
</tr>
<tr>
<td><strong>AspectJ AOP</strong></td>
<td>编译时织入，功能更强大（Spring 可集成）</td>
</tr>
</tbody></table>
<hr>
<h3 id="7️⃣-底层流程图（简述）"><a href="#7️⃣-底层流程图（简述）" class="headerlink" title="7️⃣ 底层流程图（简述）"></a>7️⃣ 底层流程图（简述）</h3><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">目标类 -&gt; AOP 代理工厂 -&gt; 生成代理对象 -&gt; 调用增强逻辑(Advice) -&gt; 执行业务方法</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="五、IOC-与-AOP-的关系与区别"><a href="#五、IOC-与-AOP-的关系与区别" class="headerlink" title="五、IOC 与 AOP 的关系与区别"></a>五、IOC 与 AOP 的关系与区别</h2><table>
<thead>
<tr>
<th>对比项</th>
<th>IOC</th>
<th>AOP</th>
</tr>
</thead>
<tbody><tr>
<td>关注点</td>
<td>对象的创建与依赖管理</td>
<td>行为的横切逻辑增强</td>
</tr>
<tr>
<td>实现方式</td>
<td>反射 + BeanFactory</td>
<td>动态代理（JDK &#x2F; CGLIB）</td>
</tr>
<tr>
<td>作用阶段</td>
<td>Bean 初始化时</td>
<td>Bean 使用时（运行期）</td>
</tr>
<tr>
<td>核心目标</td>
<td>解耦依赖</td>
<td>解耦行为</td>
</tr>
<tr>
<td>设计模式</td>
<td>工厂模式、单例模式</td>
<td>代理模式</td>
</tr>
</tbody></table>
<p>📌 <strong>关系总结</strong>：</p>
<blockquote>
<p>AOP 是 IOC 的一个重要应用场景。<br> IOC 负责“托管对象”，AOP 负责“增强对象”。</p>
</blockquote>
<hr>
<h2 id="六、常见追问与答案"><a href="#六、常见追问与答案" class="headerlink" title="六、常见追问与答案"></a>六、常见追问与答案</h2><table>
<thead>
<tr>
<th>追问</th>
<th>高分回答</th>
</tr>
</thead>
<tbody><tr>
<td>IOC 如何实现依赖注入？</td>
<td>通过反射 + BeanDefinition 注册 + 类型匹配注入。</td>
</tr>
<tr>
<td>AOP 为什么使用动态代理？</td>
<td>为了不修改源码实现横切逻辑增强，符合开闭原则。</td>
</tr>
<tr>
<td>Spring AOP 与 AspectJ 有何区别？</td>
<td>Spring AOP 是运行时代理，AspectJ 是编译时织入。</td>
</tr>
<tr>
<td>AOP 如何实现事务？</td>
<td>使用 <code>@Transactional</code>，底层通过 AOP 拦截方法调用并包裹事务逻辑。</td>
</tr>
<tr>
<td>IOC 和 DI 的区别？</td>
<td>IOC 是思想，DI 是实现（依赖注入是实现控制反转的一种方式）。</td>
</tr>
</tbody></table>
<hr>
<h2 id="七、性能与实践建议"><a href="#七、性能与实践建议" class="headerlink" title="七、性能与实践建议"></a>七、性能与实践建议</h2><p>✅ <strong>IOC：</strong></p>
<ul>
<li>使用构造注入（避免循环依赖）；</li>
<li>控制单例 Bean 的状态避免线程安全问题；</li>
</ul>
<p>✅ <strong>AOP：</strong></p>
<ul>
<li>尽量只增强必要的切点；</li>
<li>避免在高频调用方法中过度使用环绕通知（影响性能）；</li>
<li>使用异步切面记录日志、监控性能。</li>
</ul>
<hr>
<h2 id="八、高分总结模板（可背诵）"><a href="#八、高分总结模板（可背诵）" class="headerlink" title="八、高分总结模板（可背诵）"></a>八、高分总结模板（可背诵）</h2><blockquote>
<p>Spring 的核心是 IOC 和 AOP。<br> IOC（控制反转）通过容器管理对象的创建与依赖注入，解决模块间的强耦合问题，实现组件解耦与灵活配置。<br> AOP（面向切面编程）通过动态代理将横切关注点从业务逻辑中分离，实现如日志、事务、权限等功能的统一管理。</p>
<p>IOC 管理“对象关系”，AOP 管理“行为增强”，两者结合实现了 Spring 框架的高扩展性与可维护性。</p>
</blockquote>
<h1 id="🎯-面试题：Spring-中单例-Bean-的线程安全问题"><a href="#🎯-面试题：Spring-中单例-Bean-的线程安全问题" class="headerlink" title="🎯 面试题：Spring 中单例 Bean 的线程安全问题"></a>🎯 面试题：Spring 中单例 Bean 的线程安全问题</h1><hr>
<h2 id="一、核心结论速答（面试开场回答模板）"><a href="#一、核心结论速答（面试开场回答模板）" class="headerlink" title="一、核心结论速答（面试开场回答模板）"></a>一、核心结论速答（面试开场回答模板）</h2><blockquote>
<p>在 Spring 中，默认的 Bean 是单例的（singleton），容器只会创建一个实例。<br> 但 Spring 并不会对这个单例 Bean 做任何线程安全保证。</p>
<p>如果 Bean 是<strong>无状态的（stateless）</strong>，例如 Service、DAO，这样的 Bean 是线程安全的；<br> 如果 Bean 是<strong>有状态的（stateful）</strong>，例如在成员变量中保存请求数据或中间结果，就会出现线程安全问题。</p>
<p>解决方案包括：</p>
<ul>
<li>使用局部变量替代成员变量；</li>
<li>使用 <code>ThreadLocal</code> 隔离线程数据；</li>
<li>或将 Bean 定义为多例（prototype）、request、session 等作用域。</li>
</ul>
</blockquote>
<hr>
<h2 id="二、Spring-Bean-的单例本质"><a href="#二、Spring-Bean-的单例本质" class="headerlink" title="二、Spring Bean 的单例本质"></a>二、Spring Bean 的单例本质</h2><h3 id="1️⃣-默认作用域是-Singleton"><a href="#1️⃣-默认作用域是-Singleton" class="headerlink" title="1️⃣ 默认作用域是 Singleton"></a>1️⃣ 默认作用域是 Singleton</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OrderService</span> &#123;</span><br><span class="line">    <span class="comment">// 默认：单例（singleton）</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Spring 容器在启动时只会创建一个 <code>OrderService</code> 实例，并将其放入 <strong>单例池（singletonObjects）</strong> 中，全局共享。</p>
<h3 id="2️⃣-单例作用域的生命周期"><a href="#2️⃣-单例作用域的生命周期" class="headerlink" title="2️⃣ 单例作用域的生命周期"></a>2️⃣ 单例作用域的生命周期</h3><ul>
<li>容器启动 → 实例化 Bean</li>
<li>容器运行期间，所有线程共享同一个 Bean 实例</li>
<li>容器关闭 → 销毁 Bean</li>
</ul>
<p>📌 <strong>关键点</strong>：单例 Bean 的对象是共享的 → 若内部保存可变数据，就可能产生线程安全问题。</p>
<hr>
<h2 id="三、单例-Bean-线程安全问题的根本原因"><a href="#三、单例-Bean-线程安全问题的根本原因" class="headerlink" title="三、单例 Bean 线程安全问题的根本原因"></a>三、单例 Bean 线程安全问题的根本原因</h2><h3 id="❌-错误示例（有状态-Bean）"><a href="#❌-错误示例（有状态-Bean）" class="headerlink" title="❌ 错误示例（有状态 Bean）"></a>❌ 错误示例（有状态 Bean）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LoginService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String currentUser; <span class="comment">// 成员变量保存状态 ❌</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">login</span><span class="params">(String username)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.currentUser = username;</span><br><span class="line">        <span class="comment">// do something...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getCurrentUser</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.currentUser;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>多个请求线程共享同一个 <code>LoginService</code> 实例；</li>
<li>线程 A 设置 <code>currentUser = &quot;王帅锴&quot;</code>，线程 B 设置 <code>&quot;李四&quot;</code>；</li>
<li><code>getCurrentUser()</code> 的返回值会互相干扰 —— <strong>典型的线程不安全</strong>。</li>
</ul>
<hr>
<h3 id="✅-正确做法（无状态-Bean）"><a href="#✅-正确做法（无状态-Bean）" class="headerlink" title="✅ 正确做法（无状态 Bean）"></a>✅ 正确做法（无状态 Bean）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LoginService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">login</span><span class="params">(String username)</span> &#123;</span><br><span class="line">        <span class="comment">// 使用局部变量代替成员变量 ✅</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">currentUser</span> <span class="operator">=</span> username;</span><br><span class="line">        <span class="comment">// do something...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>📌 <strong>结论</strong>：<br> 只要不在成员变量中保存可变状态，单例 Bean 就是线程安全的。</p>
<hr>
<h2 id="四、单例-Bean-的分类与安全性分析"><a href="#四、单例-Bean-的分类与安全性分析" class="headerlink" title="四、单例 Bean 的分类与安全性分析"></a>四、单例 Bean 的分类与安全性分析</h2><table>
<thead>
<tr>
<th>Bean 类型</th>
<th>是否有状态</th>
<th>是否线程安全</th>
<th>示例</th>
</tr>
</thead>
<tbody><tr>
<td>Controller</td>
<td>有状态（若存储请求数据）</td>
<td>否</td>
<td><code>private String msg;</code></td>
</tr>
<tr>
<td>Service</td>
<td>通常无状态</td>
<td>是</td>
<td>调用 DAO 层方法</td>
</tr>
<tr>
<td>Repository</td>
<td>无状态</td>
<td>是</td>
<td>操作数据库连接池</td>
</tr>
<tr>
<td>Component</td>
<td>取决于设计</td>
<td>视情况而定</td>
<td>缓存 Bean、工具类等</td>
</tr>
</tbody></table>
<hr>
<h2 id="五、Spring-为什么不自动保证线程安全？"><a href="#五、Spring-为什么不自动保证线程安全？" class="headerlink" title="五、Spring 为什么不自动保证线程安全？"></a>五、Spring 为什么不自动保证线程安全？</h2><ol>
<li><strong>性能原因</strong>：<br> 若 Spring 对每个 Bean 都加锁，会严重影响性能。</li>
<li><strong>职责分离</strong>：<br> Spring 容器负责生命周期管理，不负责并发控制。</li>
<li><strong>可控性</strong>：<br> 线程安全问题取决于业务逻辑，Spring 无法统一处理。</li>
</ol>
<hr>
<h2 id="六、常见解决方案与实践建议"><a href="#六、常见解决方案与实践建议" class="headerlink" title="六、常见解决方案与实践建议"></a>六、常见解决方案与实践建议</h2><h3 id="✅-方案-1：无状态设计（推荐）"><a href="#✅-方案-1：无状态设计（推荐）" class="headerlink" title="✅ 方案 1：无状态设计（推荐）"></a>✅ 方案 1：无状态设计（推荐）</h3><p>保持 Bean 的无状态性（stateless），不要在 Bean 成员变量中存储用户请求数据。<br> <strong>最推荐的实践方式。</strong></p>
<hr>
<h3 id="✅-方案-2：使用局部变量"><a href="#✅-方案-2：使用局部变量" class="headerlink" title="✅ 方案 2：使用局部变量"></a>✅ 方案 2：使用局部变量</h3><p>在方法内部使用局部变量保存临时状态（线程独享）。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">processOrder</span><span class="params">(Order order)</span> &#123;</span><br><span class="line">    <span class="type">double</span> <span class="variable">total</span> <span class="operator">=</span> calculateTotal(order); <span class="comment">// 局部变量 ✅</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="✅-方案-3：使用-ThreadLocal"><a href="#✅-方案-3：使用-ThreadLocal" class="headerlink" title="✅ 方案 3：使用 ThreadLocal"></a>✅ 方案 3：使用 ThreadLocal</h3><p>适合存放与线程相关的上下文信息（如用户 ID、请求信息）。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserContext</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;String&gt; currentUser = <span class="keyword">new</span> <span class="title class_">ThreadLocal</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setUser</span><span class="params">(String user)</span> &#123;</span><br><span class="line">        currentUser.set(user);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getUser</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> currentUser.get();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">clear</span><span class="params">()</span> &#123;</span><br><span class="line">        currentUser.remove();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>📌 Spring 中的事务管理、请求上下文（<code>RequestContextHolder</code>）也大量使用 <code>ThreadLocal</code> 实现线程隔离。</p>
<hr>
<h3 id="✅-方案-4：更改-Bean-作用域"><a href="#✅-方案-4：更改-Bean-作用域" class="headerlink" title="✅ 方案 4：更改 Bean 作用域"></a>✅ 方案 4：更改 Bean 作用域</h3><p>通过 <code>@Scope</code> 注解更改 Bean 的生命周期范围：</p>
<table>
<thead>
<tr>
<th>Scope 类型</th>
<th>描述</th>
<th>线程安全性</th>
</tr>
</thead>
<tbody><tr>
<td>singleton</td>
<td>全局单例</td>
<td>线程不安全（需无状态）</td>
</tr>
<tr>
<td>prototype</td>
<td>每次请求新建</td>
<td>线程安全（独立实例）</td>
</tr>
<tr>
<td>request</td>
<td>每次 HTTP 请求创建</td>
<td>线程安全（Web 场景）</td>
</tr>
<tr>
<td>session</td>
<td>每个 Session 创建一次</td>
<td>线程安全（Web 场景）</td>
</tr>
</tbody></table>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Scope(&quot;prototype&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StateBean</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="七、Spring-内部的线程安全机制举例"><a href="#七、Spring-内部的线程安全机制举例" class="headerlink" title="七、Spring 内部的线程安全机制举例"></a>七、Spring 内部的线程安全机制举例</h2><table>
<thead>
<tr>
<th>模块</th>
<th>是否线程安全</th>
<th>原理</th>
</tr>
</thead>
<tbody><tr>
<td><code>ApplicationContext</code></td>
<td>是</td>
<td>启动后只读，不修改</td>
</tr>
<tr>
<td><code>@Autowired</code> 注入</td>
<td>是</td>
<td>Bean 初始化阶段完成依赖装配</td>
</tr>
<tr>
<td><code>@Transactional</code></td>
<td>是</td>
<td>AOP 代理对象保证事务隔离</td>
</tr>
<tr>
<td><code>RestController</code></td>
<td>否（若保存状态）</td>
<td>多线程共享同一对象</td>
</tr>
</tbody></table>
<hr>
<h2 id="八、常见面试追问与答案"><a href="#八、常见面试追问与答案" class="headerlink" title="八、常见面试追问与答案"></a>八、常见面试追问与答案</h2><table>
<thead>
<tr>
<th>追问</th>
<th>答案</th>
</tr>
</thead>
<tbody><tr>
<td>Q1：Spring 容器中的 Bean 默认是线程安全的吗？</td>
<td>不是。默认单例 Bean 不是线程安全的。</td>
</tr>
<tr>
<td>Q2：单例 Bean 一定不安全吗？</td>
<td>不一定。若无状态（stateless），则是线程安全的。</td>
</tr>
<tr>
<td>Q3：Spring MVC 的 Controller 是单例的吗？</td>
<td>是单例的。若在 Controller 中定义成员变量，会产生线程安全问题。</td>
</tr>
<tr>
<td>Q4：如何避免 Controller 出现线程安全问题？</td>
<td>不在 Controller 中定义可变成员变量。必要时使用局部变量或 <code>ThreadLocal</code>。</td>
</tr>
<tr>
<td>Q5：Spring 如何处理 request、session 作用域 Bean？</td>
<td>通过代理模式（ScopedProxy）为每个请求创建独立实例。</td>
</tr>
</tbody></table>
<hr>
<h2 id="九、底层实现原理（源码级）"><a href="#九、底层实现原理（源码级）" class="headerlink" title="九、底层实现原理（源码级）"></a>九、底层实现原理（源码级）</h2><p>Spring 容器通过 <code>DefaultSingletonBeanRegistry</code> 管理单例 Bean。<br> 单例 Bean 存放在 <code>singletonObjects</code> Map 中：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, Object&gt; singletonObjects = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;&gt;(<span class="number">256</span>);</span><br></pre></td></tr></table></figure>

<p>📌 注意：</p>
<ul>
<li>容器层面是线程安全的（使用 ConcurrentHashMap 存放 Bean）；</li>
<li>Bean 自身并不保证线程安全；</li>
<li>Spring 只保证“容器操作 Bean 的安全”，不保证“Bean 内部逻辑的安全”。</li>
</ul>
<hr>
<h2 id="🔟-高分总结模板（可背诵）"><a href="#🔟-高分总结模板（可背诵）" class="headerlink" title="🔟 高分总结模板（可背诵）"></a>🔟 高分总结模板（可背诵）</h2><blockquote>
<p>Spring 中默认的 Bean 是单例（singleton）模式。<br> 容器会为每个 Bean 创建一个共享实例，并在应用中复用。</p>
<p>单例 Bean 本身是线程共享的，因此如果其中存在可变的成员变量（stateful Bean），就会产生线程安全问题。</p>
<p>一般来说：</p>
<ul>
<li>无状态 Bean（如 Service、DAO）是线程安全的；</li>
<li>有状态 Bean（如保存请求信息）是线程不安全的。</li>
</ul>
<p>解决方式包括无状态设计、局部变量、ThreadLocal、或调整 Bean 作用域。</p>
<p>Spring 容器本身是线程安全的，但 Bean 的线程安全需要开发者自行保证。</p>
</blockquote>
<hr>
<h2 id="🔍-扩展话题（面试官可能深入追问）"><a href="#🔍-扩展话题（面试官可能深入追问）" class="headerlink" title="🔍 扩展话题（面试官可能深入追问）"></a>🔍 扩展话题（面试官可能深入追问）</h2><ol>
<li><strong>Spring 如何解决循环依赖（涉及三级缓存）？</strong></li>
<li><strong>ThreadLocal 在 Spring 中的典型应用有哪些？</strong></li>
<li><strong>为什么 Controller 是单例的？Spring 为什么不默认设为 prototype？</strong></li>
<li><strong>Spring 如何保证事务隔离？事务与线程安全的关系？</strong></li>
</ol>
<h1 id="🎯-面试题：Spring-如何解决循环依赖问题？"><a href="#🎯-面试题：Spring-如何解决循环依赖问题？" class="headerlink" title="🎯 面试题：Spring 如何解决循环依赖问题？"></a>🎯 面试题：Spring 如何解决循环依赖问题？</h1><hr>
<h2 id="一、面试官考察点-3"><a href="#一、面试官考察点-3" class="headerlink" title="一、面试官考察点"></a>一、面试官考察点</h2><ol>
<li>是否理解 Bean 的生命周期与依赖注入机制；</li>
<li>是否了解 Spring 容器三级缓存的作用；</li>
<li>能否区分构造器注入与 Setter 注入在循环依赖下的差异；</li>
<li>是否知道在 AOP 场景下如何处理代理对象的提前暴露。</li>
</ol>
<hr>
<h2 id="二、核心速答模板（面试开场版）"><a href="#二、核心速答模板（面试开场版）" class="headerlink" title="二、核心速答模板（面试开场版）"></a>二、核心速答模板（面试开场版）</h2><blockquote>
<p>Spring 通过<strong>三级缓存机制</strong>解决了<strong>单例 Bean 的循环依赖问题</strong>。</p>
<p>当 BeanA 依赖 BeanB，而 BeanB 又依赖 BeanA 时，<br> Spring 在实例化阶段（还未初始化完成）就会<strong>提前将 Bean 的引用暴露到三级缓存中</strong>，<br> 这样在创建另一个 Bean 时可以获取到该“半成品”对象，从而完成依赖注入。</p>
<p>⚙️ 三级缓存结构：</p>
<ul>
<li><strong>一级缓存（singletonObjects）</strong>：已完全初始化的单例 Bean；</li>
<li><strong>二级缓存（earlySingletonObjects）</strong>：已实例化但未初始化的早期 Bean；</li>
<li><strong>三级缓存（singletonFactories）</strong>：存放创建 Bean 提前暴露对象的工厂，用于解决 AOP 代理问题。</li>
</ul>
</blockquote>
<hr>
<h2 id="三、什么是循环依赖？"><a href="#三、什么是循环依赖？" class="headerlink" title="三、什么是循环依赖？"></a>三、什么是循环依赖？</h2><p><strong>循环依赖（Circular Dependency）</strong> 指的是多个 Bean 之间互相依赖，形成环状结构，导致容器无法正常完成依赖注入。</p>
<h3 id="示例："><a href="#示例：" class="headerlink" title="示例："></a>示例：</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> B b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">B</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> A a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>📌 此时：</p>
<ul>
<li>A 需要先创建 B；</li>
<li>B 又依赖 A；</li>
<li>如果没有特殊机制，就会陷入死循环。</li>
</ul>
<hr>
<h2 id="四、Spring-解决循环依赖的前提与限制"><a href="#四、Spring-解决循环依赖的前提与限制" class="headerlink" title="四、Spring 解决循环依赖的前提与限制"></a>四、Spring 解决循环依赖的前提与限制</h2><table>
<thead>
<tr>
<th>类型</th>
<th>是否支持</th>
</tr>
</thead>
<tbody><tr>
<td><strong>构造器注入</strong></td>
<td>❌ 不支持，会直接报错（因为对象未创建）</td>
</tr>
<tr>
<td><strong>Setter 注入 &#x2F; 字段注入</strong></td>
<td>✅ 支持，Spring 会通过三级缓存提前暴露引用</td>
</tr>
<tr>
<td><strong>原型（prototype）作用域 Bean</strong></td>
<td>❌ 不支持，Spring 无法缓存多个半成品对象</td>
</tr>
</tbody></table>
<hr>
<h2 id="五、Spring-三级缓存核心机制"><a href="#五、Spring-三级缓存核心机制" class="headerlink" title="五、Spring 三级缓存核心机制"></a>五、Spring 三级缓存核心机制</h2><p>Spring 通过 <code>DefaultSingletonBeanRegistry</code> 管理这三层缓存 👇</p>
<table>
<thead>
<tr>
<th>缓存层级</th>
<th>字段名</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>一级缓存</td>
<td><code>singletonObjects</code></td>
<td>存放完全初始化的单例 Bean</td>
</tr>
<tr>
<td>二级缓存</td>
<td><code>earlySingletonObjects</code></td>
<td>存放实例化但未初始化的早期 Bean</td>
</tr>
<tr>
<td>三级缓存</td>
<td><code>singletonFactories</code></td>
<td>存放可创建早期 Bean 的工厂（ObjectFactory）</td>
</tr>
</tbody></table>
<hr>
<h2 id="六、循环依赖解决流程（重点核心）"><a href="#六、循环依赖解决流程（重点核心）" class="headerlink" title="六、循环依赖解决流程（重点核心）"></a>六、循环依赖解决流程（重点核心）</h2><p>以 <code>A → B → A</code> 为例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">createBean(A)</span><br><span class="line">│</span><br><span class="line">├── 实例化 A（此时属性 b 还未注入）</span><br><span class="line">│</span><br><span class="line">├── 提前暴露 A 的 ObjectFactory 到三级缓存（singletonFactories）</span><br><span class="line">│</span><br><span class="line">├── 为 A 填充属性 → 发现依赖 B</span><br><span class="line">│   ├── createBean(B)</span><br><span class="line">│   │   ├── 实例化 B</span><br><span class="line">│   │   ├── 提前暴露 B 的工厂到三级缓存</span><br><span class="line">│   │   ├── 为 B 填充属性 → 发现依赖 A</span><br><span class="line">│   │   │   ├── 从缓存中获取 A：</span><br><span class="line">│   │   │       - 一级缓存找不到</span><br><span class="line">│   │   │       - 二级缓存找不到</span><br><span class="line">│   │   │       - 三级缓存命中 → 调用工厂返回 A（半成品）</span><br><span class="line">│   │   │   └── 将早期 A 放入二级缓存</span><br><span class="line">│   │   └── 初始化 B 完成 → 放入一级缓存</span><br><span class="line">│   └── 注入 B 到 A</span><br><span class="line">└── 初始化 A 完成 → 放入一级缓存</span><br></pre></td></tr></table></figure>

<p>📌 关键点：</p>
<ul>
<li>“半成品 A” 提前暴露（未完全初始化，但可被依赖）；</li>
<li>Bean 完成初始化后，会升级到一级缓存；</li>
<li>三级缓存保证了代理对象也能被提前暴露。</li>
</ul>
<hr>
<h2 id="七、源码核心解析（简化版）"><a href="#七、源码核心解析（简化版）" class="headerlink" title="七、源码核心解析（简化版）"></a>七、源码核心解析（简化版）</h2><p>Spring 的核心逻辑在 <code>DefaultSingletonBeanRegistry#getSingleton()</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> Object <span class="title function_">getSingleton</span><span class="params">(String beanName, <span class="type">boolean</span> allowEarlyReference)</span> &#123;</span><br><span class="line">    <span class="comment">// 1. 一级缓存：已完全初始化的 Bean</span></span><br><span class="line">    <span class="type">Object</span> <span class="variable">singletonObject</span> <span class="operator">=</span> singletonObjects.get(beanName);</span><br><span class="line">    <span class="keyword">if</span> (singletonObject == <span class="literal">null</span> &amp;&amp; isSingletonCurrentlyInCreation(beanName)) &#123;</span><br><span class="line">        <span class="comment">// 2. 二级缓存：提前曝光但未完成初始化的 Bean</span></span><br><span class="line">        singletonObject = earlySingletonObjects.get(beanName);</span><br><span class="line">        <span class="keyword">if</span> (singletonObject == <span class="literal">null</span> &amp;&amp; allowEarlyReference) &#123;</span><br><span class="line">            <span class="comment">// 3. 三级缓存：通过工厂创建早期 Bean</span></span><br><span class="line">            ObjectFactory&lt;?&gt; singletonFactory = singletonFactories.get(beanName);</span><br><span class="line">            <span class="keyword">if</span> (singletonFactory != <span class="literal">null</span>) &#123;</span><br><span class="line">                singletonObject = singletonFactory.getObject();</span><br><span class="line">                earlySingletonObjects.put(beanName, singletonObject);</span><br><span class="line">                singletonFactories.remove(beanName);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> singletonObject;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>📌 <strong>关键逻辑</strong>：</p>
<ul>
<li>当 Bean 还未完成初始化时，会调用三级缓存中的 ObjectFactory 提前生成一个早期引用；</li>
<li>初始化完成后再替换为完整 Bean；</li>
<li>若涉及 AOP 代理对象，则工厂中生成的是代理后的对象。</li>
</ul>
<hr>
<h2 id="八、AOP-代理与三级缓存的关系"><a href="#八、AOP-代理与三级缓存的关系" class="headerlink" title="八、AOP 代理与三级缓存的关系"></a>八、AOP 代理与三级缓存的关系</h2><p>在 AOP 场景下，若不使用三级缓存，循环依赖会出现代理对象注入异常。</p>
<p>原因是：</p>
<ul>
<li>AOP 需要在 Bean 初始化后创建代理；</li>
<li>若提前暴露的是“原始对象”，B 注入的将不是代理对象；</li>
<li>因此三级缓存的工厂中存放的是生成代理对象的逻辑。</li>
</ul>
<p>📌 举例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">singletonFactories.put(beanName, () -&gt; getEarlyBeanReference(beanName, mbd, bean));</span><br></pre></td></tr></table></figure>

<p>→ 这样即使提前暴露，也能拿到代理对象引用。</p>
<hr>
<h2 id="九、常见面试追问与答案"><a href="#九、常见面试追问与答案" class="headerlink" title="九、常见面试追问与答案"></a>九、常见面试追问与答案</h2><table>
<thead>
<tr>
<th>追问</th>
<th>答案</th>
</tr>
</thead>
<tbody><tr>
<td><strong>Spring 为什么要用三级缓存而不是二级？</strong></td>
<td>因为二级缓存只能保存实例对象，而无法支持代理对象的提前暴露。三级缓存通过 ObjectFactory 动态生成代理对象。</td>
</tr>
<tr>
<td><strong>构造器注入能解决循环依赖吗？</strong></td>
<td>不能。因为构造器注入在实例化阶段就需要依赖对象，而对象还未创建完成。</td>
</tr>
<tr>
<td><strong>原型作用域 Bean 能解决循环依赖吗？</strong></td>
<td>不能。因为每次创建新实例，Spring 无法缓存半成品对象。</td>
</tr>
<tr>
<td><strong>为什么要有二级缓存？</strong></td>
<td>避免多次调用 ObjectFactory 导致重复创建代理对象，保证同一个早期引用复用。</td>
</tr>
<tr>
<td><strong>AOP 代理下的循环依赖如何处理？</strong></td>
<td>提前暴露的是代理对象引用，通过 <code>getEarlyBeanReference</code> 获取。</td>
</tr>
</tbody></table>
<hr>
<h2 id="🔟-实际项目案例（WMS-场景）"><a href="#🔟-实际项目案例（WMS-场景）" class="headerlink" title="🔟 实际项目案例（WMS 场景）"></a>🔟 实际项目案例（WMS 场景）</h2><p>假设在 WMS 系统中：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InboundService</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> StorageService storageService;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StorageService</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> InboundService inboundService;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>✅ <strong>Spring 可正常启动</strong><br> 因为使用的是 Setter &#x2F; 字段注入，Spring 通过三级缓存解决。</p>
<p>❌ 若改成构造函数注入：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">InboundService</span><span class="params">(StorageService storageService)</span> &#123; ... &#125;</span><br><span class="line"><span class="keyword">public</span> <span class="title function_">StorageService</span><span class="params">(InboundService inboundService)</span> &#123; ... &#125;</span><br></pre></td></tr></table></figure>

<p>➡️ 会直接抛出：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">BeanCurrentlyInCreationException: Error creating bean with name &#x27;inboundService&#x27;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="🧩-十一、性能与安全性分析"><a href="#🧩-十一、性能与安全性分析" class="headerlink" title="🧩 十一、性能与安全性分析"></a>🧩 十一、性能与安全性分析</h2><ul>
<li>循环依赖解决方案性能开销低（基于缓存引用，不加锁）；</li>
<li>但若循环关系复杂（多层循环），可读性差，维护成本高；</li>
<li>推荐通过重构消除循环依赖（例如通过事件驱动或中间层解耦）。</li>
</ul>
<hr>
<h2 id="🧠-十二、高分总结模板（可背诵）"><a href="#🧠-十二、高分总结模板（可背诵）" class="headerlink" title="🧠 十二、高分总结模板（可背诵）"></a>🧠 十二、高分总结模板（可背诵）</h2><blockquote>
<p>Spring 通过 <strong>三级缓存机制</strong> 解决了单例 Bean 的循环依赖问题。<br> 在 Bean 创建过程中，Spring 会在实例化后、初始化前，将该 Bean 的引用提前暴露到三级缓存中。<br> 当另一个 Bean 依赖它时，可以从缓存中获取该“早期引用”，从而打破循环。</p>
<p>三级缓存结构：</p>
<ul>
<li>一级缓存（singletonObjects）：已初始化完成的 Bean；</li>
<li>二级缓存（earlySingletonObjects）：早期 Bean 实例；</li>
<li>三级缓存（singletonFactories）：可生成早期 Bean 的工厂，用于支持 AOP 代理。</li>
</ul>
<p>Spring 仅支持单例 Bean 的 Setter 注入循环依赖，<br> 对于构造器注入或 prototype Bean，不支持循环依赖。</p>
</blockquote>
<hr>
<h2 id="🔍-十三、扩展话题（面试官可能继续追问）"><a href="#🔍-十三、扩展话题（面试官可能继续追问）" class="headerlink" title="🔍 十三、扩展话题（面试官可能继续追问）"></a>🔍 十三、扩展话题（面试官可能继续追问）</h2><ol>
<li>Spring 为什么选择三级缓存而不是二级？</li>
<li>如果我用 <code>@Lazy</code> 注解能否解决循环依赖？</li>
<li>构造器注入导致循环依赖，Spring Boot 会如何处理？</li>
<li>AOP 环境下，代理对象如何在循环依赖中正确注入？</li>
<li>Spring 的三级缓存机制与三级单例缓存（singletonFactories）之间的区别？</li>
</ol>
<h1 id="🎯-面试题：Spring-Bean-的实例化和初始化过程"><a href="#🎯-面试题：Spring-Bean-的实例化和初始化过程" class="headerlink" title="🎯 面试题：Spring Bean 的实例化和初始化过程"></a>🎯 面试题：Spring Bean 的实例化和初始化过程</h1><hr>
<h2 id="一、面试官考察点-4"><a href="#一、面试官考察点-4" class="headerlink" title="一、面试官考察点"></a>一、面试官考察点</h2><ul>
<li>是否理解 Spring Bean 的完整生命周期。</li>
<li>能否区分 <strong>实例化（Instantiation）</strong> 和 <strong>初始化（Initialization）</strong> 的概念。</li>
<li>是否了解 Spring 中涉及的关键接口：<ul>
<li><code>BeanFactoryPostProcessor</code>、<code>BeanPostProcessor</code>、<code>InitializingBean</code>、<code>DisposableBean</code> 等。</li>
</ul>
</li>
<li>是否能说清楚 <strong>依赖注入、AOP 增强、三级缓存、循环依赖处理</strong> 的流程。</li>
</ul>
<hr>
<h2 id="二、核心速答（30-秒简版）"><a href="#二、核心速答（30-秒简版）" class="headerlink" title="二、核心速答（30 秒简版）"></a>二、核心速答（30 秒简版）</h2><blockquote>
<p>在 Spring 容器中，Bean 的创建大致分为两大阶段：</p>
<p>1️⃣ <strong>实例化（Instantiation）</strong>：通过反射创建对象（只分配内存、执行构造函数）。<br> 2️⃣ <strong>初始化（Initialization）</strong>：依赖注入、调用初始化方法、执行 AOP 代理、触发生命周期回调。</p>
<p>整个过程由 <code>AbstractAutowireCapableBeanFactory#createBean()</code> 负责，<br> 期间涉及 <strong>三级缓存</strong> 解决循环依赖，<br> 并通过 <strong>BeanPostProcessor</strong> 执行 Bean 的前置、后置增强逻辑。</p>
</blockquote>
<hr>
<h2 id="三、Spring-Bean-创建的完整流程（详细版）"><a href="#三、Spring-Bean-创建的完整流程（详细版）" class="headerlink" title="三、Spring Bean 创建的完整流程（详细版）"></a>三、Spring Bean 创建的完整流程（详细版）</h2><p>我们从 <code>getBean()</code> 开始，逐步梳理整个过程👇</p>
<hr>
<h3 id="阶段-1：加载-Bean-定义（BeanDefinition）"><a href="#阶段-1：加载-Bean-定义（BeanDefinition）" class="headerlink" title="阶段 1：加载 Bean 定义（BeanDefinition）"></a><strong>阶段 1：加载 Bean 定义（BeanDefinition）</strong></h3><p>Spring 启动时，会解析配置类或 XML，将每个 Bean 的元信息加载到 <code>BeanDefinition</code> 中，<br> 包括：</p>
<ul>
<li>类全限定名</li>
<li>作用域（singleton&#x2F;prototype）</li>
<li>自动注入模式</li>
<li>初始化&#x2F;销毁方法</li>
<li>依赖关系等</li>
</ul>
<p><strong>对应源码：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">AbstractBeanDefinitionReader#loadBeanDefinitions()</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="阶段-2：实例化-Bean（Instantiation）"><a href="#阶段-2：实例化-Bean（Instantiation）" class="headerlink" title="阶段 2：实例化 Bean（Instantiation）"></a><strong>阶段 2：实例化 Bean（Instantiation）</strong></h3><blockquote>
<p>负责 “创建对象”，类似于执行 <code>new</code> 操作。</p>
</blockquote>
<p>Spring 调用 <code>createBeanInstance()</code> 方法，通过反射或工厂方法创建 Bean 对象：</p>
<p><strong>主要执行逻辑：</strong></p>
<ol>
<li>若存在工厂方法 → 调用工厂方法创建；</li>
<li>否则使用反射（Constructor 或 CGLIB）实例化；</li>
<li>实例化完成后，<strong>Bean 进入三级缓存（singletonFactories）</strong>；</li>
<li>该阶段 Bean 仅有“空壳对象”，属性尚未注入。</li>
</ol>
<p><strong>源码位置：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">AbstractAutowireCapableBeanFactory#createBeanInstance()</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="阶段-3：依赖注入（Populate-Bean）"><a href="#阶段-3：依赖注入（Populate-Bean）" class="headerlink" title="阶段 3：依赖注入（Populate Bean）"></a><strong>阶段 3：依赖注入（Populate Bean）</strong></h3><blockquote>
<p>负责 “填充属性”。</p>
</blockquote>
<p>Spring 调用 <code>populateBean()</code>，为实例化的 Bean 注入依赖。</p>
<p><strong>主要流程：</strong></p>
<ol>
<li>解析字段、setter 注入；</li>
<li>从容器中获取依赖 Bean；</li>
<li>如果依赖 Bean 尚未完全初始化，则通过 <strong>三级缓存提前暴露早期引用</strong>（解决循环依赖）；</li>
<li>完成属性装配。</li>
</ol>
<p><strong>源码位置：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">AbstractAutowireCapableBeanFactory#populateBean()</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="阶段-4：初始化前置处理（BeanPostProcessor-before）"><a href="#阶段-4：初始化前置处理（BeanPostProcessor-before）" class="headerlink" title="阶段 4：初始化前置处理（BeanPostProcessor - before）"></a><strong>阶段 4：初始化前置处理（BeanPostProcessor - before）</strong></h3><blockquote>
<p>BeanPostProcessor 的第一次回调：<code>postProcessBeforeInitialization()</code></p>
</blockquote>
<p>在 Bean 完成依赖注入后，但在调用初始化方法前，<br> Spring 会让所有注册的 <code>BeanPostProcessor</code> 对 Bean 进行预处理，比如：</p>
<ul>
<li>AOP 代理的预检测；</li>
<li>@Autowired 检查；</li>
<li>@PostConstruct 处理；</li>
<li>资源注入（Resource、Environment）等。</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">postProcessBeforeInitialization</span><span class="params">(Object bean, String beanName)</span> &#123;</span><br><span class="line">    <span class="comment">// 可对 Bean 属性进行修改</span></span><br><span class="line">    <span class="keyword">return</span> bean;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="阶段-5：初始化（Initialization）"><a href="#阶段-5：初始化（Initialization）" class="headerlink" title="阶段 5：初始化（Initialization）"></a><strong>阶段 5：初始化（Initialization）</strong></h3><blockquote>
<p>初始化是指执行 Bean 自定义的初始化逻辑。</p>
</blockquote>
<p>Spring 提供多种方式定义 Bean 的初始化逻辑：</p>
<table>
<thead>
<tr>
<th>方式</th>
<th>示例</th>
<th>执行顺序</th>
</tr>
</thead>
<tbody><tr>
<td>实现接口</td>
<td><code>InitializingBean.afterPropertiesSet()</code></td>
<td>先执行</td>
</tr>
<tr>
<td>注解</td>
<td><code>@PostConstruct</code></td>
<td>在 BeanPostProcessor 中触发</td>
</tr>
<tr>
<td>XML&#x2F;注解指定</td>
<td><code>init-method=&quot;init&quot;</code> 或 <code>@Bean(initMethod=&quot;init&quot;)</code></td>
<td>最后执行</td>
</tr>
</tbody></table>
<p><strong>源码位置：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">invokeInitMethods(beanName, bean, mbd)</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="阶段-6：初始化后置处理（BeanPostProcessor-after）"><a href="#阶段-6：初始化后置处理（BeanPostProcessor-after）" class="headerlink" title="阶段 6：初始化后置处理（BeanPostProcessor - after）"></a><strong>阶段 6：初始化后置处理（BeanPostProcessor - after）</strong></h3><blockquote>
<p>第二次回调：<code>postProcessAfterInitialization()</code></p>
</blockquote>
<p>此时 Bean 已初始化完成。<br> 若 Bean 需要 AOP 增强（如 <code>@Transactional</code>），则在此阶段生成代理对象。</p>
<p><strong>示例：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">postProcessAfterInitialization</span><span class="params">(Object bean, String beanName)</span> &#123;</span><br><span class="line">    <span class="comment">// 返回代理对象</span></span><br><span class="line">    <span class="keyword">return</span> ProxyFactory.createProxy(bean);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最终返回的可能不是原始 Bean，而是代理 Bean（增强后的对象）。</p>
<hr>
<h3 id="阶段-7：注册到单例池（singletonObjects）"><a href="#阶段-7：注册到单例池（singletonObjects）" class="headerlink" title="阶段 7：注册到单例池（singletonObjects）"></a><strong>阶段 7：注册到单例池（singletonObjects）</strong></h3><blockquote>
<p>初始化完成后，Spring 将 Bean 存入一级缓存，供全局复用。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">singletonObjects.put(beanName, bean);</span><br></pre></td></tr></table></figure>

<p>此时：</p>
<ul>
<li>二级、三级缓存中的 Bean 引用被清除；</li>
<li>Bean 生命周期进入“可使用”阶段；</li>
<li>若实现了 <code>ApplicationContextAware</code>，则上下文已注入。</li>
</ul>
<hr>
<h3 id="阶段-8：销毁阶段（Destruction）"><a href="#阶段-8：销毁阶段（Destruction）" class="headerlink" title="阶段 8：销毁阶段（Destruction）"></a><strong>阶段 8：销毁阶段（Destruction）</strong></h3><p>当容器关闭时（如 <code>context.close()</code>）：</p>
<ul>
<li>调用 <code>DisposableBean.destroy()</code>；</li>
<li>调用 <code>@PreDestroy</code> 注解方法；</li>
<li>调用 <code>destroy-method</code> 中定义的销毁逻辑。</li>
</ul>
<hr>
<h2 id="四、Bean-生命周期总览图（高频面试画图题）"><a href="#四、Bean-生命周期总览图（高频面试画图题）" class="headerlink" title="四、Bean 生命周期总览图（高频面试画图题）"></a>四、Bean 生命周期总览图（高频面试画图题）</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Spring Bean 生命周期：</span><br><span class="line">---------------------------------------------</span><br><span class="line">            ↓ 读取配置加载BeanDefinition</span><br><span class="line">[创建实例] → 实例化（构造函数）</span><br><span class="line">            ↓</span><br><span class="line">        属性填充（依赖注入）</span><br><span class="line">            ↓</span><br><span class="line">BeanPostProcessor.beforeInit()</span><br><span class="line">            ↓</span><br><span class="line">      初始化（@PostConstruct、init-method）</span><br><span class="line">            ↓</span><br><span class="line">BeanPostProcessor.afterInit() → 生成AOP代理</span><br><span class="line">            ↓</span><br><span class="line">     注册到单例池（可被容器使用）</span><br><span class="line">            ↓</span><br><span class="line">     容器关闭 → 销毁（@PreDestroy、destroy-method）</span><br><span class="line">---------------------------------------------</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="五、源码关键路径（简化总结）"><a href="#五、源码关键路径（简化总结）" class="headerlink" title="五、源码关键路径（简化总结）"></a>五、源码关键路径（简化总结）</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">AbstractAutowireCapableBeanFactory#createBean()</span><br><span class="line">    -&gt; doCreateBean()</span><br><span class="line">        -&gt; createBeanInstance()       <span class="comment">// 实例化</span></span><br><span class="line">        -&gt; populateBean()             <span class="comment">// 依赖注入</span></span><br><span class="line">        -&gt; initializeBean()           <span class="comment">// 初始化</span></span><br><span class="line">            -&gt; applyBeanPostProcessorsBeforeInitialization()</span><br><span class="line">            -&gt; invokeInitMethods()</span><br><span class="line">            -&gt; applyBeanPostProcessorsAfterInitialization()</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="六、常见追问与标准答案"><a href="#六、常见追问与标准答案" class="headerlink" title="六、常见追问与标准答案"></a>六、常见追问与标准答案</h2><table>
<thead>
<tr>
<th>追问</th>
<th>高分回答</th>
</tr>
</thead>
<tbody><tr>
<td>实例化与初始化的区别？</td>
<td>实例化是创建对象（分配内存、调用构造函数），初始化是填充属性并执行自定义逻辑。</td>
</tr>
<tr>
<td>BeanPostProcessor 在哪执行？</td>
<td>beforeInit 在属性注入后、init-method 前执行；afterInit 在初始化后执行。</td>
</tr>
<tr>
<td>BeanFactoryPostProcessor 与 BeanPostProcessor 区别？</td>
<td>前者在 Bean 实例化前修改 BeanDefinition，后者在 Bean 实例化后修改 Bean 实例。</td>
</tr>
<tr>
<td>AOP 代理在何时生成？</td>
<td>通常在 <code>postProcessAfterInitialization()</code> 阶段生成。</td>
</tr>
<tr>
<td>如何保证单例 Bean 的线程安全？</td>
<td>Spring 不保证业务线程安全，需自行同步；Spring 只保证单例 Bean 的唯一性。</td>
</tr>
</tbody></table>
<hr>
<h2 id="七、高分总结模板（面试可直接复述）"><a href="#七、高分总结模板（面试可直接复述）" class="headerlink" title="七、高分总结模板（面试可直接复述）"></a>七、高分总结模板（面试可直接复述）</h2><blockquote>
<p>Spring Bean 的创建分为两大阶段：<br> <strong>实例化</strong>（反射创建对象）与 <strong>初始化</strong>（依赖注入 + 生命周期回调 + AOP 增强）。</p>
<p>流程包括：</p>
<ol>
<li>解析 BeanDefinition；</li>
<li>实例化 Bean；</li>
<li>属性注入；</li>
<li>调用 BeanPostProcessor（前置）；</li>
<li>执行初始化方法；</li>
<li>调用 BeanPostProcessor（后置，生成代理对象）；</li>
<li>注册单例 Bean。</li>
</ol>
<p>其中，通过三级缓存机制解决循环依赖问题，<br> 通过 BeanPostProcessor 实现 AOP、依赖注入等扩展功能。</p>
</blockquote>
<hr>
<h2 id="八、扩展问题（面试加分）"><a href="#八、扩展问题（面试加分）" class="headerlink" title="八、扩展问题（面试加分）"></a>八、扩展问题（面试加分）</h2><ol>
<li>Spring 中如何处理 Bean 循环依赖？（→ 三级缓存机制）</li>
<li>如果一个 Bean 是原型（prototype）作用域，循环依赖还能解决吗？</li>
<li>BeanPostProcessor 与 Aware 接口的执行顺序？</li>
<li>Spring Boot 自动装配与 Bean 创建过程的关系？</li>
<li>初始化时如何处理事务、AOP、@Transactional 注解？</li>
</ol>
<p>非常好 ✅ 王帅锴。<br> “<strong>Spring 常用注解及其作用机制</strong>”是中高级 Java 面试的基础高频题。<br> 如果你能在面试中不仅背出注解名称，还能说明<strong>底层原理、执行阶段、常见组合与陷阱</strong>，那就能体现出你是真正理解 Spring 框架的工程师，而不是仅仅“会用”。</p>
<hr>
<h1 id="🎯-面试题：Spring-中常用注解及其原理"><a href="#🎯-面试题：Spring-中常用注解及其原理" class="headerlink" title="🎯 面试题：Spring 中常用注解及其原理"></a>🎯 面试题：Spring 中常用注解及其原理</h1><hr>
<h2 id="一、考察点概览"><a href="#一、考察点概览" class="headerlink" title="一、考察点概览"></a>一、考察点概览</h2><p>面试官主要考察以下几个方面：</p>
<ol>
<li>是否能系统分类常用注解（核心、IOC、AOP、Web、Boot 等）。</li>
<li>是否理解注解与 Spring 容器（BeanFactory、ApplicationContext）的关系。</li>
<li>是否能解释注解背后的原理（如 <code>@ComponentScan</code> → ClassPathBeanDefinitionScanner）。</li>
<li>是否知道注解在 Bean 生命周期中的执行顺序（如 @Autowired 依赖注入阶段）。</li>
<li>是否清楚常见注解的使用陷阱与组合（如 @Controller + @ResponseBody &#x3D; @RestController）。</li>
</ol>
<hr>
<h2 id="二、Spring-注解体系总体分类"><a href="#二、Spring-注解体系总体分类" class="headerlink" title="二、Spring 注解体系总体分类"></a>二、Spring 注解体系总体分类</h2><table>
<thead>
<tr>
<th>分类</th>
<th>代表注解</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td><strong>1️⃣ 核心注解（IOC容器相关）</strong></td>
<td><code>@Component</code>、<code>@Repository</code>、<code>@Service</code>、<code>@Controller</code></td>
<td>声明 Bean 并由 Spring 管理</td>
</tr>
<tr>
<td><strong>2️⃣ 自动装配相关</strong></td>
<td><code>@Autowired</code>、<code>@Qualifier</code>、<code>@Resource</code></td>
<td>实现依赖注入</td>
</tr>
<tr>
<td><strong>3️⃣ 配置与声明类</strong></td>
<td><code>@Configuration</code>、<code>@ComponentScan</code>、<code>@Import</code>、<code>@Bean</code></td>
<td>声明配置类、加载 Bean、导入外部配置</td>
</tr>
<tr>
<td><strong>4️⃣ AOP 与事务</strong></td>
<td><code>@Aspect</code>、<code>@EnableAspectJAutoProxy</code>、<code>@Transactional</code></td>
<td>切面编程与事务管理</td>
</tr>
<tr>
<td><strong>5️⃣ Web 层注解</strong></td>
<td><code>@RestController</code>、<code>@Controller</code>、<code>@RequestMapping</code>、<code>@GetMapping</code>、<code>@RequestBody</code></td>
<td>Spring MVC 控制器层注解</td>
</tr>
<tr>
<td><strong>6️⃣ 生命周期与回调</strong></td>
<td><code>@PostConstruct</code>、<code>@PreDestroy</code></td>
<td>Bean 初始化与销毁钩子</td>
</tr>
<tr>
<td><strong>7️⃣ Spring Boot 扩展</strong></td>
<td><code>@SpringBootApplication</code>、<code>@EnableAutoConfiguration</code>、<code>@ConditionalOnXXX</code></td>
<td>自动装配与条件注入</td>
</tr>
</tbody></table>
<hr>
<h2 id="三、核心注解详解（IOC-组件声明）"><a href="#三、核心注解详解（IOC-组件声明）" class="headerlink" title="三、核心注解详解（IOC 组件声明）"></a>三、核心注解详解（IOC 组件声明）</h2><h3 id="1️⃣-Component"><a href="#1️⃣-Component" class="headerlink" title="1️⃣ @Component"></a>1️⃣ <code>@Component</code></h3><blockquote>
<p>表示当前类是一个组件，由 Spring 容器管理。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserService</span> &#123;&#125;</span><br></pre></td></tr></table></figure>

<p>📌 原理：<br> 在 <code>@ComponentScan</code> 扫描时，被扫描的类会被解析成 <code>BeanDefinition</code> 注册到 IOC 容器中。</p>
<hr>
<h3 id="2️⃣-Service、-Repository、-Controller"><a href="#2️⃣-Service、-Repository、-Controller" class="headerlink" title="2️⃣ @Service、@Repository、@Controller"></a>2️⃣ <code>@Service</code>、<code>@Repository</code>、<code>@Controller</code></h3><blockquote>
<p>它们本质上都是 <code>@Component</code> 的派生注解，<br> 只是用于不同的分层语义（业务、数据、控制层）。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserService</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Repository</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserRepository</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserController</span> &#123;&#125;</span><br></pre></td></tr></table></figure>

<p>📌 原理：</p>
<ul>
<li><code>@Repository</code> 具备额外的异常转换功能（PersistenceExceptionTranslationPostProcessor）。</li>
<li><code>@Controller</code> 会被 <code>RequestMappingHandlerMapping</code> 识别为 Web 控制器。</li>
<li><code>@RestController</code> &#x3D; <code>@Controller</code> + <code>@ResponseBody</code>（返回 JSON 数据）。</li>
</ul>
<hr>
<h2 id="四、依赖注入注解"><a href="#四、依赖注入注解" class="headerlink" title="四、依赖注入注解"></a>四、依赖注入注解</h2><table>
<thead>
<tr>
<th>注解</th>
<th>作用</th>
<th>特点与区别</th>
</tr>
</thead>
<tbody><tr>
<td><code>@Autowired</code></td>
<td>自动按类型注入</td>
<td>Spring 提供，支持构造器、字段、setter</td>
</tr>
<tr>
<td><code>@Qualifier</code></td>
<td>配合 @Autowired 指定 Bean 名称</td>
<td>按名称精确注入</td>
</tr>
<tr>
<td><code>@Resource</code></td>
<td>JSR-250 标准注解，默认按名称注入</td>
<td>兼容性好，可与非 Spring 框架集成</td>
</tr>
</tbody></table>
<h3 id="示例：-1"><a href="#示例：-1" class="headerlink" title="示例："></a>示例：</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OrderService</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="meta">@Qualifier(&quot;userServiceImpl&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> UserService userService;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>📌 常见陷阱：</p>
<ul>
<li>同类型多个 Bean 未使用 @Qualifier 时，会报 <code>NoUniqueBeanDefinitionException</code>。</li>
<li>构造器注入推荐使用 <code>@Autowired</code>，字段注入易于滥用。</li>
</ul>
<hr>
<h2 id="五、配置类相关注解（取代-XML-配置）"><a href="#五、配置类相关注解（取代-XML-配置）" class="headerlink" title="五、配置类相关注解（取代 XML 配置）"></a>五、配置类相关注解（取代 XML 配置）</h2><table>
<thead>
<tr>
<th>注解</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td><code>@Configuration</code></td>
<td>声明配置类，等价于 XML 配置文件</td>
</tr>
<tr>
<td><code>@ComponentScan</code></td>
<td>指定扫描包路径，自动发现 Bean</td>
</tr>
<tr>
<td><code>@Bean</code></td>
<td>定义 Bean 的创建方法（适合外部类或第三方对象）</td>
</tr>
<tr>
<td><code>@Import</code></td>
<td>导入额外的配置类或 Bean</td>
</tr>
<tr>
<td><code>@PropertySource</code></td>
<td>加载外部属性文件</td>
</tr>
<tr>
<td><code>@Value</code></td>
<td>注入配置文件中的属性值</td>
</tr>
</tbody></table>
<h3 id="示例：-2"><a href="#示例：-2" class="headerlink" title="示例："></a>示例：</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan(&quot;com.wms.service&quot;)</span></span><br><span class="line"><span class="meta">@PropertySource(&quot;classpath:application.properties&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AppConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> UserService <span class="title function_">userService</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">UserService</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>📌 原理：</p>
<ul>
<li>Spring 会通过 <code>ConfigurationClassPostProcessor</code> 解析 <code>@Configuration</code> 类。</li>
<li><code>@Bean</code> 方法在容器启动时执行，返回对象会注册进 BeanDefinition。</li>
</ul>
<hr>
<h2 id="六、AOP-与事务注解"><a href="#六、AOP-与事务注解" class="headerlink" title="六、AOP 与事务注解"></a>六、AOP 与事务注解</h2><table>
<thead>
<tr>
<th>注解</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td><code>@Aspect</code></td>
<td>声明一个切面类</td>
</tr>
<tr>
<td><code>@Pointcut</code></td>
<td>定义切点表达式</td>
</tr>
<tr>
<td><code>@Before</code>、<code>@After</code>、<code>@Around</code></td>
<td>定义通知逻辑</td>
</tr>
<tr>
<td><code>@EnableAspectJAutoProxy</code></td>
<td>开启 AOP 自动代理</td>
</tr>
<tr>
<td><code>@Transactional</code></td>
<td>声明事务管理</td>
</tr>
</tbody></table>
<h3 id="示例：-3"><a href="#示例：-3" class="headerlink" title="示例："></a>示例：</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LogAspect</span> &#123;</span><br><span class="line">    <span class="meta">@Before(&quot;execution(* com.wms.service.*.*(..))&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">beforeMethod</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Before method execute...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>📌 原理：</p>
<ul>
<li>Spring 通过 <code>AnnotationAwareAspectJAutoProxyCreator</code> 在 Bean 初始化后创建代理；</li>
<li><code>@Transactional</code> 通过 <code>TransactionInterceptor</code> 与 AOP 动态代理实现事务切面。</li>
</ul>
<hr>
<h2 id="七、Web-层常用注解（Spring-MVC）"><a href="#七、Web-层常用注解（Spring-MVC）" class="headerlink" title="七、Web 层常用注解（Spring MVC）"></a>七、Web 层常用注解（Spring MVC）</h2><table>
<thead>
<tr>
<th>注解</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td><code>@RestController</code></td>
<td>返回 JSON 的控制器</td>
</tr>
<tr>
<td><code>@RequestMapping</code></td>
<td>定义请求路径与方法映射</td>
</tr>
<tr>
<td><code>@GetMapping</code>、<code>@PostMapping</code></td>
<td>快捷请求映射</td>
</tr>
<tr>
<td><code>@RequestBody</code></td>
<td>将请求体反序列化为对象</td>
</tr>
<tr>
<td><code>@ResponseBody</code></td>
<td>将返回值序列化为 JSON</td>
</tr>
<tr>
<td><code>@PathVariable</code></td>
<td>绑定 URL 路径参数</td>
</tr>
<tr>
<td><code>@RequestParam</code></td>
<td>绑定请求参数</td>
</tr>
<tr>
<td><code>@CrossOrigin</code></td>
<td>允许跨域请求</td>
</tr>
</tbody></table>
<h3 id="示例：-4"><a href="#示例：-4" class="headerlink" title="示例："></a>示例：</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/user&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserController</span> &#123;</span><br><span class="line">    <span class="meta">@GetMapping(&quot;/&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> User <span class="title function_">getUser</span><span class="params">(<span class="meta">@PathVariable</span> Long id)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> userService.findById(id);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="八、生命周期与回调注解"><a href="#八、生命周期与回调注解" class="headerlink" title="八、生命周期与回调注解"></a>八、生命周期与回调注解</h2><table>
<thead>
<tr>
<th>注解</th>
<th>阶段</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>@PostConstruct</code></td>
<td>初始化前</td>
<td>在依赖注入完成后执行初始化逻辑</td>
</tr>
<tr>
<td><code>@PreDestroy</code></td>
<td>容器关闭前</td>
<td>在 Bean 销毁前执行清理逻辑</td>
</tr>
</tbody></table>
<h3 id="示例：-5"><a href="#示例：-5" class="headerlink" title="示例："></a>示例：</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@PostConstruct</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;Bean 初始化完成&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@PreDestroy</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">destroy</span><span class="params">()</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;Bean 即将销毁&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="九、Spring-Boot-注解体系（扩展）"><a href="#九、Spring-Boot-注解体系（扩展）" class="headerlink" title="九、Spring Boot 注解体系（扩展）"></a>九、Spring Boot 注解体系（扩展）</h2><table>
<thead>
<tr>
<th>注解</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>@SpringBootApplication</code></td>
<td>组合注解（<code>@Configuration</code> + <code>@ComponentScan</code> + <code>@EnableAutoConfiguration</code>）</td>
</tr>
<tr>
<td><code>@EnableAutoConfiguration</code></td>
<td>自动装配机制核心</td>
</tr>
<tr>
<td><code>@ConditionalOnXXX</code></td>
<td>条件装配控制，如 @ConditionalOnMissingBean</td>
</tr>
<tr>
<td><code>@ConfigurationProperties</code></td>
<td>绑定配置文件属性到 Bean</td>
</tr>
</tbody></table>
<hr>
<h2 id="十、常见追问与标准答案"><a href="#十、常见追问与标准答案" class="headerlink" title="十、常见追问与标准答案"></a>十、常见追问与标准答案</h2><table>
<thead>
<tr>
<th>面试官追问</th>
<th>高分回答</th>
</tr>
</thead>
<tbody><tr>
<td>@Autowired 和 @Resource 有何区别？</td>
<td>@Autowired 是 Spring 特有，默认按类型注入；@Resource 属于 JSR-250 标准，默认按名称注入。</td>
</tr>
<tr>
<td>@RestController 和 @Controller 区别？</td>
<td>@RestController &#x3D; @Controller + @ResponseBody，用于返回 JSON。</td>
</tr>
<tr>
<td>@Configuration 和 @Component 的区别？</td>
<td>@Configuration 声明配置类，支持 @Bean 方法代理；@Component 仅是普通 Bean。</td>
</tr>
<tr>
<td>@EnableAutoConfiguration 的原理？</td>
<td>通过 <code>spring.factories</code> 加载自动配置类（SPI 机制）。</td>
</tr>
<tr>
<td>如何自定义注解？</td>
<td>使用 @Target + @Retention 声明作用范围与生命周期，再结合 <code>ImportSelector</code> 实现逻辑。</td>
</tr>
</tbody></table>
<hr>
<h2 id="十一、高分总结模板（可背诵）"><a href="#十一、高分总结模板（可背诵）" class="headerlink" title="十一、高分总结模板（可背诵）"></a>十一、高分总结模板（可背诵）</h2><blockquote>
<p>Spring 注解体系主要围绕 IOC、AOP、Web、Boot 四大模块构建：</p>
<ul>
<li><code>@Component</code> 系：定义 Bean；</li>
<li><code>@Autowired</code> 系：实现依赖注入；</li>
<li><code>@Configuration</code> 系：定义配置类与 Bean；</li>
<li><code>@Aspect</code> 系：实现 AOP 增强；</li>
<li><code>@RestController</code> 系：构建 Web 层控制器。</li>
</ul>
<p>它们的实现依赖于 Spring 的后置处理器机制（如 BeanFactoryPostProcessor、BeanPostProcessor），<br> 通过反射与动态代理实现自动扫描、注入与增强。</p>
</blockquote>
<hr>
<h2 id="十二、扩展：面试官可能进一步追问"><a href="#十二、扩展：面试官可能进一步追问" class="headerlink" title="十二、扩展：面试官可能进一步追问"></a>十二、扩展：面试官可能进一步追问</h2><ol>
<li>Spring 是如何识别这些注解的？<br> 👉 通过 <code>ClassPathBeanDefinitionScanner</code> 扫描元注解 <code>@Component</code>。</li>
<li>Spring 如何处理组合注解（如 @SpringBootApplication）？<br> 👉 利用元注解机制（<code>@AliasFor</code>）与 <code>MergedAnnotationMetadata</code>。</li>
<li>@ConditionalOnBean 的原理？<br> 👉 基于 <code>Condition</code> 接口 + <code>ConditionEvaluator</code> 在解析阶段动态判断。</li>
</ol>
<h1 id="🎯-面试题：Spring-声明式事务在什么情况下会失效？"><a href="#🎯-面试题：Spring-声明式事务在什么情况下会失效？" class="headerlink" title="🎯 面试题：Spring 声明式事务在什么情况下会失效？"></a>🎯 面试题：Spring 声明式事务在什么情况下会失效？</h1><hr>
<h2 id="一、前置知识：Spring-声明式事务的原理"><a href="#一、前置知识：Spring-声明式事务的原理" class="headerlink" title="一、前置知识：Spring 声明式事务的原理"></a>一、前置知识：Spring 声明式事务的原理</h2><p>Spring 声明式事务的核心机制基于 <strong>AOP 动态代理</strong>。<br> 当你在方法上使用 <code>@Transactional</code> 注解时，Spring 会：</p>
<ol>
<li><strong>创建一个代理对象（JDK 动态代理或 CGLIB 代理）</strong></li>
<li><strong>在方法调用前后进行事务增强</strong>：<ul>
<li>调用前：开启事务（<code>TransactionInterceptor</code>）</li>
<li>调用后：提交事务或回滚事务</li>
</ul>
</li>
</ol>
<p>💡 <strong>注意：</strong><br> 只有通过 <strong>代理对象调用方法</strong> 时，Spring 才能在方法前后织入事务逻辑。<br> 如果方法是由“本类直接调用”，则事务逻辑会被绕过，这正是事务失效的根源之一。</p>
<hr>
<h2 id="二、常见的-8-种事务失效场景（含原理与解决方案）"><a href="#二、常见的-8-种事务失效场景（含原理与解决方案）" class="headerlink" title="二、常见的 8 种事务失效场景（含原理与解决方案）"></a>二、常见的 8 种事务失效场景（含原理与解决方案）</h2><hr>
<h3 id="①-同类方法内部调用（Self-Invocation）导致事务失效"><a href="#①-同类方法内部调用（Self-Invocation）导致事务失效" class="headerlink" title="① 同类方法内部调用（Self Invocation）导致事务失效"></a>① <strong>同类方法内部调用（Self Invocation）导致事务失效</strong></h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">    <span class="meta">@Transactional</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addUser</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 开启事务</span></span><br><span class="line">        saveUser();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">saveUser</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 本类调用本类方法，没有经过代理！</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>🧠 原理：</p>
<ul>
<li>Spring 通过代理类增强 <code>@Transactional</code>；</li>
<li>但 <code>this.saveUser()</code> 调用是直接调用自身方法，没有经过代理对象；</li>
<li>因此事务增强逻辑（开启&#x2F;提交&#x2F;回滚）根本不会触发。</li>
</ul>
<p>✅ 解决方案：</p>
<ol>
<li><p>把 <code>saveUser()</code> 移到另一个 Service 中，由代理对象调用；</p>
</li>
<li><p>或者在容器中获取自己：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">((UserService) AopContext.currentProxy()).saveUser();</span><br></pre></td></tr></table></figure>

<p>前提：<code>@EnableAspectJAutoProxy(exposeProxy = true)</code>。</p>
</li>
</ol>
<hr>
<h3 id="②-方法不是-public-导致事务失效"><a href="#②-方法不是-public-导致事务失效" class="headerlink" title="② 方法不是 public 导致事务失效"></a>② <strong>方法不是 public 导致事务失效</strong></h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">updateUser</span><span class="params">()</span> &#123; ... &#125;</span><br></pre></td></tr></table></figure>

<p>🧠 原理：</p>
<ul>
<li>Spring AOP 只能代理 <code>public</code> 方法；</li>
<li>非 <code>public</code> 方法不会被代理（事务逻辑不会织入）。</li>
</ul>
<p>✅ 解决方案：</p>
<ul>
<li>保证带有 <code>@Transactional</code> 的方法是 <strong>public</strong>。</li>
</ul>
<hr>
<h3 id="③-异常类型错误（非运行时异常不回滚）"><a href="#③-异常类型错误（非运行时异常不回滚）" class="headerlink" title="③ 异常类型错误（非运行时异常不回滚）"></a>③ <strong>异常类型错误（非运行时异常不回滚）</strong></h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">updateUser</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Exception</span>(<span class="string">&quot;Checked Exception&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>🧠 原理：</p>
<ul>
<li>Spring 默认只对 <strong>运行时异常（RuntimeException 或 Error）</strong> 回滚；</li>
<li>检查型异常（Checked Exception）不会触发回滚。</li>
</ul>
<p>✅ 解决方案：</p>
<ul>
<li><p>显式指定回滚异常类型：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Transactional(rollbackFor = Exception.class)</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>或统一封装异常为运行时异常。</p>
</li>
</ul>
<hr>
<h3 id="④-异常被捕获导致事务失效"><a href="#④-异常被捕获导致事务失效" class="headerlink" title="④ 异常被捕获导致事务失效"></a>④ <strong>异常被捕获导致事务失效</strong></h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">updateUser</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 出错</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">1</span> / <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        <span class="comment">// 吞掉异常</span></span><br><span class="line">        System.out.println(<span class="string">&quot;异常被捕获&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>🧠 原理：</p>
<ul>
<li>Spring 通过 AOP 代理判断是否需要回滚；</li>
<li>若异常被捕获，外层代理检测不到异常 → 事务正常提交。</li>
</ul>
<p>✅ 解决方案：</p>
<ul>
<li><p>不要捕获异常；</p>
</li>
<li><p>或在捕获后手动标记回滚：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">TransactionAspectSupport.currentTransactionStatus().setRollbackOnly();</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h3 id="⑤-事务方法未被-Spring-管理"><a href="#⑤-事务方法未被-Spring-管理" class="headerlink" title="⑤ 事务方法未被 Spring 管理"></a>⑤ <strong>事务方法未被 Spring 管理</strong></h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">    <span class="meta">@Transactional</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">saveUser</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>🧠 原理：</p>
<ul>
<li>如果 <code>UserService</code> 未被 Spring 容器托管（例如自己 new 出来的对象），</li>
<li>Spring 无法生成代理对象 → 没有事务增强逻辑。</li>
</ul>
<p>✅ 解决方案：</p>
<ul>
<li>保证类上有 <code>@Component</code> &#x2F; <code>@Service</code>；</li>
<li>且由 Spring 容器注入使用。</li>
</ul>
<hr>
<h3 id="⑥-数据库不支持事务（或使用了错误的引擎）"><a href="#⑥-数据库不支持事务（或使用了错误的引擎）" class="headerlink" title="⑥ 数据库不支持事务（或使用了错误的引擎）"></a>⑥ <strong>数据库不支持事务（或使用了错误的引擎）</strong></h3><p>🧠 原理：</p>
<ul>
<li>如果使用 MySQL MyISAM 引擎，它不支持事务；</li>
<li>或者操作跨多个数据源但未使用分布式事务管理器。</li>
</ul>
<p>✅ 解决方案：</p>
<ul>
<li>使用支持事务的引擎（如 InnoDB）；</li>
<li>跨库事务需配置分布式事务（如 Atomikos、Seata）。</li>
</ul>
<hr>
<h3 id="⑦-多线程导致事务失效"><a href="#⑦-多线程导致事务失效" class="headerlink" title="⑦ 多线程导致事务失效"></a>⑦ <strong>多线程导致事务失效</strong></h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addUser</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; userMapper.insert(user)).start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>🧠 原理：</p>
<ul>
<li>新线程与当前事务上下文无关；</li>
<li>Spring 事务是基于 <code>ThreadLocal</code> 存储的；</li>
<li>新线程不会继承主线程的事务状态。</li>
</ul>
<p>✅ 解决方案：</p>
<ul>
<li>不要在事务方法中创建新线程；</li>
<li>或使用异步事务框架 &#x2F; 消息队列解耦。</li>
</ul>
<hr>
<h3 id="⑧-事务传播行为配置不当"><a href="#⑧-事务传播行为配置不当" class="headerlink" title="⑧ 事务传播行为配置不当"></a>⑧ <strong>事务传播行为配置不当</strong></h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Transactional(propagation = Propagation.NOT_SUPPORTED)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">updateUser</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 不开启事务</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>🧠 原理：</p>
<ul>
<li><code>NOT_SUPPORTED</code>、<code>NEVER</code> 等传播属性会禁止事务；</li>
<li>若嵌套调用时外层事务被挂起或关闭，也会失效。</li>
</ul>
<p>✅ 解决方案：</p>
<ul>
<li><p>确保传播行为满足业务逻辑，如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Transactional(propagation = Propagation.REQUIRED)</span></span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h2 id="三、事务失效问题定位技巧"><a href="#三、事务失效问题定位技巧" class="headerlink" title="三、事务失效问题定位技巧"></a>三、事务失效问题定位技巧</h2><table>
<thead>
<tr>
<th>工具</th>
<th>方法</th>
</tr>
</thead>
<tbody><tr>
<td><strong>日志调试</strong></td>
<td>打开 <code>org.springframework.transaction</code> 日志级别为 DEBUG</td>
</tr>
<tr>
<td><strong>AOP 检查</strong></td>
<td>确认方法是否通过代理对象调用</td>
</tr>
<tr>
<td><strong>事务传播链分析</strong></td>
<td>查看多层调用传播属性是否冲突</td>
</tr>
<tr>
<td><strong>事务管理器配置检查</strong></td>
<td>是否正确配置了 <code>DataSourceTransactionManager</code> 或 <code>JpaTransactionManager</code></td>
</tr>
</tbody></table>
<hr>
<h2 id="四、高分总结模板（面试可直接背诵）"><a href="#四、高分总结模板（面试可直接背诵）" class="headerlink" title="四、高分总结模板（面试可直接背诵）"></a>四、高分总结模板（面试可直接背诵）</h2><blockquote>
<p>在 Spring 中，声明式事务是基于 AOP 动态代理实现的。<br> 因此，事务只有在通过代理对象调用 <code>@Transactional</code> 方法时才会生效。<br> 常见的事务失效场景包括：</p>
<ol>
<li><strong>同类方法内部调用</strong>（未经过代理）；</li>
<li><strong>方法非 public</strong>；</li>
<li><strong>异常类型错误（非 RuntimeException 不回滚）</strong>；</li>
<li><strong>异常被捕获未重新抛出</strong>；</li>
<li><strong>方法未被 Spring 管理</strong>；</li>
<li><strong>数据库不支持事务</strong>；</li>
<li><strong>多线程导致 ThreadLocal 隔离</strong>；</li>
<li><strong>传播属性设置错误</strong>。</li>
</ol>
<p>核心本质：Spring 事务依赖代理 + AOP + ThreadLocal 机制，只能在代理边界内生效。</p>
</blockquote>
<h1 id="🎯-面试题：什么是嵌套事务？Spring-中是如何实现的？"><a href="#🎯-面试题：什么是嵌套事务？Spring-中是如何实现的？" class="headerlink" title="🎯 面试题：什么是嵌套事务？Spring 中是如何实现的？"></a>🎯 面试题：什么是嵌套事务？Spring 中是如何实现的？</h1><hr>
<h2 id="一、面试官考察点-5"><a href="#一、面试官考察点-5" class="headerlink" title="一、面试官考察点"></a>一、面试官考察点</h2><blockquote>
<p>💡 考察你是否理解：</p>
<ul>
<li>事务的传播机制（Propagation）</li>
<li>嵌套事务与独立事务的区别</li>
<li>Spring 如何实现嵌套事务（基于 <code>savepoint</code>）</li>
<li>嵌套事务的失效与回滚规则</li>
</ul>
</blockquote>
<hr>
<h2 id="二、30-秒速答版（面试简答）"><a href="#二、30-秒速答版（面试简答）" class="headerlink" title="二、30 秒速答版（面试简答）"></a>二、30 秒速答版（面试简答）</h2><blockquote>
<p>嵌套事务（Nested Transaction）是指：<br> <strong>在一个事务内部再开启一个子事务</strong>，<br> 当子事务回滚时，不影响外层事务，但外层事务回滚时，会导致子事务一并回滚。</p>
<p>在 Spring 中，通过 <code>@Transactional(propagation = Propagation.NESTED)</code> 实现，<br> 底层是基于数据库的 <strong>Savepoint（保存点）机制</strong> 实现的。</p>
</blockquote>
<hr>
<h2 id="三、详细解析（核心原理）"><a href="#三、详细解析（核心原理）" class="headerlink" title="三、详细解析（核心原理）"></a>三、详细解析（核心原理）</h2><hr>
<h3 id="1️⃣-嵌套事务的定义"><a href="#1️⃣-嵌套事务的定义" class="headerlink" title="1️⃣ 嵌套事务的定义"></a>1️⃣ 嵌套事务的定义</h3><p>假设有两个方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">parent</span><span class="params">()</span> &#123;</span><br><span class="line">    userService.saveUser();      <span class="comment">// 外层事务</span></span><br><span class="line">    orderService.createOrder();  <span class="comment">// 内层事务</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>createOrder()</code> 也加了事务注解：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Transactional(propagation = Propagation.NESTED)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">createOrder</span><span class="params">()</span> &#123; ... &#125;</span><br></pre></td></tr></table></figure>

<p>执行逻辑：</p>
<ul>
<li><code>parent()</code> 启动一个事务；</li>
<li>当执行到 <code>createOrder()</code> 时：<ul>
<li><strong>如果当前事务存在</strong>，则在当前事务中创建一个 <strong>保存点（Savepoint）</strong>；</li>
<li>内层事务出错时，Spring 会回滚到保存点，而不是整个外层事务；</li>
<li>外层事务仍然可以继续提交；</li>
<li>但如果外层事务回滚，内层事务也必须随之回滚。</li>
</ul>
</li>
</ul>
<blockquote>
<p>✅ 嵌套事务 &#x3D; 外层事务 + 子 Savepoint</p>
</blockquote>
<hr>
<h3 id="⚙️-2️⃣-Spring-的嵌套事务传播行为：Propagation-NESTED"><a href="#⚙️-2️⃣-Spring-的嵌套事务传播行为：Propagation-NESTED" class="headerlink" title="⚙️ 2️⃣ Spring 的嵌套事务传播行为：Propagation.NESTED"></a>⚙️ 2️⃣ Spring 的嵌套事务传播行为：<code>Propagation.NESTED</code></h3><p>Spring 中事务传播行为一共有 7 种：</p>
<table>
<thead>
<tr>
<th>传播行为</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td><code>REQUIRED</code></td>
<td>如果存在事务则加入，否则新建一个（最常用）</td>
</tr>
<tr>
<td><code>REQUIRES_NEW</code></td>
<td>每次都新建一个独立事务，暂停外层事务</td>
</tr>
<tr>
<td><code>NESTED</code></td>
<td>如果存在事务，则在当前事务中创建 <strong>保存点</strong>；否则新建事务</td>
</tr>
<tr>
<td><code>SUPPORTS</code></td>
<td>支持当前事务，无则非事务执行</td>
</tr>
<tr>
<td><code>NOT_SUPPORTED</code></td>
<td>非事务执行，若有事务则挂起</td>
</tr>
<tr>
<td><code>MANDATORY</code></td>
<td>必须在事务中执行，否则抛异常</td>
</tr>
<tr>
<td><code>NEVER</code></td>
<td>禁止事务执行，有事务则异常</td>
</tr>
</tbody></table>
<hr>
<h3 id="🔍-3️⃣-NESTED-与-REQUIRES-NEW-的区别（面试高频追问）"><a href="#🔍-3️⃣-NESTED-与-REQUIRES-NEW-的区别（面试高频追问）" class="headerlink" title="🔍 3️⃣ NESTED 与 REQUIRES_NEW 的区别（面试高频追问）"></a>🔍 3️⃣ NESTED 与 REQUIRES_NEW 的区别（面试高频追问）</h3><table>
<thead>
<tr>
<th>对比点</th>
<th>NESTED</th>
<th>REQUIRES_NEW</th>
</tr>
</thead>
<tbody><tr>
<td>是否新建事务</td>
<td>否，创建保存点</td>
<td>是，新建一个独立事务</td>
</tr>
<tr>
<td>外层事务回滚是否影响内层</td>
<td>是</td>
<td>否</td>
</tr>
<tr>
<td>内层事务回滚是否影响外层</td>
<td>否，仅回滚到保存点</td>
<td>否，各自独立</td>
</tr>
<tr>
<td>实现机制</td>
<td>Savepoint（同一连接）</td>
<td>新事务（新连接）</td>
</tr>
<tr>
<td>性能</td>
<td>较高（共用连接）</td>
<td>较低（切换连接）</td>
</tr>
<tr>
<td>典型场景</td>
<td>局部失败可恢复的业务</td>
<td>完全独立的业务逻辑</td>
</tr>
</tbody></table>
<p><strong>示例：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Transactional(propagation = Propagation.REQUIRED)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">parent</span><span class="params">()</span> &#123;</span><br><span class="line">    serviceA.methodA(); <span class="comment">// 外层事务</span></span><br><span class="line">    serviceB.methodB(); <span class="comment">// 内层嵌套事务</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>methodB()</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Transactional(propagation = Propagation.NESTED)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">methodB</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 嵌套事务操作</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行时会创建一个 <strong>Savepoint</strong>，异常时仅回滚 <code>methodB</code> 的修改。</p>
<hr>
<h3 id="🔧-4️⃣-底层原理分析（源码层）"><a href="#🔧-4️⃣-底层原理分析（源码层）" class="headerlink" title="🔧 4️⃣ 底层原理分析（源码层）"></a>🔧 4️⃣ 底层原理分析（源码层）</h3><p>在 <code>DataSourceTransactionManager</code> 中：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (isExistingTransaction(transaction)) &#123;</span><br><span class="line">    <span class="keyword">if</span> (definition.getPropagationBehavior() == PROPAGATION_NESTED) &#123;</span><br><span class="line">        <span class="comment">// 创建保存点</span></span><br><span class="line">        <span class="type">Savepoint</span> <span class="variable">savepoint</span> <span class="operator">=</span> transaction.createSavepoint();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>说明：嵌套事务通过底层数据库连接的 Savepoint 来实现回滚局部事务。</p>
</blockquote>
<hr>
<h3 id="⚠️-5️⃣-嵌套事务的失效场景（常见陷阱）"><a href="#⚠️-5️⃣-嵌套事务的失效场景（常见陷阱）" class="headerlink" title="⚠️ 5️⃣ 嵌套事务的失效场景（常见陷阱）"></a>⚠️ 5️⃣ 嵌套事务的失效场景（常见陷阱）</h3><ol>
<li><p><strong>使用非支持保存点的数据库</strong></p>
<ul>
<li>比如某些 MySQL 引擎（MyISAM）不支持事务保存点；</li>
<li>只能使用 InnoDB。</li>
</ul>
</li>
<li><p><strong>不同事务管理器 &#x2F; 不同数据源</strong></p>
<ul>
<li>嵌套事务要求使用同一个 <code>DataSourceTransactionManager</code>；</li>
<li>否则无法共用连接。</li>
</ul>
</li>
<li><p><strong>嵌套调用在同类中自调用</strong></p>
<ul>
<li>Spring 的事务是基于代理的；</li>
<li>同类内部方法直接调用不会触发代理，事务失效。</li>
</ul>
<p>✅ 解决方案：</p>
<ul>
<li>使用 <code>AopContext.currentProxy()</code> 调用；</li>
<li>或者通过另一个 Bean 注入自身调用。</li>
</ul>
</li>
<li><p><strong>异常未被 Spring 感知</strong></p>
<ul>
<li>如果子事务抛出异常被 <code>try/catch</code> 捕获且未抛出，事务不会回滚。</li>
</ul>
</li>
</ol>
<hr>
<h3 id="📚-6️⃣-嵌套事务的典型应用场景"><a href="#📚-6️⃣-嵌套事务的典型应用场景" class="headerlink" title="📚 6️⃣ 嵌套事务的典型应用场景"></a>📚 6️⃣ 嵌套事务的典型应用场景</h3><table>
<thead>
<tr>
<th>场景</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>局部业务可回滚</td>
<td>某部分失败不影响主事务（如订单部分失败但主流程继续）</td>
</tr>
<tr>
<td>批量处理部分回滚</td>
<td>批处理任务，单条失败可回滚到保存点</td>
</tr>
<tr>
<td>工作流</td>
<td>多步骤任务，局部异常只回滚该节点</td>
</tr>
</tbody></table>
<hr>
<h3 id="💡-示例代码（带回滚演示）"><a href="#💡-示例代码（带回滚演示）" class="headerlink" title="💡 示例代码（带回滚演示）"></a>💡 示例代码（带回滚演示）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OrderService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> PaymentService paymentService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Transactional</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">createOrder</span><span class="params">()</span> &#123;</span><br><span class="line">        saveOrder(); <span class="comment">// 外层事务</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            paymentService.pay(); <span class="comment">// 内层嵌套事务</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;支付失败，订单继续&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PaymentService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Transactional(propagation = Propagation.NESTED)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">pay</span><span class="params">()</span> &#123;</span><br><span class="line">        savePayment();</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;模拟支付异常&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>输出：支付失败，订单继续。<br> ✅ 外层事务成功提交，内层事务自动回滚到保存点。</p>
</blockquote>
<hr>
<h3 id="⚙️-7️⃣-性能与事务深度分析"><a href="#⚙️-7️⃣-性能与事务深度分析" class="headerlink" title="⚙️ 7️⃣ 性能与事务深度分析"></a>⚙️ 7️⃣ 性能与事务深度分析</h3><table>
<thead>
<tr>
<th>层次</th>
<th>事务类型</th>
<th>性能</th>
<th>数据库连接</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>REQUIRES_NEW</td>
<td>新事务</td>
<td>中等</td>
<td>新连接</td>
<td>完全独立</td>
</tr>
<tr>
<td>NESTED</td>
<td>保存点</td>
<td>高</td>
<td>共享连接</td>
<td>可局部回滚</td>
</tr>
</tbody></table>
<blockquote>
<p>嵌套事务是“轻量级的局部回滚”，而非完全独立的事务。</p>
</blockquote>
<hr>
<h2 id="八、面试加分总结（可背诵版）"><a href="#八、面试加分总结（可背诵版）" class="headerlink" title="八、面试加分总结（可背诵版）"></a>八、面试加分总结（可背诵版）</h2><blockquote>
<p>嵌套事务（Nested Transaction）是指在一个事务中创建子事务。<br> 在 Spring 中通过 <code>@Transactional(propagation = Propagation.NESTED)</code> 实现，<br> 底层基于数据库的 <strong>Savepoint 机制</strong>。<br> 子事务回滚时仅回滚到保存点，不影响外层事务；<br> 外层事务回滚会连带子事务一起回滚。</p>
<p>它与 <code>REQUIRES_NEW</code> 最大的区别是：</p>
<ul>
<li>NESTED 共用连接，性能高，可局部回滚；</li>
<li>REQUIRES_NEW 新建事务，完全独立但成本更高。</li>
</ul>
<p>在批处理、局部回滚等业务中非常有用。</p>
</blockquote>
<h1 id="🎯-面试题：外部事务回滚，子事务也必然会回滚吗？"><a href="#🎯-面试题：外部事务回滚，子事务也必然会回滚吗？" class="headerlink" title="🎯 面试题：外部事务回滚，子事务也必然会回滚吗？"></a>🎯 面试题：外部事务回滚，子事务也必然会回滚吗？</h1><hr>
<h2 id="一、面试速答（标准答法）"><a href="#一、面试速答（标准答法）" class="headerlink" title="一、面试速答（标准答法）"></a>一、面试速答（标准答法）</h2><blockquote>
<p>✅ <strong>是的，如果使用的是 Propagation.NESTED 嵌套事务，外部事务回滚时，子事务一定会回滚。</strong></p>
<p>因为嵌套事务与外部事务共用同一个数据库连接，子事务的保存点（Savepoint）是在外层事务中创建的，<br> 一旦外层事务回滚，整个事务上下文会回滚到事务开始前的状态——包括子事务的修改。</p>
</blockquote>
<hr>
<h2 id="二、深入原理解析"><a href="#二、深入原理解析" class="headerlink" title="二、深入原理解析"></a>二、深入原理解析</h2><h3 id="1️⃣-NESTED-的本质：同一事务、保存点机制"><a href="#1️⃣-NESTED-的本质：同一事务、保存点机制" class="headerlink" title="1️⃣ NESTED 的本质：同一事务、保存点机制"></a>1️⃣ NESTED 的本质：<strong>同一事务、保存点机制</strong></h3><p>Spring 在处理 <code>Propagation.NESTED</code> 时，不会创建一个全新的事务，而是在外层事务中：</p>
<ul>
<li><strong>创建一个保存点（Savepoint）</strong></li>
<li>在执行子事务时，数据库会记录此保存点之前的状态；</li>
<li>如果子事务异常，Spring 可以回滚到该保存点；</li>
<li>但如果外层事务回滚，整个事务上下文都会被回滚，包括所有保存点。</li>
</ul>
<hr>
<h3 id="2️⃣-底层执行逻辑（伪源码）"><a href="#2️⃣-底层执行逻辑（伪源码）" class="headerlink" title="2️⃣ 底层执行逻辑（伪源码）"></a>2️⃣ 底层执行逻辑（伪源码）</h3><p>在 <code>DataSourceTransactionManager</code> 中：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (isExistingTransaction(transaction)) &#123;</span><br><span class="line">    <span class="keyword">if</span> (definition.getPropagationBehavior() == PROPAGATION_NESTED) &#123;</span><br><span class="line">        <span class="comment">// 在当前事务中创建保存点</span></span><br><span class="line">        <span class="type">Savepoint</span> <span class="variable">savepoint</span> <span class="operator">=</span> transaction.createSavepoint();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 执行子事务逻辑</span></span><br><span class="line">            method.invoke(target, args);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            transaction.rollbackToSavepoint(savepoint);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>💡 当外层事务 later 回滚时，Spring 会调用：</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">transaction.rollback();</span><br></pre></td></tr></table></figure>

<p>这会直接撤销整个连接上的所有修改，包括之前的保存点。</p>
<hr>
<h3 id="3️⃣-与-REQUIRES-NEW-的对比（非常关键）"><a href="#3️⃣-与-REQUIRES-NEW-的对比（非常关键）" class="headerlink" title="3️⃣ 与 REQUIRES_NEW 的对比（非常关键）"></a>3️⃣ 与 REQUIRES_NEW 的对比（非常关键）</h3><table>
<thead>
<tr>
<th>传播类型</th>
<th>是否共享事务连接</th>
<th>外层回滚对子事务影响</th>
<th>子事务异常对外层影响</th>
<th>实现机制</th>
</tr>
</thead>
<tbody><tr>
<td><strong>NESTED</strong></td>
<td>✅ 同一事务连接</td>
<td>✅ 必然回滚</td>
<td>❌ 可回滚到保存点</td>
<td>Savepoint</td>
</tr>
<tr>
<td><strong>REQUIRES_NEW</strong></td>
<td>❌ 独立连接</td>
<td>❌ 不影响</td>
<td>❌ 独立提交</td>
<td>新事务、独立连接</td>
</tr>
</tbody></table>
<blockquote>
<p>⚠️ 因此，<strong>只有 NESTED 会被外层事务联动回滚。</strong><br> 而 REQUIRES_NEW 是完全独立的事务，外层失败不会影响它。</p>
</blockquote>
<hr>
<h3 id="4️⃣-举个实际例子"><a href="#4️⃣-举个实际例子" class="headerlink" title="4️⃣ 举个实际例子"></a>4️⃣ 举个实际例子</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OrderService</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> PaymentService paymentService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Transactional</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">createOrder</span><span class="params">()</span> &#123;</span><br><span class="line">        saveOrder();</span><br><span class="line">        paymentService.pay();</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;外层事务异常&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PaymentService</span> &#123;</span><br><span class="line">    <span class="meta">@Transactional(propagation = Propagation.NESTED)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">pay</span><span class="params">()</span> &#123;</span><br><span class="line">        savePayment();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="执行结果："><a href="#执行结果：" class="headerlink" title="执行结果："></a>执行结果：</h4><ul>
<li><code>pay()</code> 创建了一个保存点；</li>
<li>当外层 <code>createOrder()</code> 抛出异常；</li>
<li>Spring 回滚整个事务（包括保存点）；</li>
<li>✅ 所以 <code>savePayment()</code> 的数据也被回滚。</li>
</ul>
<hr>
<h3 id="5️⃣-如果改成-REQUIRES-NEW"><a href="#5️⃣-如果改成-REQUIRES-NEW" class="headerlink" title="5️⃣ 如果改成 REQUIRES_NEW"></a>5️⃣ 如果改成 REQUIRES_NEW</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Transactional(propagation = Propagation.REQUIRES_NEW)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">pay</span><span class="params">()</span> &#123;</span><br><span class="line">    savePayment();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="执行结果：-1"><a href="#执行结果：-1" class="headerlink" title="执行结果："></a>执行结果：</h4><ul>
<li>外层 <code>createOrder()</code> 失败；</li>
<li>内层事务因为是新事务，已经独立提交；</li>
<li>❌ 外层事务回滚不会影响 <code>savePayment()</code>，它依旧提交成功。</li>
</ul>
<hr>
<h2 id="三、总结逻辑（面试可复述版）"><a href="#三、总结逻辑（面试可复述版）" class="headerlink" title="三、总结逻辑（面试可复述版）"></a>三、总结逻辑（面试可复述版）</h2><blockquote>
<ul>
<li>嵌套事务（<code>NESTED</code>）与外层事务共用同一连接，通过 Savepoint 实现局部回滚；</li>
<li>外层事务回滚时，整个事务链（包括子事务保存点）都会被回滚；</li>
<li>子事务回滚不会影响外层事务，外层事务仍可继续执行；</li>
<li>与之相反，<code>REQUIRES_NEW</code> 启动一个全新事务，互不影响。</li>
</ul>
</blockquote>
<hr>
<h2 id="四、常见追问与陷阱"><a href="#四、常见追问与陷阱" class="headerlink" title="四、常见追问与陷阱"></a>四、常见追问与陷阱</h2><table>
<thead>
<tr>
<th>追问</th>
<th>答案</th>
</tr>
</thead>
<tbody><tr>
<td>数据库是否必须支持 Savepoint？</td>
<td>是，MySQL 必须使用 InnoDB 引擎。</td>
</tr>
<tr>
<td>嵌套事务在不同事务管理器中会怎样？</td>
<td>不支持，会退化为普通 REQUIRED。</td>
</tr>
<tr>
<td>嵌套事务在自调用中失效的原因？</td>
<td>同类内部方法不会经过代理，AOP 事务不生效。</td>
</tr>
<tr>
<td>异步任务中嵌套事务是否生效？</td>
<td>不会生效，因为线程切换导致事务上下文丢失。</td>
</tr>
</tbody></table>
<hr>
<h2 id="五、高分总结（背诵模板）"><a href="#五、高分总结（背诵模板）" class="headerlink" title="五、高分总结（背诵模板）"></a>五、高分总结（背诵模板）</h2><blockquote>
<p>嵌套事务（NESTED）与外层事务共用同一个连接，基于 Savepoint 实现。</p>
<p>当<strong>外层事务回滚</strong>时，所有保存点都会被清除，因此子事务必然回滚；<br> 当<strong>子事务回滚</strong>时，只会回滚到保存点，不影响外层事务。</p>
<p>与之不同的是，<code>REQUIRES_NEW</code> 会新建一个独立事务，外层回滚不会影响内层。</p>
<p>嵌套事务适用于“局部失败可恢复”的业务逻辑，例如批处理、分步保存、局部回滚等场景。</p>
</blockquote>
<h1 id="🎯-面试题：Spring-事务的实现原理（-Transactional-底层机制）"><a href="#🎯-面试题：Spring-事务的实现原理（-Transactional-底层机制）" class="headerlink" title="🎯 面试题：Spring 事务的实现原理（@Transactional 底层机制）"></a>🎯 面试题：Spring 事务的实现原理（@Transactional 底层机制）</h1><hr>
<h2 id="一、面试官考察点-6"><a href="#一、面试官考察点-6" class="headerlink" title="一、面试官考察点"></a>一、面试官考察点</h2><blockquote>
<p>💡 考察开发者是否理解：</p>
<ul>
<li><code>@Transactional</code> 是如何生效的？</li>
<li>AOP 是如何代理事务方法的？</li>
<li>Spring 如何在方法执行前后开启、提交或回滚事务？</li>
<li>事务传播、回滚机制与数据库连接控制的关系。</li>
</ul>
</blockquote>
<hr>
<h2 id="二、30-秒速答（面试速答版）"><a href="#二、30-秒速答（面试速答版）" class="headerlink" title="二、30 秒速答（面试速答版）"></a>二、30 秒速答（面试速答版）</h2><blockquote>
<p>Spring 的事务实现原理是基于 <strong>AOP 动态代理 + 事务管理器（PlatformTransactionManager）</strong>。</p>
<p>当方法被 <code>@Transactional</code> 注解标记时，Spring 会在运行时为该类生成代理对象，<br> 在方法执行前后通过 <strong>AOP 拦截器（TransactionInterceptor）</strong> 进行拦截：</p>
<ul>
<li>在方法执行前开启事务；</li>
<li>正常执行则提交事务；</li>
<li>发生异常则回滚事务。</li>
</ul>
<p>事务的具体操作（开启、提交、回滚）由 <code>DataSourceTransactionManager</code> 调用底层数据库的连接对象完成。</p>
</blockquote>
<hr>
<h2 id="三、事务的整体执行流程"><a href="#三、事务的整体执行流程" class="headerlink" title="三、事务的整体执行流程"></a>三、事务的整体执行流程</h2><p>Spring 事务的核心流程如下 👇</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">┌───────────────────────────────┐</span><br><span class="line">│     @Transactional 方法调用   │</span><br><span class="line">└──────────────┬────────────────┘</span><br><span class="line">               │</span><br><span class="line">               ▼</span><br><span class="line">     [AOP 代理拦截]</span><br><span class="line">               │</span><br><span class="line">               ▼</span><br><span class="line">   TransactionInterceptor 拦截器</span><br><span class="line">               │</span><br><span class="line">        ┌──────┴────────┐</span><br><span class="line">        ▼               ▼</span><br><span class="line">  获取事务状态         判断传播行为</span><br><span class="line">        │</span><br><span class="line">        ▼</span><br><span class="line">  调用事务管理器 DataSourceTransactionManager</span><br><span class="line">        │</span><br><span class="line">        ▼</span><br><span class="line">  开启事务（setAutoCommit=false）</span><br><span class="line">        │</span><br><span class="line">        ▼</span><br><span class="line">  执行业务方法 (Method.invoke)</span><br><span class="line">        │</span><br><span class="line">        ▼</span><br><span class="line">  正常结束 → 提交事务(commit)</span><br><span class="line">  发生异常 → 回滚事务(rollback)</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="四、核心组件与职责划分"><a href="#四、核心组件与职责划分" class="headerlink" title="四、核心组件与职责划分"></a>四、核心组件与职责划分</h2><table>
<thead>
<tr>
<th>组件</th>
<th>作用</th>
<th>关键类</th>
</tr>
</thead>
<tbody><tr>
<td><code>@Transactional</code></td>
<td>声明事务边界</td>
<td>注解驱动</td>
</tr>
<tr>
<td><code>TransactionInterceptor</code></td>
<td>AOP 拦截器，负责事务增强</td>
<td>org.springframework.transaction.interceptor</td>
</tr>
<tr>
<td><code>TransactionAspectSupport</code></td>
<td>事务增强逻辑核心类</td>
<td>控制开启&#x2F;提交&#x2F;回滚</td>
</tr>
<tr>
<td><code>PlatformTransactionManager</code></td>
<td>事务管理器接口</td>
<td>核心事务操作定义</td>
</tr>
<tr>
<td><code>DataSourceTransactionManager</code></td>
<td>基于 JDBC 的事务管理器实现</td>
<td>真正调用数据库连接控制</td>
</tr>
<tr>
<td><code>TransactionSynchronizationManager</code></td>
<td>管理线程绑定的事务资源</td>
<td>用 ThreadLocal 保存连接与状态</td>
</tr>
</tbody></table>
<hr>
<h2 id="五、深入底层实现（源码级分析）"><a href="#五、深入底层实现（源码级分析）" class="headerlink" title="五、深入底层实现（源码级分析）"></a>五、深入底层实现（源码级分析）</h2><hr>
<h3 id="1️⃣-AOP-动态代理机制"><a href="#1️⃣-AOP-动态代理机制" class="headerlink" title="1️⃣ AOP 动态代理机制"></a>1️⃣ AOP 动态代理机制</h3><p>当 Spring 容器启动时，会扫描 <code>@Transactional</code> 注解的 Bean，<br> 并通过 <strong>AnnotationTransactionAttributeSource</strong> 解析注解元信息。</p>
<p>Spring 为这些 Bean 创建代理对象：</p>
<ul>
<li>若实现接口 → 使用 <strong>JDK 动态代理</strong>；</li>
<li>否则 → 使用 <strong>CGLIB 子类代理</strong>。</li>
</ul>
<p>代理对象的方法调用会被 <code>TransactionInterceptor</code> 拦截。</p>
<hr>
<h3 id="2️⃣-事务拦截器-TransactionInterceptor"><a href="#2️⃣-事务拦截器-TransactionInterceptor" class="headerlink" title="2️⃣ 事务拦截器 TransactionInterceptor"></a>2️⃣ 事务拦截器 TransactionInterceptor</h3><p>核心逻辑（简化版）：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(MethodInvocation invocation)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">    <span class="comment">// 1. 获取事务属性</span></span><br><span class="line">    <span class="type">TransactionAttribute</span> <span class="variable">txAttr</span> <span class="operator">=</span> getTransactionAttributeSource().getTransactionAttribute(method, targetClass);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 2. 获取事务管理器</span></span><br><span class="line">    <span class="type">PlatformTransactionManager</span> <span class="variable">txManager</span> <span class="operator">=</span> determineTransactionManager(txAttr);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 开启事务</span></span><br><span class="line">    <span class="type">TransactionStatus</span> <span class="variable">status</span> <span class="operator">=</span> txManager.getTransaction(txAttr);</span><br><span class="line"></span><br><span class="line">    Object result;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 4. 执行业务方法</span></span><br><span class="line">        result = invocation.proceed();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 5. 正常则提交事务</span></span><br><span class="line">        txManager.commit(status);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">        <span class="comment">// 6. 异常则回滚事务</span></span><br><span class="line">        txManager.rollback(status);</span><br><span class="line">        <span class="keyword">throw</span> ex;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>✅ Spring 在方法执行前开启事务，在方法结束后决定提交或回滚。<br> 所有逻辑都在 AOP 拦截器中完成。</p>
</blockquote>
<hr>
<h3 id="3️⃣-事务管理器-PlatformTransactionManager"><a href="#3️⃣-事务管理器-PlatformTransactionManager" class="headerlink" title="3️⃣ 事务管理器 PlatformTransactionManager"></a>3️⃣ 事务管理器 PlatformTransactionManager</h3><p>Spring 通过 <code>PlatformTransactionManager</code> 提供统一的事务接口：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">PlatformTransactionManager</span> &#123;</span><br><span class="line">    TransactionStatus <span class="title function_">getTransaction</span><span class="params">(TransactionDefinition definition)</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">commit</span><span class="params">(TransactionStatus status)</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">rollback</span><span class="params">(TransactionStatus status)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>常见实现：</p>
<table>
<thead>
<tr>
<th>实现类</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>DataSourceTransactionManager</code></td>
<td>JDBC 数据源事务（最常用）</td>
</tr>
<tr>
<td><code>JpaTransactionManager</code></td>
<td>JPA 实现</td>
</tr>
<tr>
<td><code>HibernateTransactionManager</code></td>
<td>Hibernate 实现</td>
</tr>
<tr>
<td><code>JtaTransactionManager</code></td>
<td>分布式事务（JTA）</td>
</tr>
</tbody></table>
<hr>
<h3 id="4️⃣-JDBC-层事务控制"><a href="#4️⃣-JDBC-层事务控制" class="headerlink" title="4️⃣ JDBC 层事务控制"></a>4️⃣ JDBC 层事务控制</h3><p>以 <code>DataSourceTransactionManager</code> 为例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 开启事务</span></span><br><span class="line"><span class="type">Connection</span> <span class="variable">con</span> <span class="operator">=</span> DataSourceUtils.getConnection(dataSource);</span><br><span class="line">con.setAutoCommit(<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 提交事务</span></span><br><span class="line">con.commit();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 回滚事务</span></span><br><span class="line">con.rollback();</span><br></pre></td></tr></table></figure>

<blockquote>
<p>Spring 实际是通过操作 JDBC Connection 的自动提交模式来控制事务边界。</p>
</blockquote>
<hr>
<h3 id="5️⃣-ThreadLocal-线程绑定机制"><a href="#5️⃣-ThreadLocal-线程绑定机制" class="headerlink" title="5️⃣ ThreadLocal 线程绑定机制"></a>5️⃣ ThreadLocal 线程绑定机制</h3><p>Spring 事务是 <strong>线程级别的</strong>。<br> 每个事务在当前线程中绑定一个数据库连接：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">TransactionSynchronizationManager.bindResource(dataSource, connection);</span><br></pre></td></tr></table></figure>

<p>当方法嵌套调用时，通过 <code>ThreadLocal</code> 获取当前事务状态，从而实现事务传播行为。</p>
<blockquote>
<p>⚠️ 因此在使用多线程或异步执行时，事务上下文无法传播（事务会失效）。</p>
</blockquote>
<hr>
<h2 id="六、事务传播机制（Propagation）"><a href="#六、事务传播机制（Propagation）" class="headerlink" title="六、事务传播机制（Propagation）"></a>六、事务传播机制（Propagation）</h2><p>Spring 支持 7 种传播行为（<code>Propagation</code> 枚举），核心在于“<strong>当前线程是否存在事务</strong>”：</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>含义</th>
<th>是否新建事务</th>
</tr>
</thead>
<tbody><tr>
<td><code>REQUIRED</code></td>
<td>有事务加入，无则新建</td>
<td>否（默认）</td>
</tr>
<tr>
<td><code>REQUIRES_NEW</code></td>
<td>始终新建新事务，挂起当前事务</td>
<td>是</td>
</tr>
<tr>
<td><code>NESTED</code></td>
<td>同连接创建保存点</td>
<td>否</td>
</tr>
<tr>
<td><code>SUPPORTS</code></td>
<td>有事务则加入，无则非事务执行</td>
<td>否</td>
</tr>
<tr>
<td><code>NOT_SUPPORTED</code></td>
<td>非事务执行，挂起事务</td>
<td>否</td>
</tr>
<tr>
<td><code>MANDATORY</code></td>
<td>必须在事务中，否则异常</td>
<td>否</td>
</tr>
<tr>
<td><code>NEVER</code></td>
<td>禁止事务，有事务则异常</td>
<td>否</td>
</tr>
</tbody></table>
<hr>
<h2 id="七、事务回滚机制"><a href="#七、事务回滚机制" class="headerlink" title="七、事务回滚机制"></a>七、事务回滚机制</h2><h3 id="1️⃣-回滚条件"><a href="#1️⃣-回滚条件" class="headerlink" title="1️⃣ 回滚条件"></a>1️⃣ 回滚条件</h3><p>默认情况下：</p>
<ul>
<li><strong>仅在发生 RuntimeException 或 Error 时才回滚</strong>；</li>
<li>CheckedException 不会触发回滚。</li>
</ul>
<p>可通过注解配置改变：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Transactional(rollbackFor = Exception.class)</span></span><br></pre></td></tr></table></figure>

<hr>
<h3 id="2️⃣-回滚流程（源码）"><a href="#2️⃣-回滚流程（源码）" class="headerlink" title="2️⃣ 回滚流程（源码）"></a>2️⃣ 回滚流程（源码）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">rollback</span><span class="params">(TransactionStatus status)</span> &#123;</span><br><span class="line">    <span class="type">Connection</span> <span class="variable">con</span> <span class="operator">=</span> DataSourceUtils.getConnection(dataSource);</span><br><span class="line">    con.rollback();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Spring 调用 JDBC Connection 的回滚方法实现真正的数据库回滚。</p>
<hr>
<h2 id="八、事务失效的常见原因（面试高频陷阱）"><a href="#八、事务失效的常见原因（面试高频陷阱）" class="headerlink" title="八、事务失效的常见原因（面试高频陷阱）"></a>八、事务失效的常见原因（面试高频陷阱）</h2><table>
<thead>
<tr>
<th>场景</th>
<th>原因</th>
<th>解决方案</th>
</tr>
</thead>
<tbody><tr>
<td>同类内部方法调用</td>
<td>未经过 AOP 代理</td>
<td>通过 <code>AopContext.currentProxy()</code> 调用</td>
</tr>
<tr>
<td>异步方法中执行</td>
<td>新线程无事务上下文</td>
<td>需手动传递事务或使用分布式事务</td>
</tr>
<tr>
<td>异常被捕获未抛出</td>
<td>Spring 感知不到异常</td>
<td>手动 <code>TransactionAspectSupport.currentTransactionStatus().setRollbackOnly()</code></td>
</tr>
<tr>
<td>方法非 public</td>
<td>AOP 无法代理</td>
<td>必须为 <code>public</code></td>
</tr>
<tr>
<td>事务管理器错误</td>
<td>不同数据源未绑定</td>
<td>指定正确的 <code>@Transactional(transactionManager = &quot;...&quot;)</code></td>
</tr>
</tbody></table>
<hr>
<h2 id="九、性能与设计分析"><a href="#九、性能与设计分析" class="headerlink" title="九、性能与设计分析"></a>九、性能与设计分析</h2><table>
<thead>
<tr>
<th>特性</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>事务粒度</td>
<td>方法级别（通过代理增强）</td>
</tr>
<tr>
<td>性能优化</td>
<td>使用 CGLIB 代理和连接缓存减少开销</td>
</tr>
<tr>
<td>线程安全</td>
<td>基于 ThreadLocal 实现</td>
</tr>
<tr>
<td>可扩展性</td>
<td>自定义事务拦截器、注解、传播机制</td>
</tr>
</tbody></table>
<hr>
<h2 id="🔥-十、一分钟高分总结（可背诵）"><a href="#🔥-十、一分钟高分总结（可背诵）" class="headerlink" title="🔥 十、一分钟高分总结（可背诵）"></a>🔥 十、一分钟高分总结（可背诵）</h2><blockquote>
<p>Spring 的事务实现是基于 <strong>AOP 动态代理</strong> 与 <strong>PlatformTransactionManager</strong> 的。<br> 当调用带 <code>@Transactional</code> 的方法时，Spring 创建代理对象并在方法执行前后进行增强：</p>
<ul>
<li>前置增强：获取连接、开启事务；</li>
<li>后置增强：提交或回滚事务；</li>
</ul>
<p>实际的事务控制是通过 <code>DataSourceTransactionManager</code> 调用 <strong>JDBC Connection</strong> 的 <code>commit()</code> 与 <code>rollback()</code> 完成；</p>
<p>事务信息通过 <strong>ThreadLocal</strong> 绑定到当前线程，实现事务传播。</p>
<p>这种机制让我们能用简单注解实现复杂的事务控制逻辑，同时保持解耦与灵活性。</p>
</blockquote>
<h1 id="🎯-面试题：Spring-Task-定时任务失败了如何重试？"><a href="#🎯-面试题：Spring-Task-定时任务失败了如何重试？" class="headerlink" title="🎯 面试题：Spring Task 定时任务失败了如何重试？"></a>🎯 面试题：Spring Task 定时任务失败了如何重试？</h1><hr>
<h2 id="一、面试官意图"><a href="#一、面试官意图" class="headerlink" title="一、面试官意图"></a>一、面试官意图</h2><blockquote>
<p>通过这个问题，考察候选人是否：</p>
<ul>
<li>了解 <code>@Scheduled</code> 的底层线程模型；</li>
<li>明白 Spring Task 默认的失败处理逻辑；</li>
<li>能设计出可自动重试、可监控、可恢复的任务执行机制；</li>
<li>能权衡“可靠性 vs 性能”的实现方式。</li>
</ul>
</blockquote>
<hr>
<h2 id="二、基础回答（30-秒面试速答版）"><a href="#二、基础回答（30-秒面试速答版）" class="headerlink" title="二、基础回答（30 秒面试速答版）"></a>二、基础回答（30 秒面试速答版）</h2><blockquote>
<p>Spring Task 本身 <strong>不会自动重试失败任务</strong>。<br> 如果定时任务执行过程中抛出异常，默认只是记录日志并结束执行，不会重试。</p>
<p>若要实现重试机制，可以通过以下几种方式实现：<br> 1️⃣ 在任务内部使用 <code>try-catch</code> + 重试逻辑；<br> 2️⃣ 使用 Spring 的 <code>@Retryable</code> 注解结合 <code>spring-retry</code> 实现自动重试；<br> 3️⃣ 使用 MQ 或任务表做“失败补偿”机制，手动调度重试；<br> 4️⃣ 使用分布式任务调度框架（如 XXL-Job &#x2F; Quartz &#x2F; ElasticJob）实现持久化与重试管理。</p>
</blockquote>
<hr>
<h2 id="三、Spring-Task-执行原理"><a href="#三、Spring-Task-执行原理" class="headerlink" title="三、Spring Task 执行原理"></a>三、Spring Task 执行原理</h2><p>Spring Task 的核心组件为 <code>TaskScheduler</code>，默认使用：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ThreadPoolTaskScheduler</span><br></pre></td></tr></table></figure>

<p>执行流程：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Scheduled 注解解析 → 注册任务（ScheduledAnnotationBeanPostProcessor）</span><br><span class="line">         ↓</span><br><span class="line">TaskScheduler.schedule(task, trigger)</span><br><span class="line">         ↓</span><br><span class="line">提交到线程池执行（ThreadPoolExecutor）</span><br><span class="line">         ↓</span><br><span class="line">任务执行 → 抛异常时线程终止（不会重试）</span><br></pre></td></tr></table></figure>

<p>⚠️ <strong>默认线程池不具备任务重试与失败恢复能力</strong>。<br> 如果任务在执行过程中发生异常，下次执行会按照 cron 表达式正常触发，但当前这次任务不会重试。</p>
<hr>
<h2 id="四、Spring-Task-任务失败的常见原因"><a href="#四、Spring-Task-任务失败的常见原因" class="headerlink" title="四、Spring Task 任务失败的常见原因"></a>四、Spring Task 任务失败的常见原因</h2><table>
<thead>
<tr>
<th>失败原因</th>
<th>说明</th>
<th>典型表现</th>
</tr>
</thead>
<tbody><tr>
<td>业务异常未捕获</td>
<td>异常中断执行</td>
<td>任务提前结束</td>
</tr>
<tr>
<td>线程池被阻塞</td>
<td>核心线程用尽</td>
<td>后续任务延迟甚至跳过</td>
</tr>
<tr>
<td>Cron 表达式错误</td>
<td>执行计划丢失</td>
<td>任务未执行</td>
</tr>
<tr>
<td>内存溢出 &#x2F; 死锁</td>
<td>线程无法释放</td>
<td>所有任务停滞</td>
</tr>
<tr>
<td>网络超时</td>
<td>外部接口失败</td>
<td>重试逻辑失效</td>
</tr>
</tbody></table>
<hr>
<h2 id="五、任务失败后的重试策略实现"><a href="#五、任务失败后的重试策略实现" class="headerlink" title="五、任务失败后的重试策略实现"></a>五、任务失败后的重试策略实现</h2><h3 id="✅-1️⃣-手动重试（try-catch-循环）"><a href="#✅-1️⃣-手动重试（try-catch-循环）" class="headerlink" title="✅ 1️⃣ 手动重试（try-catch + 循环）"></a>✅ 1️⃣ 手动重试（try-catch + 循环）</h3><p>适用于简单任务或接口调用失败场景。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Scheduled(cron = &quot;0 0/5 * * * ?&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">syncOrderTask</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">retryCount</span> <span class="operator">=</span> <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; retryCount; i++) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            callRemoteApi(); <span class="comment">// 调用外部接口</span></span><br><span class="line">            <span class="keyword">return</span>; <span class="comment">// 成功则退出</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            log.error(<span class="string">&quot;第&#123;&#125;次任务执行失败：&#123;&#125;&quot;</span>, i + <span class="number">1</span>, e.getMessage());</span><br><span class="line">            <span class="keyword">if</span> (i &lt; retryCount - <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123; Thread.sleep(<span class="number">2000</span>); &#125; <span class="keyword">catch</span> (InterruptedException ignored) &#123;&#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    log.error(<span class="string">&quot;任务重试3次仍失败，记录数据库等待人工处理&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>优点：简单直接<br> 缺点：代码冗余、不可配置、重试粒度粗</p>
<hr>
<h3 id="✅-2️⃣-使用-Retryable-注解（Spring-Retry）"><a href="#✅-2️⃣-使用-Retryable-注解（Spring-Retry）" class="headerlink" title="✅ 2️⃣ 使用 @Retryable 注解（Spring Retry）"></a>✅ 2️⃣ 使用 <code>@Retryable</code> 注解（Spring Retry）</h3><p>Spring Retry 是 Spring 官方推荐的 <strong>声明式重试机制</strong>。<br> 可以优雅地为定时任务增加自动重试功能。</p>
<h4 id="示例代码："><a href="#示例代码：" class="headerlink" title="示例代码："></a>示例代码：</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@EnableRetry</span> <span class="comment">// 启用重试机制</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RetryTask</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Retryable(</span></span><br><span class="line"><span class="meta">        value = &#123; Exception.class &#125;,</span></span><br><span class="line"><span class="meta">        maxAttempts = 3,</span></span><br><span class="line"><span class="meta">        backoff = @Backoff(delay = 2000, multiplier = 2))</span></span><br><span class="line">    <span class="meta">@Scheduled(cron = &quot;0 0/1 * * * ?&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">executeTask</span><span class="params">()</span> &#123;</span><br><span class="line">        log.info(<span class="string">&quot;执行定时任务...&quot;</span>);</span><br><span class="line">        riskyOperation(); <span class="comment">// 可能抛异常</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Recover</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">recover</span><span class="params">(Exception e)</span> &#123;</span><br><span class="line">        log.error(<span class="string">&quot;任务重试3次后仍失败，进入补偿逻辑，异常：&#123;&#125;&quot;</span>, e.getMessage());</span><br><span class="line">        <span class="comment">// 可记录数据库或发告警通知</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">riskyOperation</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;模拟失败&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>📘 原理：</p>
<ul>
<li><code>@Retryable</code> 会为该方法生成代理对象；</li>
<li>调用时若抛出异常，会根据配置自动重试；</li>
<li>最终失败后调用 <code>@Recover</code> 标注的方法进行补偿。</li>
</ul>
<hr>
<h3 id="✅-3️⃣-使用消息队列重试（业务补偿机制）"><a href="#✅-3️⃣-使用消息队列重试（业务补偿机制）" class="headerlink" title="✅ 3️⃣ 使用消息队列重试（业务补偿机制）"></a>✅ 3️⃣ 使用消息队列重试（业务补偿机制）</h3><blockquote>
<p>如果任务结果很重要（如订单同步、账务对账），建议采用 <strong>MQ + 数据库状态表</strong> 的方式实现可靠重试。</p>
</blockquote>
<p>思路：</p>
<p>1️⃣ 将任务执行状态记录到数据库（pending、success、failed）；<br> 2️⃣ 失败时发送到重试队列（MQ Topic）；<br> 3️⃣ 消费端监听并执行重试任务，成功则更新状态。</p>
<p>优点：</p>
<ul>
<li>持久化；</li>
<li>可追踪；</li>
<li>可分布式部署。</li>
</ul>
<hr>
<h3 id="✅-4️⃣-使用分布式调度框架（XXL-Job-Quartz）"><a href="#✅-4️⃣-使用分布式调度框架（XXL-Job-Quartz）" class="headerlink" title="✅ 4️⃣ 使用分布式调度框架（XXL-Job &#x2F; Quartz）"></a>✅ 4️⃣ 使用分布式调度框架（XXL-Job &#x2F; Quartz）</h3><blockquote>
<p>如果任务较多、需要监控与可视化重试，推荐使用 <strong>Quartz 或 XXL-Job</strong>。</p>
</blockquote>
<p>例如 <strong>Quartz</strong> 提供了 JobListener + TriggerListener：</p>
<ul>
<li>可在任务失败后重新触发；</li>
<li>支持 <code>JobDetail.setRequestsRecovery(true)</code>。</li>
</ul>
<hr>
<h2 id="六、最佳实践建议（工程级）"><a href="#六、最佳实践建议（工程级）" class="headerlink" title="六、最佳实践建议（工程级）"></a>六、最佳实践建议（工程级）</h2><table>
<thead>
<tr>
<th>场景</th>
<th>建议方案</th>
</tr>
</thead>
<tbody><tr>
<td>简单任务</td>
<td>try-catch + 手动重试</td>
</tr>
<tr>
<td>中等复杂度任务</td>
<td>@Retryable + @Recover</td>
</tr>
<tr>
<td>核心任务 &#x2F; 对外接口</td>
<td>MQ + 补偿表</td>
</tr>
<tr>
<td>分布式系统</td>
<td>使用分布式调度框架（XXL-Job、ElasticJob）</td>
</tr>
<tr>
<td>高可用任务</td>
<td>增加监控告警（Prometheus + Grafana）</td>
</tr>
</tbody></table>
<hr>
<h2 id="七、常见追问与高分回答"><a href="#七、常见追问与高分回答" class="headerlink" title="七、常见追问与高分回答"></a>七、常见追问与高分回答</h2><h3 id="❓1️⃣-追问：如果任务失败后，整个应用重启了怎么办？"><a href="#❓1️⃣-追问：如果任务失败后，整个应用重启了怎么办？" class="headerlink" title="❓1️⃣ 追问：如果任务失败后，整个应用重启了怎么办？"></a>❓1️⃣ 追问：如果任务失败后，整个应用重启了怎么办？</h3><blockquote>
<p>Spring Task 是内存级调度，重启后任务状态会丢失。<br> 若需任务状态持久化，建议使用 <strong>Quartz、XXL-Job</strong> 等可存储任务执行记录的调度器。</p>
</blockquote>
<hr>
<h3 id="❓2️⃣-追问：任务执行中抛出异常，Spring-会停止后续执行吗？"><a href="#❓2️⃣-追问：任务执行中抛出异常，Spring-会停止后续执行吗？" class="headerlink" title="❓2️⃣ 追问：任务执行中抛出异常，Spring 会停止后续执行吗？"></a>❓2️⃣ 追问：任务执行中抛出异常，Spring 会停止后续执行吗？</h3><blockquote>
<p>不会。默认只记录日志，下一次任务仍会根据 Cron 继续执行。<br> 但如果线程池被阻塞或线程异常退出，可能导致任务跳过或延迟。</p>
</blockquote>
<hr>
<h3 id="❓3️⃣-追问：Spring-Task-支持集群模式下避免重复执行吗？"><a href="#❓3️⃣-追问：Spring-Task-支持集群模式下避免重复执行吗？" class="headerlink" title="❓3️⃣ 追问：Spring Task 支持集群模式下避免重复执行吗？"></a>❓3️⃣ 追问：Spring Task 支持集群模式下避免重复执行吗？</h3><blockquote>
<p>默认不支持。需要借助 <strong>分布式锁（Redis、Zookeeper）</strong> 实现单节点任务执行。</p>
</blockquote>
<hr>
<h2 id="八、性能分析与扩展话题"><a href="#八、性能分析与扩展话题" class="headerlink" title="八、性能分析与扩展话题"></a>八、性能分析与扩展话题</h2><table>
<thead>
<tr>
<th>方面</th>
<th>内容</th>
</tr>
</thead>
<tbody><tr>
<td>性能影响</td>
<td>重试次数多会增加线程占用，应控制最大次数与等待时间</td>
</tr>
<tr>
<td>可观察性</td>
<td>建议结合日志与任务表，追踪任务状态</td>
</tr>
<tr>
<td>幂等性</td>
<td>任务必须具备幂等特性，否则重试可能导致重复操作</td>
</tr>
<tr>
<td>监控方案</td>
<td>结合 Spring Actuator + Prometheus 监控任务执行率与失败率</td>
</tr>
</tbody></table>
<hr>
<h2 id="🔥-九、总结（可背诵版）"><a href="#🔥-九、总结（可背诵版）" class="headerlink" title="🔥 九、总结（可背诵版）"></a>🔥 九、总结（可背诵版）</h2><blockquote>
<p>Spring Task 默认不具备自动重试机制。<br> 当任务执行失败时，只会打印异常日志，不会重新执行。</p>
<p>若要实现可靠重试，可通过以下方式：<br> 1️⃣ 手动重试（try-catch）；<br> 2️⃣ 使用 <code>@Retryable</code> 注解自动重试；<br> 3️⃣ MQ 补偿机制；<br> 4️⃣ Quartz 或 XXL-Job 分布式调度框架。</p>
<p>在工程中还应配合：</p>
<ul>
<li>幂等性设计；</li>
<li>失败记录与告警；</li>
<li>分布式锁控制执行唯一性。</li>
</ul>
</blockquote>
</article><div class="post-copyright"><div class="copyright-cc-box"><i class="anzhiyufont anzhiyu-icon-copyright"></i></div><div class="post-copyright__author_box"><a class="post-copyright__author_img" href="/" title="头像"><img class="post-copyright__author_img_back" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://s2.loli.net/2022/11/07/QVWvrnAsuGxelbS.jpg" title="头像" alt="头像"><img class="post-copyright__author_img_front" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://s2.loli.net/2022/11/07/QVWvrnAsuGxelbS.jpg" title="头像" alt="头像"></a><div class="post-copyright__author_name">Wsk</div><div class="post-copyright__author_desc">Believe in yourself</div></div><div class="post-copyright__post__info"><a class="post-copyright__original" title="该文章为原创文章，注意版权协议" href="https://wsk0404.github.io/posts/6c92115f.html">原创</a><a class="post-copyright-title"><span onclick="rm.copyPageUrl('https://wsk0404.github.io/posts/6c92115f.html')">Spring</span></a></div><div class="post-tools" id="post-tools"><div class="post-tools-left"><div class="rewardLeftButton"><div class="post-reward" onclick="anzhiyu.addRewardMask()"><div class="reward-button button--animated" title="赞赏作者"><i class="anzhiyufont anzhiyu-icon-hand-heart-fill"></i>打赏作者</div><div class="reward-main"><div class="reward-all"><span class="reward-title">感谢你赐予我前进的力量</span><ul class="reward-group"><li class="reward-item"><a href="/./img/wechat.jpg" target="_blank"><img class="post-qr-code-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/./img/wechat.jpg" alt="微信"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="/./img/alipay.jpg" target="_blank"><img class="post-qr-code-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/./img/alipay.jpg" alt="支付宝"/></a><div class="post-qr-code-desc">支付宝</div></li></ul><a class="reward-main-btn" href="/about/#about-reward" target="_blank"><div class="reward-text">赞赏者名单</div><div class="reward-dec">因为你们的支持让我意识到写文章的价值🙏</div></a></div></div></div><div id="quit-box" onclick="anzhiyu.removeRewardMask()" style="display: none"></div><div class="reward-link mode"><a class="reward-link-button" href="/wecaht/"><i class="anzhiyufont anzhiyu-icon-plant-fill"></i>运营模式与责任</a></div></div><div class="shareRight"><div class="share-link mobile"><div class="share-qrcode"><div class="share-button" title="使用手机访问这篇文章"><i class="anzhiyufont anzhiyu-icon-qrcode"></i></div><div class="share-main"><div class="share-main-all"><div id="qrcode" title="https://wsk0404.github.io/posts/6c92115f.html"></div><div class="reward-dec">使用手机访问这篇文章</div></div></div></div></div><div class="share-link weibo"><a class="share-button" target="_blank" href="https://service.weibo.com/share/share.php?title=Spring&amp;url=https://wsk0404.github.io/posts/6c92115f.html&amp;pic=https://s2.loli.net/2025/10/23/g4UkwyDri9BWZtE.jpg?_r_=95828ad5-7d6d-d56f-f27a-6610327ee6f0" rel="external nofollow noreferrer noopener"><i class="anzhiyufont anzhiyu-icon-weibo"></i></a></div><div class="share-link copyurl"><div class="share-button" id="post-share-url" title="复制链接" onclick="rm.copyPageUrl()"><i class="anzhiyufont anzhiyu-icon-link"></i></div></div></div></div></div><div class="post-copyright__notice"><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://wsk0404.github.io" target="_blank">Wsk Blog</a>！</span></div></div><div class="post-tools-right"><div class="tag_share"><div class="post-meta__box"><div class="post-meta__box__tag-list"><a class="post-meta__box__tags" href="/tags/IOC/"><span class="tags-punctuation"> <i class="anzhiyufont anzhiyu-icon-tag"></i></span>IOC<span class="tagsPageCount">2</span></a><a class="post-meta__box__tags" href="/tags/AOP/"><span class="tags-punctuation"> <i class="anzhiyufont anzhiyu-icon-tag"></i></span>AOP<span class="tagsPageCount">2</span></a></div></div></div><div class="post_share"><div class="social-share" data-image="https://s2.loli.net/2025/10/23/SurYK9kV8bRd2Ll.jpg?_r_=41e375ff-0cff-cb57-3980-a8c55b88e4db" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.cbd.int/butterfly-extsrc@1.1.3/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"/><script src="https://cdn.cbd.int/butterfly-extsrc@1.1.3/sharejs/dist/js/social-share.min.js" defer="defer"></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/posts/a9cea93d.html"><img class="prev-cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://s2.loli.net/2025/10/23/w3ErpsQhncfDed2.jpg?_r_=fa221af0-5611-e9d5-14a3-00eb665f569c" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">电商项目</div></div></a></div><div class="next-post pull-right"><a href="/posts/750d7523.html"><img class="next-cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://s2.loli.net/2025/10/23/wfbr2eNcL1VvXIn.png?_r_=3c733d3b-d548-0bdb-ecb9-a7013130f02b" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Spring Cloud</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="anzhiyufont anzhiyu-icon-thumbs-up fa-fw" style="font-size: 1.5rem; margin-right: 4px"></i><span>喜欢这篇文章的人也看了</span></div><div class="relatedPosts-list"><div><a href="/posts/73f99711.html" title="Spring MVC"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://s2.loli.net/2025/10/23/5MFUXBI3EhCAx6y.jpg?_r_=9a77e673-6589-7230-5662-a3bef3984e17" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2025-11-03</div><div class="title">Spring MVC</div></div></a></div></div></div><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="anzhiyufont anzhiyu-icon-comments"></i><span> 评论</span></div><div class="comment-randomInfo"><a onclick="anzhiyu.addRandomCommentInfo()" href="javascript:void(0)">匿名评论</a><a href="/privacy" style="margin-left: 4px">隐私政策</a></div></div><div class="comment-wrap"><div><div class="vcomment" id="vcomment"></div></div></div></div><div class="comment-barrage"></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="card-content"><div class="author-info__sayhi" id="author-info__sayhi" onclick="anzhiyu.changeSayHelloText()"></div><div class="author-info-avatar"><img class="avatar-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://s2.loli.net/2022/11/07/QVWvrnAsuGxelbS.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/><div class="author-status"><img class="g-status" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/zc998800/cdn/face/gif/m17.gif" ait="status"/></div></div><div class="author-info__description">路慢其修远兮 吾将上下而求索</div><div class="author-info__bottom-group"><a class="author-info__bottom-group-left" href="/"><h1 class="author-info__name">Wsk</h1><div class="author-info__desc">Believe in yourself</div></a><div class="card-info-social-icons is-center"><a class="social-icon faa-parent animated-hover" href="https://github.com/gukeyang" target="_blank" title="Github"><i class="anzhiyufont anzhiyu-icon-github"></i></a><a class="social-icon faa-parent animated-hover" href="https://space.bilibili.com/1542898061" target="_blank" title="BiliBili"><i class="anzhiyufont anzhiyu-icon-bilibili"></i></a></div></div></div></div><div class="card-widget anzhiyu-right-widget" id="card-wechat" onclick="null"><div id="flip-wrapper"><div id="flip-content"><div class="face" style="background: url(https://bu.dusays.com/2023/01/13/63c02edf44033.png) center center / 100% no-repeat"></div><div class="back face" style="background: url(https://s2.loli.net/2023/10/19/vNio4QGBSX9x5lO.png) center center / 100% no-repeat"></div></div></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-bars"></i><span>文章目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%F0%9F%8E%AF-%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%9A%E8%81%8A%E8%81%8A%E4%BD%A0%E5%AF%B9-Spring-%E6%A1%86%E6%9E%B6%E7%9A%84%E7%90%86%E8%A7%A3"><span class="toc-number">1.</span> <span class="toc-text">🎯 面试题：聊聊你对 Spring 框架的理解</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E9%9D%A2%E8%AF%95%E5%AE%98%E8%80%83%E5%AF%9F%E7%82%B9"><span class="toc-number">1.1.</span> <span class="toc-text">一、面试官考察点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E3%80%81Spring-%E6%A1%86%E6%9E%B6%E7%AE%80%E4%BB%8B"><span class="toc-number">1.2.</span> <span class="toc-text">二、Spring 框架简介</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E3%80%81Spring-%E7%9A%84%E6%A0%B8%E5%BF%83%E7%90%86%E5%BF%B5"><span class="toc-number">1.3.</span> <span class="toc-text">三、Spring 的核心理念</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%EF%B8%8F%E2%83%A3-IOC%EF%BC%88Inversion-of-Control%EF%BC%89%E6%8E%A7%E5%88%B6%E5%8F%8D%E8%BD%AC"><span class="toc-number">1.3.1.</span> <span class="toc-text">1️⃣ IOC（Inversion of Control）控制反转</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%EF%B8%8F%E2%83%A3-AOP%EF%BC%88Aspect-Oriented-Programming%EF%BC%89%E9%9D%A2%E5%90%91%E5%88%87%E9%9D%A2%E7%BC%96%E7%A8%8B"><span class="toc-number">1.3.2.</span> <span class="toc-text">2️⃣ AOP（Aspect-Oriented Programming）面向切面编程</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9B%E3%80%81Spring-%E7%9A%84%E6%A0%B8%E5%BF%83%E6%A8%A1%E5%9D%97"><span class="toc-number">1.4.</span> <span class="toc-text">四、Spring 的核心模块</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%94%E3%80%81Spring-%E6%A1%86%E6%9E%B6%E5%B8%B8%E7%94%A8%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F"><span class="toc-number">1.5.</span> <span class="toc-text">五、Spring 框架常用设计模式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%AD%E3%80%81Spring-%E5%9C%A8-WMS-%E7%B3%BB%E7%BB%9F%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8%EF%BC%88%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98%EF%BC%89"><span class="toc-number">1.6.</span> <span class="toc-text">六、Spring 在 WMS 系统中的应用（项目实战）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%9C%85-%E5%85%A5%E5%BA%93%E6%A8%A1%E5%9D%97%E7%A4%BA%E4%BE%8B"><span class="toc-number">1.6.1.</span> <span class="toc-text">✅ 入库模块示例</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%83%E3%80%81%E6%80%A7%E8%83%BD%E4%B8%8E%E6%89%A9%E5%B1%95%E6%9C%BA%E5%88%B6"><span class="toc-number">1.7.</span> <span class="toc-text">七、性能与扩展机制</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%AB%E3%80%81%E9%9D%A2%E8%AF%95%E9%AB%98%E9%A2%91%E8%BF%BD%E9%97%AE"><span class="toc-number">1.8.</span> <span class="toc-text">八、面试高频追问</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B9%9D%E3%80%81%E9%AB%98%E5%88%86%E6%80%BB%E7%BB%93%E6%A8%A1%E6%9D%BF%EF%BC%88%E5%8F%AF%E7%9B%B4%E6%8E%A5%E8%83%8C%E8%AF%B5%EF%BC%89"><span class="toc-number">1.9.</span> <span class="toc-text">九、高分总结模板（可直接背诵）</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%F0%9F%8E%AF-%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%9A-Autowired-%E5%92%8C-Resource-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">2.</span> <span class="toc-text">🎯 面试题：@Autowired 和 @Resource 有什么区别？</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E9%9D%A2%E8%AF%95%E5%AE%98%E8%80%83%E5%AF%9F%E7%82%B9-1"><span class="toc-number">2.1.</span> <span class="toc-text">一、面试官考察点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E3%80%81%E6%A0%B8%E5%BF%83%E9%80%9F%E7%AD%94%EF%BC%8830-%E7%A7%92%E7%AD%94%E9%A2%98%E6%A8%A1%E6%9D%BF%EF%BC%89"><span class="toc-number">2.2.</span> <span class="toc-text">二、核心速答（30 秒答题模板）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E3%80%81%E8%AF%A6%E7%BB%86%E5%8C%BA%E5%88%AB%E5%AF%B9%E6%AF%94%E8%A1%A8"><span class="toc-number">2.3.</span> <span class="toc-text">三、详细区别对比表</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9B%E3%80%81%E6%B3%A8%E5%85%A5%E6%9C%BA%E5%88%B6%E8%AF%A6%E8%A7%A3"><span class="toc-number">2.4.</span> <span class="toc-text">四、注入机制详解</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%9C%85-Autowired-%E6%B3%A8%E5%85%A5%E6%B5%81%E7%A8%8B%EF%BC%88%E6%8C%89%E7%B1%BB%E5%9E%8B%EF%BC%89"><span class="toc-number">2.4.1.</span> <span class="toc-text">✅ @Autowired 注入流程（按类型）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%9C%85-Resource-%E6%B3%A8%E5%85%A5%E6%B5%81%E7%A8%8B%EF%BC%88%E6%8C%89%E5%90%8D%E7%A7%B0%EF%BC%89"><span class="toc-number">2.4.2.</span> <span class="toc-text">✅ @Resource 注入流程（按名称）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%94%E3%80%81%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86%EF%BC%88%E6%BA%90%E7%A0%81%E5%B1%82%E7%BA%A7%EF%BC%89"><span class="toc-number">2.5.</span> <span class="toc-text">五、底层原理（源码层级）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%94%8D-Autowired"><span class="toc-number">2.5.1.</span> <span class="toc-text">🔍 @Autowired</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%94%8D-Resource"><span class="toc-number">2.5.2.</span> <span class="toc-text">🔍 @Resource</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%AD%E3%80%81%E5%AE%9E%E6%88%98%E5%9C%BA%E6%99%AF%EF%BC%88WMS-%E7%B3%BB%E7%BB%9F%E7%A4%BA%E4%BE%8B%EF%BC%89"><span class="toc-number">2.6.</span> <span class="toc-text">六、实战场景（WMS 系统示例）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%83%E3%80%81%E5%B8%B8%E8%A7%81%E9%94%99%E8%AF%AF%E4%B8%8E%E9%99%B7%E9%98%B1"><span class="toc-number">2.7.</span> <span class="toc-text">七、常见错误与陷阱</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%AB%E3%80%81%E5%B8%B8%E8%A7%81%E8%BF%BD%E9%97%AE%E4%B8%8E%E7%AD%94%E6%A1%88"><span class="toc-number">2.8.</span> <span class="toc-text">八、常见追问与答案</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B9%9D%E3%80%81%E6%80%A7%E8%83%BD%E4%B8%8E%E5%B7%A5%E7%A8%8B%E5%AE%9E%E8%B7%B5%E5%BB%BA%E8%AE%AE"><span class="toc-number">2.9.</span> <span class="toc-text">九、性能与工程实践建议</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%F0%9F%94%9F-%E4%B8%80%E5%88%86%E9%92%9F%E9%AB%98%E5%88%86%E6%80%BB%E7%BB%93%EF%BC%88%E5%8F%AF%E8%83%8C%E8%AF%B5%EF%BC%89"><span class="toc-number">2.10.</span> <span class="toc-text">🔟 一分钟高分总结（可背诵）</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%F0%9F%8E%AF-%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%9A%E8%B0%88%E8%B0%88%E4%BD%A0%E5%AF%B9-IOC-%E5%92%8C-AOP-%E7%9A%84%E7%90%86%E8%A7%A3"><span class="toc-number">3.</span> <span class="toc-text">🎯 面试题：谈谈你对 IOC 和 AOP 的理解</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E9%9D%A2%E8%AF%95%E5%AE%98%E8%80%83%E5%AF%9F%E7%82%B9-2"><span class="toc-number">3.1.</span> <span class="toc-text">一、面试官考察点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E3%80%81%E6%A0%B8%E5%BF%83%E9%80%9F%E7%AD%94%EF%BC%8830-%E7%A7%92%E6%A8%A1%E6%9D%BF%EF%BC%89"><span class="toc-number">3.2.</span> <span class="toc-text">二、核心速答（30 秒模板）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E3%80%81IOC%EF%BC%88%E6%8E%A7%E5%88%B6%E5%8F%8D%E8%BD%AC%EF%BC%89%E8%AF%A6%E8%A7%A3"><span class="toc-number">3.3.</span> <span class="toc-text">三、IOC（控制反转）详解</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%EF%B8%8F%E2%83%A3-%E5%AE%9A%E4%B9%89"><span class="toc-number">3.3.1.</span> <span class="toc-text">1️⃣ 定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%EF%B8%8F%E2%83%A3-%E6%A0%B8%E5%BF%83%E6%80%9D%E6%83%B3"><span class="toc-number">3.3.2.</span> <span class="toc-text">2️⃣ 核心思想</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%EF%B8%8F%E2%83%A3-%E4%BC%A0%E7%BB%9F%E6%96%B9%E5%BC%8F-vs-IOC-%E6%96%B9%E5%BC%8F"><span class="toc-number">3.3.3.</span> <span class="toc-text">3️⃣ 传统方式 vs IOC 方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4%EF%B8%8F%E2%83%A3-IOC-%E5%AE%B9%E5%99%A8%E6%A0%B8%E5%BF%83%E7%BB%84%E4%BB%B6"><span class="toc-number">3.3.4.</span> <span class="toc-text">4️⃣ IOC 容器核心组件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5%EF%B8%8F%E2%83%A3-%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%EF%BC%88IOC-%E8%BF%90%E8%A1%8C%E6%B5%81%E7%A8%8B%EF%BC%89"><span class="toc-number">3.3.5.</span> <span class="toc-text">5️⃣ 实现原理（IOC 运行流程）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6%EF%B8%8F%E2%83%A3-%E6%B6%89%E5%8F%8A%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F"><span class="toc-number">3.3.6.</span> <span class="toc-text">6️⃣ 涉及的设计模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7%EF%B8%8F%E2%83%A3-%E5%9C%A8%E9%A1%B9%E7%9B%AE%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8%EF%BC%88WMS-%E7%A4%BA%E4%BE%8B%EF%BC%89"><span class="toc-number">3.3.7.</span> <span class="toc-text">7️⃣ 在项目中的应用（WMS 示例）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9B%E3%80%81AOP%EF%BC%88%E9%9D%A2%E5%90%91%E5%88%87%E9%9D%A2%E7%BC%96%E7%A8%8B%EF%BC%89%E8%AF%A6%E8%A7%A3"><span class="toc-number">3.4.</span> <span class="toc-text">四、AOP（面向切面编程）详解</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%EF%B8%8F%E2%83%A3-%E5%AE%9A%E4%B9%89-1"><span class="toc-number">3.4.1.</span> <span class="toc-text">1️⃣ 定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%EF%B8%8F%E2%83%A3-%E6%A0%B8%E5%BF%83%E6%80%9D%E6%83%B3-1"><span class="toc-number">3.4.2.</span> <span class="toc-text">2️⃣ 核心思想</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%EF%B8%8F%E2%83%A3-%E5%85%B8%E5%9E%8B%E5%9C%BA%E6%99%AF"><span class="toc-number">3.4.3.</span> <span class="toc-text">3️⃣ 典型场景</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4%EF%B8%8F%E2%83%A3-%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5"><span class="toc-number">3.4.4.</span> <span class="toc-text">4️⃣ 核心概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5%EF%B8%8F%E2%83%A3-%E7%A4%BA%E4%BE%8B%EF%BC%9AAOP-%E6%97%A5%E5%BF%97%E5%A2%9E%E5%BC%BA"><span class="toc-number">3.4.5.</span> <span class="toc-text">5️⃣ 示例：AOP 日志增强</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6%EF%B8%8F%E2%83%A3-%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="toc-number">3.4.6.</span> <span class="toc-text">6️⃣ 底层实现原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7%EF%B8%8F%E2%83%A3-%E5%BA%95%E5%B1%82%E6%B5%81%E7%A8%8B%E5%9B%BE%EF%BC%88%E7%AE%80%E8%BF%B0%EF%BC%89"><span class="toc-number">3.4.7.</span> <span class="toc-text">7️⃣ 底层流程图（简述）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%94%E3%80%81IOC-%E4%B8%8E-AOP-%E7%9A%84%E5%85%B3%E7%B3%BB%E4%B8%8E%E5%8C%BA%E5%88%AB"><span class="toc-number">3.5.</span> <span class="toc-text">五、IOC 与 AOP 的关系与区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%AD%E3%80%81%E5%B8%B8%E8%A7%81%E8%BF%BD%E9%97%AE%E4%B8%8E%E7%AD%94%E6%A1%88"><span class="toc-number">3.6.</span> <span class="toc-text">六、常见追问与答案</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%83%E3%80%81%E6%80%A7%E8%83%BD%E4%B8%8E%E5%AE%9E%E8%B7%B5%E5%BB%BA%E8%AE%AE"><span class="toc-number">3.7.</span> <span class="toc-text">七、性能与实践建议</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%AB%E3%80%81%E9%AB%98%E5%88%86%E6%80%BB%E7%BB%93%E6%A8%A1%E6%9D%BF%EF%BC%88%E5%8F%AF%E8%83%8C%E8%AF%B5%EF%BC%89"><span class="toc-number">3.8.</span> <span class="toc-text">八、高分总结模板（可背诵）</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%F0%9F%8E%AF-%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%9ASpring-%E4%B8%AD%E5%8D%95%E4%BE%8B-Bean-%E7%9A%84%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98"><span class="toc-number">4.</span> <span class="toc-text">🎯 面试题：Spring 中单例 Bean 的线程安全问题</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E6%A0%B8%E5%BF%83%E7%BB%93%E8%AE%BA%E9%80%9F%E7%AD%94%EF%BC%88%E9%9D%A2%E8%AF%95%E5%BC%80%E5%9C%BA%E5%9B%9E%E7%AD%94%E6%A8%A1%E6%9D%BF%EF%BC%89"><span class="toc-number">4.1.</span> <span class="toc-text">一、核心结论速答（面试开场回答模板）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E3%80%81Spring-Bean-%E7%9A%84%E5%8D%95%E4%BE%8B%E6%9C%AC%E8%B4%A8"><span class="toc-number">4.2.</span> <span class="toc-text">二、Spring Bean 的单例本质</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%EF%B8%8F%E2%83%A3-%E9%BB%98%E8%AE%A4%E4%BD%9C%E7%94%A8%E5%9F%9F%E6%98%AF-Singleton"><span class="toc-number">4.2.1.</span> <span class="toc-text">1️⃣ 默认作用域是 Singleton</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%EF%B8%8F%E2%83%A3-%E5%8D%95%E4%BE%8B%E4%BD%9C%E7%94%A8%E5%9F%9F%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="toc-number">4.2.2.</span> <span class="toc-text">2️⃣ 单例作用域的生命周期</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E3%80%81%E5%8D%95%E4%BE%8B-Bean-%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98%E7%9A%84%E6%A0%B9%E6%9C%AC%E5%8E%9F%E5%9B%A0"><span class="toc-number">4.3.</span> <span class="toc-text">三、单例 Bean 线程安全问题的根本原因</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%9D%8C-%E9%94%99%E8%AF%AF%E7%A4%BA%E4%BE%8B%EF%BC%88%E6%9C%89%E7%8A%B6%E6%80%81-Bean%EF%BC%89"><span class="toc-number">4.3.1.</span> <span class="toc-text">❌ 错误示例（有状态 Bean）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%9C%85-%E6%AD%A3%E7%A1%AE%E5%81%9A%E6%B3%95%EF%BC%88%E6%97%A0%E7%8A%B6%E6%80%81-Bean%EF%BC%89"><span class="toc-number">4.3.2.</span> <span class="toc-text">✅ 正确做法（无状态 Bean）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9B%E3%80%81%E5%8D%95%E4%BE%8B-Bean-%E7%9A%84%E5%88%86%E7%B1%BB%E4%B8%8E%E5%AE%89%E5%85%A8%E6%80%A7%E5%88%86%E6%9E%90"><span class="toc-number">4.4.</span> <span class="toc-text">四、单例 Bean 的分类与安全性分析</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%94%E3%80%81Spring-%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E8%87%AA%E5%8A%A8%E4%BF%9D%E8%AF%81%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%EF%BC%9F"><span class="toc-number">4.5.</span> <span class="toc-text">五、Spring 为什么不自动保证线程安全？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%AD%E3%80%81%E5%B8%B8%E8%A7%81%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%E4%B8%8E%E5%AE%9E%E8%B7%B5%E5%BB%BA%E8%AE%AE"><span class="toc-number">4.6.</span> <span class="toc-text">六、常见解决方案与实践建议</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%9C%85-%E6%96%B9%E6%A1%88-1%EF%BC%9A%E6%97%A0%E7%8A%B6%E6%80%81%E8%AE%BE%E8%AE%A1%EF%BC%88%E6%8E%A8%E8%8D%90%EF%BC%89"><span class="toc-number">4.6.1.</span> <span class="toc-text">✅ 方案 1：无状态设计（推荐）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%9C%85-%E6%96%B9%E6%A1%88-2%EF%BC%9A%E4%BD%BF%E7%94%A8%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F"><span class="toc-number">4.6.2.</span> <span class="toc-text">✅ 方案 2：使用局部变量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%9C%85-%E6%96%B9%E6%A1%88-3%EF%BC%9A%E4%BD%BF%E7%94%A8-ThreadLocal"><span class="toc-number">4.6.3.</span> <span class="toc-text">✅ 方案 3：使用 ThreadLocal</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%9C%85-%E6%96%B9%E6%A1%88-4%EF%BC%9A%E6%9B%B4%E6%94%B9-Bean-%E4%BD%9C%E7%94%A8%E5%9F%9F"><span class="toc-number">4.6.4.</span> <span class="toc-text">✅ 方案 4：更改 Bean 作用域</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%83%E3%80%81Spring-%E5%86%85%E9%83%A8%E7%9A%84%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E6%9C%BA%E5%88%B6%E4%B8%BE%E4%BE%8B"><span class="toc-number">4.7.</span> <span class="toc-text">七、Spring 内部的线程安全机制举例</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%AB%E3%80%81%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E8%BF%BD%E9%97%AE%E4%B8%8E%E7%AD%94%E6%A1%88"><span class="toc-number">4.8.</span> <span class="toc-text">八、常见面试追问与答案</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B9%9D%E3%80%81%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%EF%BC%88%E6%BA%90%E7%A0%81%E7%BA%A7%EF%BC%89"><span class="toc-number">4.9.</span> <span class="toc-text">九、底层实现原理（源码级）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%F0%9F%94%9F-%E9%AB%98%E5%88%86%E6%80%BB%E7%BB%93%E6%A8%A1%E6%9D%BF%EF%BC%88%E5%8F%AF%E8%83%8C%E8%AF%B5%EF%BC%89"><span class="toc-number">4.10.</span> <span class="toc-text">🔟 高分总结模板（可背诵）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%F0%9F%94%8D-%E6%89%A9%E5%B1%95%E8%AF%9D%E9%A2%98%EF%BC%88%E9%9D%A2%E8%AF%95%E5%AE%98%E5%8F%AF%E8%83%BD%E6%B7%B1%E5%85%A5%E8%BF%BD%E9%97%AE%EF%BC%89"><span class="toc-number">4.11.</span> <span class="toc-text">🔍 扩展话题（面试官可能深入追问）</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%F0%9F%8E%AF-%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%9ASpring-%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96%E9%97%AE%E9%A2%98%EF%BC%9F"><span class="toc-number">5.</span> <span class="toc-text">🎯 面试题：Spring 如何解决循环依赖问题？</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E9%9D%A2%E8%AF%95%E5%AE%98%E8%80%83%E5%AF%9F%E7%82%B9-3"><span class="toc-number">5.1.</span> <span class="toc-text">一、面试官考察点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E3%80%81%E6%A0%B8%E5%BF%83%E9%80%9F%E7%AD%94%E6%A8%A1%E6%9D%BF%EF%BC%88%E9%9D%A2%E8%AF%95%E5%BC%80%E5%9C%BA%E7%89%88%EF%BC%89"><span class="toc-number">5.2.</span> <span class="toc-text">二、核心速答模板（面试开场版）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AF%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96%EF%BC%9F"><span class="toc-number">5.3.</span> <span class="toc-text">三、什么是循环依赖？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B%EF%BC%9A"><span class="toc-number">5.3.1.</span> <span class="toc-text">示例：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9B%E3%80%81Spring-%E8%A7%A3%E5%86%B3%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96%E7%9A%84%E5%89%8D%E6%8F%90%E4%B8%8E%E9%99%90%E5%88%B6"><span class="toc-number">5.4.</span> <span class="toc-text">四、Spring 解决循环依赖的前提与限制</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%94%E3%80%81Spring-%E4%B8%89%E7%BA%A7%E7%BC%93%E5%AD%98%E6%A0%B8%E5%BF%83%E6%9C%BA%E5%88%B6"><span class="toc-number">5.5.</span> <span class="toc-text">五、Spring 三级缓存核心机制</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%AD%E3%80%81%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96%E8%A7%A3%E5%86%B3%E6%B5%81%E7%A8%8B%EF%BC%88%E9%87%8D%E7%82%B9%E6%A0%B8%E5%BF%83%EF%BC%89"><span class="toc-number">5.6.</span> <span class="toc-text">六、循环依赖解决流程（重点核心）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%83%E3%80%81%E6%BA%90%E7%A0%81%E6%A0%B8%E5%BF%83%E8%A7%A3%E6%9E%90%EF%BC%88%E7%AE%80%E5%8C%96%E7%89%88%EF%BC%89"><span class="toc-number">5.7.</span> <span class="toc-text">七、源码核心解析（简化版）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%AB%E3%80%81AOP-%E4%BB%A3%E7%90%86%E4%B8%8E%E4%B8%89%E7%BA%A7%E7%BC%93%E5%AD%98%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="toc-number">5.8.</span> <span class="toc-text">八、AOP 代理与三级缓存的关系</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B9%9D%E3%80%81%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E8%BF%BD%E9%97%AE%E4%B8%8E%E7%AD%94%E6%A1%88"><span class="toc-number">5.9.</span> <span class="toc-text">九、常见面试追问与答案</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%F0%9F%94%9F-%E5%AE%9E%E9%99%85%E9%A1%B9%E7%9B%AE%E6%A1%88%E4%BE%8B%EF%BC%88WMS-%E5%9C%BA%E6%99%AF%EF%BC%89"><span class="toc-number">5.10.</span> <span class="toc-text">🔟 实际项目案例（WMS 场景）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%F0%9F%A7%A9-%E5%8D%81%E4%B8%80%E3%80%81%E6%80%A7%E8%83%BD%E4%B8%8E%E5%AE%89%E5%85%A8%E6%80%A7%E5%88%86%E6%9E%90"><span class="toc-number">5.11.</span> <span class="toc-text">🧩 十一、性能与安全性分析</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%F0%9F%A7%A0-%E5%8D%81%E4%BA%8C%E3%80%81%E9%AB%98%E5%88%86%E6%80%BB%E7%BB%93%E6%A8%A1%E6%9D%BF%EF%BC%88%E5%8F%AF%E8%83%8C%E8%AF%B5%EF%BC%89"><span class="toc-number">5.12.</span> <span class="toc-text">🧠 十二、高分总结模板（可背诵）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%F0%9F%94%8D-%E5%8D%81%E4%B8%89%E3%80%81%E6%89%A9%E5%B1%95%E8%AF%9D%E9%A2%98%EF%BC%88%E9%9D%A2%E8%AF%95%E5%AE%98%E5%8F%AF%E8%83%BD%E7%BB%A7%E7%BB%AD%E8%BF%BD%E9%97%AE%EF%BC%89"><span class="toc-number">5.13.</span> <span class="toc-text">🔍 十三、扩展话题（面试官可能继续追问）</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%F0%9F%8E%AF-%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%9ASpring-Bean-%E7%9A%84%E5%AE%9E%E4%BE%8B%E5%8C%96%E5%92%8C%E5%88%9D%E5%A7%8B%E5%8C%96%E8%BF%87%E7%A8%8B"><span class="toc-number">6.</span> <span class="toc-text">🎯 面试题：Spring Bean 的实例化和初始化过程</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E9%9D%A2%E8%AF%95%E5%AE%98%E8%80%83%E5%AF%9F%E7%82%B9-4"><span class="toc-number">6.1.</span> <span class="toc-text">一、面试官考察点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E3%80%81%E6%A0%B8%E5%BF%83%E9%80%9F%E7%AD%94%EF%BC%8830-%E7%A7%92%E7%AE%80%E7%89%88%EF%BC%89"><span class="toc-number">6.2.</span> <span class="toc-text">二、核心速答（30 秒简版）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E3%80%81Spring-Bean-%E5%88%9B%E5%BB%BA%E7%9A%84%E5%AE%8C%E6%95%B4%E6%B5%81%E7%A8%8B%EF%BC%88%E8%AF%A6%E7%BB%86%E7%89%88%EF%BC%89"><span class="toc-number">6.3.</span> <span class="toc-text">三、Spring Bean 创建的完整流程（详细版）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%98%B6%E6%AE%B5-1%EF%BC%9A%E5%8A%A0%E8%BD%BD-Bean-%E5%AE%9A%E4%B9%89%EF%BC%88BeanDefinition%EF%BC%89"><span class="toc-number">6.3.1.</span> <span class="toc-text">阶段 1：加载 Bean 定义（BeanDefinition）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%98%B6%E6%AE%B5-2%EF%BC%9A%E5%AE%9E%E4%BE%8B%E5%8C%96-Bean%EF%BC%88Instantiation%EF%BC%89"><span class="toc-number">6.3.2.</span> <span class="toc-text">阶段 2：实例化 Bean（Instantiation）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%98%B6%E6%AE%B5-3%EF%BC%9A%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5%EF%BC%88Populate-Bean%EF%BC%89"><span class="toc-number">6.3.3.</span> <span class="toc-text">阶段 3：依赖注入（Populate Bean）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%98%B6%E6%AE%B5-4%EF%BC%9A%E5%88%9D%E5%A7%8B%E5%8C%96%E5%89%8D%E7%BD%AE%E5%A4%84%E7%90%86%EF%BC%88BeanPostProcessor-before%EF%BC%89"><span class="toc-number">6.3.4.</span> <span class="toc-text">阶段 4：初始化前置处理（BeanPostProcessor - before）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%98%B6%E6%AE%B5-5%EF%BC%9A%E5%88%9D%E5%A7%8B%E5%8C%96%EF%BC%88Initialization%EF%BC%89"><span class="toc-number">6.3.5.</span> <span class="toc-text">阶段 5：初始化（Initialization）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%98%B6%E6%AE%B5-6%EF%BC%9A%E5%88%9D%E5%A7%8B%E5%8C%96%E5%90%8E%E7%BD%AE%E5%A4%84%E7%90%86%EF%BC%88BeanPostProcessor-after%EF%BC%89"><span class="toc-number">6.3.6.</span> <span class="toc-text">阶段 6：初始化后置处理（BeanPostProcessor - after）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%98%B6%E6%AE%B5-7%EF%BC%9A%E6%B3%A8%E5%86%8C%E5%88%B0%E5%8D%95%E4%BE%8B%E6%B1%A0%EF%BC%88singletonObjects%EF%BC%89"><span class="toc-number">6.3.7.</span> <span class="toc-text">阶段 7：注册到单例池（singletonObjects）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%98%B6%E6%AE%B5-8%EF%BC%9A%E9%94%80%E6%AF%81%E9%98%B6%E6%AE%B5%EF%BC%88Destruction%EF%BC%89"><span class="toc-number">6.3.8.</span> <span class="toc-text">阶段 8：销毁阶段（Destruction）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9B%E3%80%81Bean-%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E6%80%BB%E8%A7%88%E5%9B%BE%EF%BC%88%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E7%94%BB%E5%9B%BE%E9%A2%98%EF%BC%89"><span class="toc-number">6.4.</span> <span class="toc-text">四、Bean 生命周期总览图（高频面试画图题）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%94%E3%80%81%E6%BA%90%E7%A0%81%E5%85%B3%E9%94%AE%E8%B7%AF%E5%BE%84%EF%BC%88%E7%AE%80%E5%8C%96%E6%80%BB%E7%BB%93%EF%BC%89"><span class="toc-number">6.5.</span> <span class="toc-text">五、源码关键路径（简化总结）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%AD%E3%80%81%E5%B8%B8%E8%A7%81%E8%BF%BD%E9%97%AE%E4%B8%8E%E6%A0%87%E5%87%86%E7%AD%94%E6%A1%88"><span class="toc-number">6.6.</span> <span class="toc-text">六、常见追问与标准答案</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%83%E3%80%81%E9%AB%98%E5%88%86%E6%80%BB%E7%BB%93%E6%A8%A1%E6%9D%BF%EF%BC%88%E9%9D%A2%E8%AF%95%E5%8F%AF%E7%9B%B4%E6%8E%A5%E5%A4%8D%E8%BF%B0%EF%BC%89"><span class="toc-number">6.7.</span> <span class="toc-text">七、高分总结模板（面试可直接复述）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%AB%E3%80%81%E6%89%A9%E5%B1%95%E9%97%AE%E9%A2%98%EF%BC%88%E9%9D%A2%E8%AF%95%E5%8A%A0%E5%88%86%EF%BC%89"><span class="toc-number">6.8.</span> <span class="toc-text">八、扩展问题（面试加分）</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%F0%9F%8E%AF-%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%9ASpring-%E4%B8%AD%E5%B8%B8%E7%94%A8%E6%B3%A8%E8%A7%A3%E5%8F%8A%E5%85%B6%E5%8E%9F%E7%90%86"><span class="toc-number">7.</span> <span class="toc-text">🎯 面试题：Spring 中常用注解及其原理</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E8%80%83%E5%AF%9F%E7%82%B9%E6%A6%82%E8%A7%88"><span class="toc-number">7.1.</span> <span class="toc-text">一、考察点概览</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E3%80%81Spring-%E6%B3%A8%E8%A7%A3%E4%BD%93%E7%B3%BB%E6%80%BB%E4%BD%93%E5%88%86%E7%B1%BB"><span class="toc-number">7.2.</span> <span class="toc-text">二、Spring 注解体系总体分类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E3%80%81%E6%A0%B8%E5%BF%83%E6%B3%A8%E8%A7%A3%E8%AF%A6%E8%A7%A3%EF%BC%88IOC-%E7%BB%84%E4%BB%B6%E5%A3%B0%E6%98%8E%EF%BC%89"><span class="toc-number">7.3.</span> <span class="toc-text">三、核心注解详解（IOC 组件声明）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%EF%B8%8F%E2%83%A3-Component"><span class="toc-number">7.3.1.</span> <span class="toc-text">1️⃣ @Component</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%EF%B8%8F%E2%83%A3-Service%E3%80%81-Repository%E3%80%81-Controller"><span class="toc-number">7.3.2.</span> <span class="toc-text">2️⃣ @Service、@Repository、@Controller</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9B%E3%80%81%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5%E6%B3%A8%E8%A7%A3"><span class="toc-number">7.4.</span> <span class="toc-text">四、依赖注入注解</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B%EF%BC%9A-1"><span class="toc-number">7.4.1.</span> <span class="toc-text">示例：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%94%E3%80%81%E9%85%8D%E7%BD%AE%E7%B1%BB%E7%9B%B8%E5%85%B3%E6%B3%A8%E8%A7%A3%EF%BC%88%E5%8F%96%E4%BB%A3-XML-%E9%85%8D%E7%BD%AE%EF%BC%89"><span class="toc-number">7.5.</span> <span class="toc-text">五、配置类相关注解（取代 XML 配置）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B%EF%BC%9A-2"><span class="toc-number">7.5.1.</span> <span class="toc-text">示例：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%AD%E3%80%81AOP-%E4%B8%8E%E4%BA%8B%E5%8A%A1%E6%B3%A8%E8%A7%A3"><span class="toc-number">7.6.</span> <span class="toc-text">六、AOP 与事务注解</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B%EF%BC%9A-3"><span class="toc-number">7.6.1.</span> <span class="toc-text">示例：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%83%E3%80%81Web-%E5%B1%82%E5%B8%B8%E7%94%A8%E6%B3%A8%E8%A7%A3%EF%BC%88Spring-MVC%EF%BC%89"><span class="toc-number">7.7.</span> <span class="toc-text">七、Web 层常用注解（Spring MVC）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B%EF%BC%9A-4"><span class="toc-number">7.7.1.</span> <span class="toc-text">示例：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%AB%E3%80%81%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E4%B8%8E%E5%9B%9E%E8%B0%83%E6%B3%A8%E8%A7%A3"><span class="toc-number">7.8.</span> <span class="toc-text">八、生命周期与回调注解</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B%EF%BC%9A-5"><span class="toc-number">7.8.1.</span> <span class="toc-text">示例：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B9%9D%E3%80%81Spring-Boot-%E6%B3%A8%E8%A7%A3%E4%BD%93%E7%B3%BB%EF%BC%88%E6%89%A9%E5%B1%95%EF%BC%89"><span class="toc-number">7.9.</span> <span class="toc-text">九、Spring Boot 注解体系（扩展）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%81%E3%80%81%E5%B8%B8%E8%A7%81%E8%BF%BD%E9%97%AE%E4%B8%8E%E6%A0%87%E5%87%86%E7%AD%94%E6%A1%88"><span class="toc-number">7.10.</span> <span class="toc-text">十、常见追问与标准答案</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%81%E4%B8%80%E3%80%81%E9%AB%98%E5%88%86%E6%80%BB%E7%BB%93%E6%A8%A1%E6%9D%BF%EF%BC%88%E5%8F%AF%E8%83%8C%E8%AF%B5%EF%BC%89"><span class="toc-number">7.11.</span> <span class="toc-text">十一、高分总结模板（可背诵）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%81%E4%BA%8C%E3%80%81%E6%89%A9%E5%B1%95%EF%BC%9A%E9%9D%A2%E8%AF%95%E5%AE%98%E5%8F%AF%E8%83%BD%E8%BF%9B%E4%B8%80%E6%AD%A5%E8%BF%BD%E9%97%AE"><span class="toc-number">7.12.</span> <span class="toc-text">十二、扩展：面试官可能进一步追问</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%F0%9F%8E%AF-%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%9ASpring-%E5%A3%B0%E6%98%8E%E5%BC%8F%E4%BA%8B%E5%8A%A1%E5%9C%A8%E4%BB%80%E4%B9%88%E6%83%85%E5%86%B5%E4%B8%8B%E4%BC%9A%E5%A4%B1%E6%95%88%EF%BC%9F"><span class="toc-number">8.</span> <span class="toc-text">🎯 面试题：Spring 声明式事务在什么情况下会失效？</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E5%89%8D%E7%BD%AE%E7%9F%A5%E8%AF%86%EF%BC%9ASpring-%E5%A3%B0%E6%98%8E%E5%BC%8F%E4%BA%8B%E5%8A%A1%E7%9A%84%E5%8E%9F%E7%90%86"><span class="toc-number">8.1.</span> <span class="toc-text">一、前置知识：Spring 声明式事务的原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E3%80%81%E5%B8%B8%E8%A7%81%E7%9A%84-8-%E7%A7%8D%E4%BA%8B%E5%8A%A1%E5%A4%B1%E6%95%88%E5%9C%BA%E6%99%AF%EF%BC%88%E5%90%AB%E5%8E%9F%E7%90%86%E4%B8%8E%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%EF%BC%89"><span class="toc-number">8.2.</span> <span class="toc-text">二、常见的 8 种事务失效场景（含原理与解决方案）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%91%A0-%E5%90%8C%E7%B1%BB%E6%96%B9%E6%B3%95%E5%86%85%E9%83%A8%E8%B0%83%E7%94%A8%EF%BC%88Self-Invocation%EF%BC%89%E5%AF%BC%E8%87%B4%E4%BA%8B%E5%8A%A1%E5%A4%B1%E6%95%88"><span class="toc-number">8.2.1.</span> <span class="toc-text">① 同类方法内部调用（Self Invocation）导致事务失效</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%91%A1-%E6%96%B9%E6%B3%95%E4%B8%8D%E6%98%AF-public-%E5%AF%BC%E8%87%B4%E4%BA%8B%E5%8A%A1%E5%A4%B1%E6%95%88"><span class="toc-number">8.2.2.</span> <span class="toc-text">② 方法不是 public 导致事务失效</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%91%A2-%E5%BC%82%E5%B8%B8%E7%B1%BB%E5%9E%8B%E9%94%99%E8%AF%AF%EF%BC%88%E9%9D%9E%E8%BF%90%E8%A1%8C%E6%97%B6%E5%BC%82%E5%B8%B8%E4%B8%8D%E5%9B%9E%E6%BB%9A%EF%BC%89"><span class="toc-number">8.2.3.</span> <span class="toc-text">③ 异常类型错误（非运行时异常不回滚）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%91%A3-%E5%BC%82%E5%B8%B8%E8%A2%AB%E6%8D%95%E8%8E%B7%E5%AF%BC%E8%87%B4%E4%BA%8B%E5%8A%A1%E5%A4%B1%E6%95%88"><span class="toc-number">8.2.4.</span> <span class="toc-text">④ 异常被捕获导致事务失效</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%91%A4-%E4%BA%8B%E5%8A%A1%E6%96%B9%E6%B3%95%E6%9C%AA%E8%A2%AB-Spring-%E7%AE%A1%E7%90%86"><span class="toc-number">8.2.5.</span> <span class="toc-text">⑤ 事务方法未被 Spring 管理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%91%A5-%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%8D%E6%94%AF%E6%8C%81%E4%BA%8B%E5%8A%A1%EF%BC%88%E6%88%96%E4%BD%BF%E7%94%A8%E4%BA%86%E9%94%99%E8%AF%AF%E7%9A%84%E5%BC%95%E6%93%8E%EF%BC%89"><span class="toc-number">8.2.6.</span> <span class="toc-text">⑥ 数据库不支持事务（或使用了错误的引擎）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%91%A6-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%AF%BC%E8%87%B4%E4%BA%8B%E5%8A%A1%E5%A4%B1%E6%95%88"><span class="toc-number">8.2.7.</span> <span class="toc-text">⑦ 多线程导致事务失效</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%91%A7-%E4%BA%8B%E5%8A%A1%E4%BC%A0%E6%92%AD%E8%A1%8C%E4%B8%BA%E9%85%8D%E7%BD%AE%E4%B8%8D%E5%BD%93"><span class="toc-number">8.2.8.</span> <span class="toc-text">⑧ 事务传播行为配置不当</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E3%80%81%E4%BA%8B%E5%8A%A1%E5%A4%B1%E6%95%88%E9%97%AE%E9%A2%98%E5%AE%9A%E4%BD%8D%E6%8A%80%E5%B7%A7"><span class="toc-number">8.3.</span> <span class="toc-text">三、事务失效问题定位技巧</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9B%E3%80%81%E9%AB%98%E5%88%86%E6%80%BB%E7%BB%93%E6%A8%A1%E6%9D%BF%EF%BC%88%E9%9D%A2%E8%AF%95%E5%8F%AF%E7%9B%B4%E6%8E%A5%E8%83%8C%E8%AF%B5%EF%BC%89"><span class="toc-number">8.4.</span> <span class="toc-text">四、高分总结模板（面试可直接背诵）</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%F0%9F%8E%AF-%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%9A%E4%BB%80%E4%B9%88%E6%98%AF%E5%B5%8C%E5%A5%97%E4%BA%8B%E5%8A%A1%EF%BC%9FSpring-%E4%B8%AD%E6%98%AF%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E7%9A%84%EF%BC%9F"><span class="toc-number">9.</span> <span class="toc-text">🎯 面试题：什么是嵌套事务？Spring 中是如何实现的？</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E9%9D%A2%E8%AF%95%E5%AE%98%E8%80%83%E5%AF%9F%E7%82%B9-5"><span class="toc-number">9.1.</span> <span class="toc-text">一、面试官考察点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E3%80%8130-%E7%A7%92%E9%80%9F%E7%AD%94%E7%89%88%EF%BC%88%E9%9D%A2%E8%AF%95%E7%AE%80%E7%AD%94%EF%BC%89"><span class="toc-number">9.2.</span> <span class="toc-text">二、30 秒速答版（面试简答）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E3%80%81%E8%AF%A6%E7%BB%86%E8%A7%A3%E6%9E%90%EF%BC%88%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86%EF%BC%89"><span class="toc-number">9.3.</span> <span class="toc-text">三、详细解析（核心原理）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%EF%B8%8F%E2%83%A3-%E5%B5%8C%E5%A5%97%E4%BA%8B%E5%8A%A1%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="toc-number">9.3.1.</span> <span class="toc-text">1️⃣ 嵌套事务的定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%9A%99%EF%B8%8F-2%EF%B8%8F%E2%83%A3-Spring-%E7%9A%84%E5%B5%8C%E5%A5%97%E4%BA%8B%E5%8A%A1%E4%BC%A0%E6%92%AD%E8%A1%8C%E4%B8%BA%EF%BC%9APropagation-NESTED"><span class="toc-number">9.3.2.</span> <span class="toc-text">⚙️ 2️⃣ Spring 的嵌套事务传播行为：Propagation.NESTED</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%94%8D-3%EF%B8%8F%E2%83%A3-NESTED-%E4%B8%8E-REQUIRES-NEW-%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%88%E9%9D%A2%E8%AF%95%E9%AB%98%E9%A2%91%E8%BF%BD%E9%97%AE%EF%BC%89"><span class="toc-number">9.3.3.</span> <span class="toc-text">🔍 3️⃣ NESTED 与 REQUIRES_NEW 的区别（面试高频追问）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%94%A7-4%EF%B8%8F%E2%83%A3-%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90%EF%BC%88%E6%BA%90%E7%A0%81%E5%B1%82%EF%BC%89"><span class="toc-number">9.3.4.</span> <span class="toc-text">🔧 4️⃣ 底层原理分析（源码层）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%9A%A0%EF%B8%8F-5%EF%B8%8F%E2%83%A3-%E5%B5%8C%E5%A5%97%E4%BA%8B%E5%8A%A1%E7%9A%84%E5%A4%B1%E6%95%88%E5%9C%BA%E6%99%AF%EF%BC%88%E5%B8%B8%E8%A7%81%E9%99%B7%E9%98%B1%EF%BC%89"><span class="toc-number">9.3.5.</span> <span class="toc-text">⚠️ 5️⃣ 嵌套事务的失效场景（常见陷阱）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%93%9A-6%EF%B8%8F%E2%83%A3-%E5%B5%8C%E5%A5%97%E4%BA%8B%E5%8A%A1%E7%9A%84%E5%85%B8%E5%9E%8B%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">9.3.6.</span> <span class="toc-text">📚 6️⃣ 嵌套事务的典型应用场景</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%92%A1-%E7%A4%BA%E4%BE%8B%E4%BB%A3%E7%A0%81%EF%BC%88%E5%B8%A6%E5%9B%9E%E6%BB%9A%E6%BC%94%E7%A4%BA%EF%BC%89"><span class="toc-number">9.3.7.</span> <span class="toc-text">💡 示例代码（带回滚演示）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%9A%99%EF%B8%8F-7%EF%B8%8F%E2%83%A3-%E6%80%A7%E8%83%BD%E4%B8%8E%E4%BA%8B%E5%8A%A1%E6%B7%B1%E5%BA%A6%E5%88%86%E6%9E%90"><span class="toc-number">9.3.8.</span> <span class="toc-text">⚙️ 7️⃣ 性能与事务深度分析</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%AB%E3%80%81%E9%9D%A2%E8%AF%95%E5%8A%A0%E5%88%86%E6%80%BB%E7%BB%93%EF%BC%88%E5%8F%AF%E8%83%8C%E8%AF%B5%E7%89%88%EF%BC%89"><span class="toc-number">9.4.</span> <span class="toc-text">八、面试加分总结（可背诵版）</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%F0%9F%8E%AF-%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%9A%E5%A4%96%E9%83%A8%E4%BA%8B%E5%8A%A1%E5%9B%9E%E6%BB%9A%EF%BC%8C%E5%AD%90%E4%BA%8B%E5%8A%A1%E4%B9%9F%E5%BF%85%E7%84%B6%E4%BC%9A%E5%9B%9E%E6%BB%9A%E5%90%97%EF%BC%9F"><span class="toc-number">10.</span> <span class="toc-text">🎯 面试题：外部事务回滚，子事务也必然会回滚吗？</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E9%9D%A2%E8%AF%95%E9%80%9F%E7%AD%94%EF%BC%88%E6%A0%87%E5%87%86%E7%AD%94%E6%B3%95%EF%BC%89"><span class="toc-number">10.1.</span> <span class="toc-text">一、面试速答（标准答法）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E3%80%81%E6%B7%B1%E5%85%A5%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90"><span class="toc-number">10.2.</span> <span class="toc-text">二、深入原理解析</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%EF%B8%8F%E2%83%A3-NESTED-%E7%9A%84%E6%9C%AC%E8%B4%A8%EF%BC%9A%E5%90%8C%E4%B8%80%E4%BA%8B%E5%8A%A1%E3%80%81%E4%BF%9D%E5%AD%98%E7%82%B9%E6%9C%BA%E5%88%B6"><span class="toc-number">10.2.1.</span> <span class="toc-text">1️⃣ NESTED 的本质：同一事务、保存点机制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%EF%B8%8F%E2%83%A3-%E5%BA%95%E5%B1%82%E6%89%A7%E8%A1%8C%E9%80%BB%E8%BE%91%EF%BC%88%E4%BC%AA%E6%BA%90%E7%A0%81%EF%BC%89"><span class="toc-number">10.2.2.</span> <span class="toc-text">2️⃣ 底层执行逻辑（伪源码）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%EF%B8%8F%E2%83%A3-%E4%B8%8E-REQUIRES-NEW-%E7%9A%84%E5%AF%B9%E6%AF%94%EF%BC%88%E9%9D%9E%E5%B8%B8%E5%85%B3%E9%94%AE%EF%BC%89"><span class="toc-number">10.2.3.</span> <span class="toc-text">3️⃣ 与 REQUIRES_NEW 的对比（非常关键）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4%EF%B8%8F%E2%83%A3-%E4%B8%BE%E4%B8%AA%E5%AE%9E%E9%99%85%E4%BE%8B%E5%AD%90"><span class="toc-number">10.2.4.</span> <span class="toc-text">4️⃣ 举个实际例子</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%89%A7%E8%A1%8C%E7%BB%93%E6%9E%9C%EF%BC%9A"><span class="toc-number">10.2.4.1.</span> <span class="toc-text">执行结果：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5%EF%B8%8F%E2%83%A3-%E5%A6%82%E6%9E%9C%E6%94%B9%E6%88%90-REQUIRES-NEW"><span class="toc-number">10.2.5.</span> <span class="toc-text">5️⃣ 如果改成 REQUIRES_NEW</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%89%A7%E8%A1%8C%E7%BB%93%E6%9E%9C%EF%BC%9A-1"><span class="toc-number">10.2.5.1.</span> <span class="toc-text">执行结果：</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E3%80%81%E6%80%BB%E7%BB%93%E9%80%BB%E8%BE%91%EF%BC%88%E9%9D%A2%E8%AF%95%E5%8F%AF%E5%A4%8D%E8%BF%B0%E7%89%88%EF%BC%89"><span class="toc-number">10.3.</span> <span class="toc-text">三、总结逻辑（面试可复述版）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9B%E3%80%81%E5%B8%B8%E8%A7%81%E8%BF%BD%E9%97%AE%E4%B8%8E%E9%99%B7%E9%98%B1"><span class="toc-number">10.4.</span> <span class="toc-text">四、常见追问与陷阱</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%94%E3%80%81%E9%AB%98%E5%88%86%E6%80%BB%E7%BB%93%EF%BC%88%E8%83%8C%E8%AF%B5%E6%A8%A1%E6%9D%BF%EF%BC%89"><span class="toc-number">10.5.</span> <span class="toc-text">五、高分总结（背诵模板）</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%F0%9F%8E%AF-%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%9ASpring-%E4%BA%8B%E5%8A%A1%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%EF%BC%88-Transactional-%E5%BA%95%E5%B1%82%E6%9C%BA%E5%88%B6%EF%BC%89"><span class="toc-number">11.</span> <span class="toc-text">🎯 面试题：Spring 事务的实现原理（@Transactional 底层机制）</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E9%9D%A2%E8%AF%95%E5%AE%98%E8%80%83%E5%AF%9F%E7%82%B9-6"><span class="toc-number">11.1.</span> <span class="toc-text">一、面试官考察点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E3%80%8130-%E7%A7%92%E9%80%9F%E7%AD%94%EF%BC%88%E9%9D%A2%E8%AF%95%E9%80%9F%E7%AD%94%E7%89%88%EF%BC%89"><span class="toc-number">11.2.</span> <span class="toc-text">二、30 秒速答（面试速答版）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E3%80%81%E4%BA%8B%E5%8A%A1%E7%9A%84%E6%95%B4%E4%BD%93%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B"><span class="toc-number">11.3.</span> <span class="toc-text">三、事务的整体执行流程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9B%E3%80%81%E6%A0%B8%E5%BF%83%E7%BB%84%E4%BB%B6%E4%B8%8E%E8%81%8C%E8%B4%A3%E5%88%92%E5%88%86"><span class="toc-number">11.4.</span> <span class="toc-text">四、核心组件与职责划分</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%94%E3%80%81%E6%B7%B1%E5%85%A5%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0%EF%BC%88%E6%BA%90%E7%A0%81%E7%BA%A7%E5%88%86%E6%9E%90%EF%BC%89"><span class="toc-number">11.5.</span> <span class="toc-text">五、深入底层实现（源码级分析）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%EF%B8%8F%E2%83%A3-AOP-%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E6%9C%BA%E5%88%B6"><span class="toc-number">11.5.1.</span> <span class="toc-text">1️⃣ AOP 动态代理机制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%EF%B8%8F%E2%83%A3-%E4%BA%8B%E5%8A%A1%E6%8B%A6%E6%88%AA%E5%99%A8-TransactionInterceptor"><span class="toc-number">11.5.2.</span> <span class="toc-text">2️⃣ 事务拦截器 TransactionInterceptor</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%EF%B8%8F%E2%83%A3-%E4%BA%8B%E5%8A%A1%E7%AE%A1%E7%90%86%E5%99%A8-PlatformTransactionManager"><span class="toc-number">11.5.3.</span> <span class="toc-text">3️⃣ 事务管理器 PlatformTransactionManager</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4%EF%B8%8F%E2%83%A3-JDBC-%E5%B1%82%E4%BA%8B%E5%8A%A1%E6%8E%A7%E5%88%B6"><span class="toc-number">11.5.4.</span> <span class="toc-text">4️⃣ JDBC 层事务控制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5%EF%B8%8F%E2%83%A3-ThreadLocal-%E7%BA%BF%E7%A8%8B%E7%BB%91%E5%AE%9A%E6%9C%BA%E5%88%B6"><span class="toc-number">11.5.5.</span> <span class="toc-text">5️⃣ ThreadLocal 线程绑定机制</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%AD%E3%80%81%E4%BA%8B%E5%8A%A1%E4%BC%A0%E6%92%AD%E6%9C%BA%E5%88%B6%EF%BC%88Propagation%EF%BC%89"><span class="toc-number">11.6.</span> <span class="toc-text">六、事务传播机制（Propagation）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%83%E3%80%81%E4%BA%8B%E5%8A%A1%E5%9B%9E%E6%BB%9A%E6%9C%BA%E5%88%B6"><span class="toc-number">11.7.</span> <span class="toc-text">七、事务回滚机制</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%EF%B8%8F%E2%83%A3-%E5%9B%9E%E6%BB%9A%E6%9D%A1%E4%BB%B6"><span class="toc-number">11.7.1.</span> <span class="toc-text">1️⃣ 回滚条件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%EF%B8%8F%E2%83%A3-%E5%9B%9E%E6%BB%9A%E6%B5%81%E7%A8%8B%EF%BC%88%E6%BA%90%E7%A0%81%EF%BC%89"><span class="toc-number">11.7.2.</span> <span class="toc-text">2️⃣ 回滚流程（源码）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%AB%E3%80%81%E4%BA%8B%E5%8A%A1%E5%A4%B1%E6%95%88%E7%9A%84%E5%B8%B8%E8%A7%81%E5%8E%9F%E5%9B%A0%EF%BC%88%E9%9D%A2%E8%AF%95%E9%AB%98%E9%A2%91%E9%99%B7%E9%98%B1%EF%BC%89"><span class="toc-number">11.8.</span> <span class="toc-text">八、事务失效的常见原因（面试高频陷阱）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B9%9D%E3%80%81%E6%80%A7%E8%83%BD%E4%B8%8E%E8%AE%BE%E8%AE%A1%E5%88%86%E6%9E%90"><span class="toc-number">11.9.</span> <span class="toc-text">九、性能与设计分析</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%F0%9F%94%A5-%E5%8D%81%E3%80%81%E4%B8%80%E5%88%86%E9%92%9F%E9%AB%98%E5%88%86%E6%80%BB%E7%BB%93%EF%BC%88%E5%8F%AF%E8%83%8C%E8%AF%B5%EF%BC%89"><span class="toc-number">11.10.</span> <span class="toc-text">🔥 十、一分钟高分总结（可背诵）</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%F0%9F%8E%AF-%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%9ASpring-Task-%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1%E5%A4%B1%E8%B4%A5%E4%BA%86%E5%A6%82%E4%BD%95%E9%87%8D%E8%AF%95%EF%BC%9F"><span class="toc-number">12.</span> <span class="toc-text">🎯 面试题：Spring Task 定时任务失败了如何重试？</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E9%9D%A2%E8%AF%95%E5%AE%98%E6%84%8F%E5%9B%BE"><span class="toc-number">12.1.</span> <span class="toc-text">一、面试官意图</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E3%80%81%E5%9F%BA%E7%A1%80%E5%9B%9E%E7%AD%94%EF%BC%8830-%E7%A7%92%E9%9D%A2%E8%AF%95%E9%80%9F%E7%AD%94%E7%89%88%EF%BC%89"><span class="toc-number">12.2.</span> <span class="toc-text">二、基础回答（30 秒面试速答版）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E3%80%81Spring-Task-%E6%89%A7%E8%A1%8C%E5%8E%9F%E7%90%86"><span class="toc-number">12.3.</span> <span class="toc-text">三、Spring Task 执行原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9B%E3%80%81Spring-Task-%E4%BB%BB%E5%8A%A1%E5%A4%B1%E8%B4%A5%E7%9A%84%E5%B8%B8%E8%A7%81%E5%8E%9F%E5%9B%A0"><span class="toc-number">12.4.</span> <span class="toc-text">四、Spring Task 任务失败的常见原因</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%94%E3%80%81%E4%BB%BB%E5%8A%A1%E5%A4%B1%E8%B4%A5%E5%90%8E%E7%9A%84%E9%87%8D%E8%AF%95%E7%AD%96%E7%95%A5%E5%AE%9E%E7%8E%B0"><span class="toc-number">12.5.</span> <span class="toc-text">五、任务失败后的重试策略实现</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%9C%85-1%EF%B8%8F%E2%83%A3-%E6%89%8B%E5%8A%A8%E9%87%8D%E8%AF%95%EF%BC%88try-catch-%E5%BE%AA%E7%8E%AF%EF%BC%89"><span class="toc-number">12.5.1.</span> <span class="toc-text">✅ 1️⃣ 手动重试（try-catch + 循环）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%9C%85-2%EF%B8%8F%E2%83%A3-%E4%BD%BF%E7%94%A8-Retryable-%E6%B3%A8%E8%A7%A3%EF%BC%88Spring-Retry%EF%BC%89"><span class="toc-number">12.5.2.</span> <span class="toc-text">✅ 2️⃣ 使用 @Retryable 注解（Spring Retry）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B%E4%BB%A3%E7%A0%81%EF%BC%9A"><span class="toc-number">12.5.2.1.</span> <span class="toc-text">示例代码：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%9C%85-3%EF%B8%8F%E2%83%A3-%E4%BD%BF%E7%94%A8%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E9%87%8D%E8%AF%95%EF%BC%88%E4%B8%9A%E5%8A%A1%E8%A1%A5%E5%81%BF%E6%9C%BA%E5%88%B6%EF%BC%89"><span class="toc-number">12.5.3.</span> <span class="toc-text">✅ 3️⃣ 使用消息队列重试（业务补偿机制）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%9C%85-4%EF%B8%8F%E2%83%A3-%E4%BD%BF%E7%94%A8%E5%88%86%E5%B8%83%E5%BC%8F%E8%B0%83%E5%BA%A6%E6%A1%86%E6%9E%B6%EF%BC%88XXL-Job-Quartz%EF%BC%89"><span class="toc-number">12.5.4.</span> <span class="toc-text">✅ 4️⃣ 使用分布式调度框架（XXL-Job &#x2F; Quartz）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%AD%E3%80%81%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5%E5%BB%BA%E8%AE%AE%EF%BC%88%E5%B7%A5%E7%A8%8B%E7%BA%A7%EF%BC%89"><span class="toc-number">12.6.</span> <span class="toc-text">六、最佳实践建议（工程级）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%83%E3%80%81%E5%B8%B8%E8%A7%81%E8%BF%BD%E9%97%AE%E4%B8%8E%E9%AB%98%E5%88%86%E5%9B%9E%E7%AD%94"><span class="toc-number">12.7.</span> <span class="toc-text">七、常见追问与高分回答</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%9D%931%EF%B8%8F%E2%83%A3-%E8%BF%BD%E9%97%AE%EF%BC%9A%E5%A6%82%E6%9E%9C%E4%BB%BB%E5%8A%A1%E5%A4%B1%E8%B4%A5%E5%90%8E%EF%BC%8C%E6%95%B4%E4%B8%AA%E5%BA%94%E7%94%A8%E9%87%8D%E5%90%AF%E4%BA%86%E6%80%8E%E4%B9%88%E5%8A%9E%EF%BC%9F"><span class="toc-number">12.7.1.</span> <span class="toc-text">❓1️⃣ 追问：如果任务失败后，整个应用重启了怎么办？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%9D%932%EF%B8%8F%E2%83%A3-%E8%BF%BD%E9%97%AE%EF%BC%9A%E4%BB%BB%E5%8A%A1%E6%89%A7%E8%A1%8C%E4%B8%AD%E6%8A%9B%E5%87%BA%E5%BC%82%E5%B8%B8%EF%BC%8CSpring-%E4%BC%9A%E5%81%9C%E6%AD%A2%E5%90%8E%E7%BB%AD%E6%89%A7%E8%A1%8C%E5%90%97%EF%BC%9F"><span class="toc-number">12.7.2.</span> <span class="toc-text">❓2️⃣ 追问：任务执行中抛出异常，Spring 会停止后续执行吗？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%9D%933%EF%B8%8F%E2%83%A3-%E8%BF%BD%E9%97%AE%EF%BC%9ASpring-Task-%E6%94%AF%E6%8C%81%E9%9B%86%E7%BE%A4%E6%A8%A1%E5%BC%8F%E4%B8%8B%E9%81%BF%E5%85%8D%E9%87%8D%E5%A4%8D%E6%89%A7%E8%A1%8C%E5%90%97%EF%BC%9F"><span class="toc-number">12.7.3.</span> <span class="toc-text">❓3️⃣ 追问：Spring Task 支持集群模式下避免重复执行吗？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%AB%E3%80%81%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E4%B8%8E%E6%89%A9%E5%B1%95%E8%AF%9D%E9%A2%98"><span class="toc-number">12.8.</span> <span class="toc-text">八、性能分析与扩展话题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%F0%9F%94%A5-%E4%B9%9D%E3%80%81%E6%80%BB%E7%BB%93%EF%BC%88%E5%8F%AF%E8%83%8C%E8%AF%B5%E7%89%88%EF%BC%89"><span class="toc-number">12.9.</span> <span class="toc-text">🔥 九、总结（可背诵版）</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-history"></i><span>最近发布</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/posts/162c3636.html" title="IO 与序列化"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://s2.loli.net/2025/10/23/SurYK9kV8bRd2Ll.jpg?_r_=41e375ff-0cff-cb57-3980-a8c55b88e4db" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="IO 与序列化"/></a><div class="content"><a class="title" href="/posts/162c3636.html" title="IO 与序列化">IO 与序列化</a><time datetime="2025-11-03T15:31:36.000Z" title="发表于 2025-11-03 23:31:36">2025-11-03</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/aa8deaab.html" title="多线程与并发"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://s2.loli.net/2025/10/23/wfbr2eNcL1VvXIn.png?_r_=dbb2674d-771f-2e00-fee1-9ee1b678e3b8" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="多线程与并发"/></a><div class="content"><a class="title" href="/posts/aa8deaab.html" title="多线程与并发">多线程与并发</a><time datetime="2025-11-03T15:31:36.000Z" title="发表于 2025-11-03 23:31:36">2025-11-03</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/86c7f0f3.html" title="集合与泛型"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://s2.loli.net/2025/10/23/5MFUXBI3EhCAx6y.jpg?_r_=64f99dae-8ed1-5416-ed34-b0f3330ba534" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="集合与泛型"/></a><div class="content"><a class="title" href="/posts/86c7f0f3.html" title="集合与泛型">集合与泛型</a><time datetime="2025-11-03T15:31:36.000Z" title="发表于 2025-11-03 23:31:36">2025-11-03</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/c65c3b86.html" title="Java后端工程师-王帅锴简历"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://s2.loli.net/2025/10/23/pH7DOX5rqdLCk4b.jpg?_r_=1acf6979-2e29-dbe5-631a-b36885e8ecfa" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Java后端工程师-王帅锴简历"/></a><div class="content"><a class="title" href="/posts/c65c3b86.html" title="Java后端工程师-王帅锴简历">Java后端工程师-王帅锴简历</a><time datetime="2025-11-03T09:31:36.000Z" title="发表于 2025-11-03 17:31:36">2025-11-03</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/f7ede91d.html" title="Java基础"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://s2.loli.net/2025/10/23/w3ErpsQhncfDed2.jpg?_r_=7699c7cd-000a-265b-8b3e-a56b7a115364" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Java基础"/></a><div class="content"><a class="title" href="/posts/f7ede91d.html" title="Java基础">Java基础</a><time datetime="2025-11-03T09:31:36.000Z" title="发表于 2025-11-03 17:31:36">2025-11-03</time></div></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div id="workboard"><img class="workSituationImg boardsign" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://npm.elemecdn.com/anzhiyu-blog@2.0.4/img/badge/安知鱼-上班摸鱼中.svg" alt="距离月入25k也就还差一个大佬带我~" title="距离月入25k也就还差一个大佬带我~"/><div id="runtimeTextTip"></div></div><p id="ghbdages"><a class="github-badge" target="_blank" href="https://hexo.io/" style="margin-inline:5px" data-title="博客框架为Hexo_v5.4.0" title="博客框架为Hexo_v5.4.0"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://npm.elemecdn.com/anzhiyu-blog@2.1.5/img/badge/Frame-Hexo.svg" alt="博客框架为Hexo_v5.4.0"/></a><a class="github-badge" target="_blank" href="https://blog.anheyu.com/" style="margin-inline:5px" data-title="本站使用AnZhiYu主题" title="本站使用AnZhiYu主题"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://npm.elemecdn.com/anzhiyu-theme-static@1.0.9/img/Theme-AnZhiYu-2E67D3.svg" alt="本站使用AnZhiYu主题"/></a><a class="github-badge" target="_blank" href="https://www.dogecloud.com/" style="margin-inline:5px" data-title="本站使用多吉云为静态资源提供CDN加速" title="本站使用多吉云为静态资源提供CDN加速"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://npm.elemecdn.com/anzhiyu-blog@2.2.0/img/badge/CDN-多吉云-3693F3.svg" alt="本站使用多吉云为静态资源提供CDN加速"/></a><a class="github-badge" target="_blank" href="https://github.com/" style="margin-inline:5px" data-title="本站项目由Github托管" title="本站项目由Github托管"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://npm.elemecdn.com/anzhiyu-blog@2.1.5/img/badge/Source-Github.svg" alt="本站项目由Github托管"/></a><a class="github-badge" target="_blank" href="http://creativecommons.org/licenses/by-nc-sa/4.0/" style="margin-inline:5px" data-title="本站采用知识共享署名-非商业性使用-相同方式共享4.0国际许可协议进行许可" title="本站采用知识共享署名-非商业性使用-相同方式共享4.0国际许可协议进行许可"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://npm.elemecdn.com/anzhiyu-blog@2.2.0/img/badge/Copyright-BY-NC-SA.svg" alt="本站采用知识共享署名-非商业性使用-相同方式共享4.0国际许可协议进行许可"/></a></p></div><div id="footer-bar"><div class="footer-bar-links"><div class="footer-bar-left"><div id="footer-bar-tips"><div class="copyright">&copy;2020 - 2025 By <a class="footer-bar-link" href="/" title="Wsk" target="_blank">Wsk</a></div></div><div id="footer-type-tips"></div></div><div class="footer-bar-right"><a class="footer-bar-link" target="_blank" rel="noopener" href="https://github.com/anzhiyu-c/hexo-theme-anzhiyu" title="主题">主题</a></div></div></div></footer></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="sidebar-site-data site-data is-center"><a href="/archives/" title="archive"><div class="headline">文章</div><div class="length-num">16</div></a><a href="/tags/" title="tag"><div class="headline">标签</div><div class="length-num">24</div></a><a href="/categories/" title="category"><div class="headline">分类</div><div class="length-num">2</div></a></div><span class="sidebar-menu-item-title">功能</span><div class="sidebar-menu-item"><a class="darkmode_switchbutton menu-child" href="javascript:void(0);" title="显示模式"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i><span>显示模式</span></a></div><div class="back-menu-list-groups"><div class="back-menu-list-group"><div class="back-menu-list-title">网页</div><div class="back-menu-list"><a class="back-menu-item" target="_blank" rel="noopener" href="https://blog.anheyu.com/" title="博客"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/favicon.png" alt="博客"/><span class="back-menu-item-text">博客</span></a></div></div></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 文章</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/archives/"><i class="anzhiyufont anzhiyu-icon-box-archive faa-tada" style="font-size: 0.9em;"></i><span> 隧道</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/categories/"><i class="anzhiyufont anzhiyu-icon-shapes faa-tada" style="font-size: 0.9em;"></i><span> 分类</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/tags/"><i class="anzhiyufont anzhiyu-icon-tags faa-tada" style="font-size: 0.9em;"></i><span> 标签</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 友链</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/link/"><i class="anzhiyufont anzhiyu-icon-link faa-tada" style="font-size: 0.9em;"></i><span> 友人帐</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/fcircle/"><i class="anzhiyufont anzhiyu-icon-artstation faa-tada" style="font-size: 0.9em;"></i><span> 朋友圈</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/comments/"><i class="anzhiyufont anzhiyu-icon-envelope faa-tada" style="font-size: 0.9em;"></i><span> 留言板</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 我的</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/music/?id=2898229193&amp;server=netease"><i class="anzhiyufont anzhiyu-icon-music faa-tada" style="font-size: 0.9em;"></i><span> 音乐馆</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/album/"><i class="anzhiyufont anzhiyu-icon-images faa-tada" style="font-size: 0.9em;"></i><span> 相册集</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/air-conditioner/"><i class="anzhiyufont anzhiyu-icon-fan faa-tada" style="font-size: 0.9em;"></i><span> 小空调</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 关于</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/about/"><i class="anzhiyufont anzhiyu-icon-paper-plane faa-tada" style="font-size: 0.9em;"></i><span> 关于本人</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/essay/"><i class="anzhiyufont anzhiyu-icon-lightbulb faa-tada" style="font-size: 0.9em;"></i><span> 闲言碎语</span></a></li></ul></div></div><span class="sidebar-menu-item-title">标签</span><div class="card-tags"><div class="item-headline"></div><div class="card-tag-cloud"><a href="/tags/AOP/" style="font-size: 0.88rem;">AOP<sup>2</sup></a><a href="/tags/IO/" style="font-size: 0.88rem;">IO<sup>1</sup></a><a href="/tags/IOC/" style="font-size: 0.88rem;">IOC<sup>2</sup></a><a href="/tags/JVM/" style="font-size: 0.88rem;">JVM<sup>1</sup></a><a href="/tags/JVM%E8%B0%83%E4%BC%98/" style="font-size: 0.88rem;">JVM调优<sup>1</sup></a><a href="/tags/java%E5%90%8E%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%B8%88/" style="font-size: 0.88rem;">java后端工程师<sup>1</sup></a><a href="/tags/java%E5%9F%BA%E7%A1%80/" style="font-size: 0.88rem;">java基础<sup>1</sup></a><a href="/tags/mysql/" style="font-size: 0.88rem;">mysql<sup>1</sup></a><a href="/tags/%E4%BC%98%E6%83%A0%E5%8D%B7/" style="font-size: 0.88rem;">优惠卷<sup>1</sup></a><a href="/tags/%E5%95%86%E5%93%81/" style="font-size: 0.88rem;">商品<sup>1</sup></a><a href="/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/" style="font-size: 0.88rem;">多线程<sup>1</sup></a><a href="/tags/%E5%B9%B6%E5%8F%91/" style="font-size: 0.88rem;">并发<sup>1</sup></a><a href="/tags/%E5%BA%8F%E5%88%97%E5%8C%96/" style="font-size: 0.88rem;">序列化<sup>1</sup></a><a href="/tags/%E5%BC%82%E5%B8%B8/" style="font-size: 0.88rem;">异常<sup>1</sup></a><a href="/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/" style="font-size: 0.88rem;">数据库<sup>1</sup></a><a href="/tags/%E6%B3%9B%E5%9E%8B/" style="font-size: 0.88rem;">泛型<sup>1</sup></a><a href="/tags/%E7%94%B5%E5%95%86/" style="font-size: 0.88rem;">电商<sup>1</sup></a><a href="/tags/%E7%94%B5%E5%95%86-%E8%AE%A2%E5%8D%95/" style="font-size: 0.88rem;">电商,订单<sup>1</sup></a><a href="/tags/%E7%A7%92%E6%9D%80/" style="font-size: 0.88rem;">秒杀<sup>1</sup></a><a href="/tags/%E7%AE%80%E5%8E%86/" style="font-size: 0.88rem;">简历<sup>1</sup></a><a href="/tags/%E8%87%AA%E5%8A%A8%E8%A3%85%E9%85%8D/" style="font-size: 0.88rem;">自动装配<sup>1</sup></a><a href="/tags/%E8%AE%A2%E5%8D%95/" style="font-size: 0.88rem;">订单<sup>1</sup></a><a href="/tags/%E8%B6%85%E5%8D%96-%E5%BA%93%E5%AD%98/" style="font-size: 0.88rem;">超卖 , 库存<sup>1</sup></a><a href="/tags/%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/" style="font-size: 0.88rem;">集合框架<sup>1</sup></a></div></div><hr/></div></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="anzhiyufont anzhiyu-icon-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">简</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="anzhiyufont anzhiyu-icon-arrows-left-right"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="anzhiyufont anzhiyu-icon-gear"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="anzhiyufont anzhiyu-icon-list-ul"></i></button><button id="chat-btn" type="button" title="聊天"><i class="anzhiyufont anzhiyu-icon-comment-sms"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="anzhiyufont anzhiyu-icon-comments"></i></a><a id="switch-commentBarrage" href="javascript:anzhiyu.switchCommentBarrage();" title="开关弹幕"><i class="anzhiyufont anzhiyu-icon-danmu"></i></a><button id="go-up" type="button" title="回到顶部"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></button></div></div><div id="nav-music"><a id="nav-music-hoverTips" onclick="anzhiyu.musicToggle()" accesskey="m">播放音乐</a><div id="console-music-bg"></div><meting-js id="8152976493" server="netease" type="playlist" mutex="true" preload="none" theme="var(--anzhiyu-main)" data-lrctype="0" order="random"></meting-js></div><div id="rightMenu"><div class="rightMenu-group rightMenu-small"><div class="rightMenu-item" id="menu-backward"><i class="anzhiyufont anzhiyu-icon-arrow-left"></i></div><div class="rightMenu-item" id="menu-forward"><i class="anzhiyufont anzhiyu-icon-arrow-right"></i></div><div class="rightMenu-item" id="menu-refresh"><i class="anzhiyufont anzhiyu-icon-arrow-rotate-right" style="font-size: 1rem;"></i></div><div class="rightMenu-item" id="menu-top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></div></div><div class="rightMenu-group rightMenu-line rightMenuPlugin"><div class="rightMenu-item" id="menu-copytext"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制选中文本</span></div><div class="rightMenu-item" id="menu-pastetext"><i class="anzhiyufont anzhiyu-icon-paste"></i><span>粘贴文本</span></div><a class="rightMenu-item" id="menu-commenttext"><i class="anzhiyufont anzhiyu-icon-comment-medical"></i><span>引用到评论</span></a><div class="rightMenu-item" id="menu-newwindow"><i class="anzhiyufont anzhiyu-icon-window-restore"></i><span>新窗口打开</span></div><div class="rightMenu-item" id="menu-copylink"><i class="anzhiyufont anzhiyu-icon-link"></i><span>复制链接地址</span></div><div class="rightMenu-item" id="menu-copyimg"><i class="anzhiyufont anzhiyu-icon-images"></i><span>复制此图片</span></div><div class="rightMenu-item" id="menu-downloadimg"><i class="anzhiyufont anzhiyu-icon-download"></i><span>下载此图片</span></div><div class="rightMenu-item" id="menu-newwindowimg"><i class="anzhiyufont anzhiyu-icon-window-restore"></i><span>新窗口打开图片</span></div><div class="rightMenu-item" id="menu-search"><i class="anzhiyufont anzhiyu-icon-magnifying-glass"></i><span>站内搜索</span></div><div class="rightMenu-item" id="menu-searchBaidu"><i class="anzhiyufont anzhiyu-icon-magnifying-glass"></i><span>百度搜索</span></div><div class="rightMenu-item" id="menu-music-toggle"><i class="anzhiyufont anzhiyu-icon-play"></i><span>播放音乐</span></div><div class="rightMenu-item" id="menu-music-back"><i class="anzhiyufont anzhiyu-icon-backward"></i><span>切换到上一首</span></div><div class="rightMenu-item" id="menu-music-forward"><i class="anzhiyufont anzhiyu-icon-forward"></i><span>切换到下一首</span></div><div class="rightMenu-item" id="menu-music-playlist" onclick="window.open(&quot;https://y.qq.com/n/ryqq/playlist/8152976493&quot;, &quot;_blank&quot;);" style="display: none;"><i class="anzhiyufont anzhiyu-icon-radio"></i><span>查看所有歌曲</span></div><div class="rightMenu-item" id="menu-music-copyMusicName"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制歌名</span></div></div><div class="rightMenu-group rightMenu-line rightMenuOther"><a class="rightMenu-item menu-link" id="menu-randomPost"><i class="anzhiyufont anzhiyu-icon-shuffle"></i><span>随便逛逛</span></a><a class="rightMenu-item menu-link" href="/categories/"><i class="anzhiyufont anzhiyu-icon-cube"></i><span>博客分类</span></a><a class="rightMenu-item menu-link" href="/tags/"><i class="anzhiyufont anzhiyu-icon-tags"></i><span>文章标签</span></a></div><div class="rightMenu-group rightMenu-line rightMenuOther"><a class="rightMenu-item" id="menu-copy" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制地址</span></a><a class="rightMenu-item" id="menu-commentBarrage" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-message"></i><span class="menu-commentBarrage-text">关闭热评</span></a><a class="rightMenu-item" id="menu-darkmode" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i><span class="menu-darkmode-text">深色模式</span></a><a class="rightMenu-item" id="menu-translate" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-language"></i><span>轉為繁體</span></a></div></div><div id="rightmenu-mask"></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.cbd.int/@fancyapps/ui@5.0.20/dist/fancybox/fancybox.umd.js"></script><script src="https://cdn.cbd.int/instant.page@5.2.0/instantpage.js" type="module"></script><script src="https://cdn.cbd.int/vanilla-lazyload@17.8.4/dist/lazyload.iife.min.js"></script><script src="https://cdn.cbd.int/node-snackbar@0.1.16/dist/snackbar.min.js"></script><canvas id="universe"></canvas><script async src="https://npm.elemecdn.com/anzhiyu-theme-static@1.0.0/dark/dark.js"></script><script>// 消除控制台打印
var HoldLog = console.log;
console.log = function () {};
let now1 = new Date();
queueMicrotask(() => {
  const Log = function () {
    HoldLog.apply(console, arguments);
  }; //在恢复前输出日志
  const grt = new Date("04/01/2023 00:00:00"); //此处修改你的建站时间或者网站上线时间
  now1.setTime(now1.getTime() + 250);
  const days = (now1 - grt) / 1000 / 60 / 60 / 24;
  const dnum = Math.floor(days);
  const ascll = [
    `欢迎使用安知鱼!`,
    `生活明朗, 万物可爱`,
    `
        
       █████╗ ███╗   ██╗███████╗██╗  ██╗██╗██╗   ██╗██╗   ██╗
      ██╔══██╗████╗  ██║╚══███╔╝██║  ██║██║╚██╗ ██╔╝██║   ██║
      ███████║██╔██╗ ██║  ███╔╝ ███████║██║ ╚████╔╝ ██║   ██║
      ██╔══██║██║╚██╗██║ ███╔╝  ██╔══██║██║  ╚██╔╝  ██║   ██║
      ██║  ██║██║ ╚████║███████╗██║  ██║██║   ██║   ╚██████╔╝
      ╚═╝  ╚═╝╚═╝  ╚═══╝╚══════╝╚═╝  ╚═╝╚═╝   ╚═╝    ╚═════╝
        
        `,
    "已上线",
    dnum,
    "天",
    "©2020 By 安知鱼 V1.6.8",
  ];
  const ascll2 = [`NCC2-036`, `调用前置摄像头拍照成功，识别为【小笨蛋】.`, `Photo captured: `, `🤪`];

  setTimeout(
    Log.bind(
      console,
      `\n%c${ascll[0]} %c ${ascll[1]} %c ${ascll[2]} %c${ascll[3]}%c ${ascll[4]}%c ${ascll[5]}\n\n%c ${ascll[6]}\n`,
      "color:#425AEF",
      "",
      "color:#425AEF",
      "color:#425AEF",
      "",
      "color:#425AEF",
      ""
    )
  );
  setTimeout(
    Log.bind(
      console,
      `%c ${ascll2[0]} %c ${ascll2[1]} %c \n${ascll2[2]} %c\n${ascll2[3]}\n`,
      "color:white; background-color:#4fd953",
      "",
      "",
      'background:url("https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/tinggge.gif") no-repeat;font-size:450%'
    )
  );

  setTimeout(Log.bind(console, "%c WELCOME %c 你好，小笨蛋.", "color:white; background-color:#4f90d9", ""));

  setTimeout(
    console.warn.bind(
      console,
      "%c ⚡ Powered by 安知鱼 %c 你正在访问 Wsk 的博客.",
      "color:white; background-color:#f0ad4e",
      ""
    )
  );

  setTimeout(Log.bind(console, "%c W23-12 %c 你已打开控制台.", "color:white; background-color:#4f90d9", ""));

  setTimeout(
    console.warn.bind(console, "%c S013-782 %c 你现在正处于监控中.", "color:white; background-color:#d9534f", "")
  );
});</script><script async src="/anzhiyu/random.js"></script><script async="async">(function () {
  var grt = new Date("04/01/2023 00:00:00"); //设置网站上线时间
  var now = new Date();
  var dnum;
  var hnum;
  var mnum;
  var snum;
  var nowHour;

  // 计算并更新天数、小时数、分钟数和秒数
  function updateTime() {
    now = new Date(); // 更新 now 的值
    nowHour = now.getHours(); // 更新 nowHour 的值
    var days = (now - grt) / 1000 / 60 / 60 / 24;
    dnum = Math.floor(days);
    var hours = (now - grt) / 1000 / 60 / 60 - 24 * dnum;
    hnum = Math.floor(hours);
    if (String(hnum).length == 1) {
      hnum = "0" + hnum;
    }
    var minutes = (now - grt) / 1000 / 60 - 24 * 60 * dnum - 60 * hnum;
    mnum = Math.floor(minutes);
    if (String(mnum).length == 1) {
      mnum = "0" + mnum;
    }
    var seconds = (now - grt) / 1000 - 24 * 60 * 60 * dnum - 60 * 60 * hnum - 60 * mnum;
    snum = Math.round(seconds);
    if (String(snum).length == 1) {
      snum = "0" + snum;
    }
  }

  // 更新网页中显示的网站运行时间
  function updateHtml() {
    const footer = document.getElementById("footer");
    if (!footer) return
    let currentTimeHtml = "";
    if (nowHour < 18 && nowHour >= 9) {
      // 如果是上班时间，默认就是"安知鱼-上班摸鱼中.svg"图片，不需要更改
      currentTimeHtml = `本站居然运行了 ${dnum} 天<span id='runtime'> ${hnum} 小时 ${mnum} 分 ${snum} 秒 </span><i class='anzhiyufont anzhiyu-icon-heartbeat' style='color:red'></i>`;
    } else {
      // 如果是下班时间，插入"安知鱼-下班啦.svg"图片
      let img = document.querySelector("#workboard .workSituationImg");
      img.src = "";
      img.title = "";
      img.alt = "";

      currentTimeHtml = `本站居然运行了 ${dnum} 天<span id='runtime'> ${hnum} 小时 ${mnum} 分 ${snum} 秒 </span><i class='anzhiyufont anzhiyu-icon-heartbeat' style='color:red'></i>`;
    }

    if (document.getElementById("runtimeTextTip")) {
      document.getElementById("runtimeTextTip").innerHTML = currentTimeHtml;
    }
  }

  setInterval(() => {
    updateTime();
    updateHtml();
  }, 1000);
})();</script><div class="js-pjax"><script>(() => {
  const initValine = () => {
    const valine = new Valine(Object.assign({
      el: '#vcomment',
      appId: '4GK2IcRZ0PX28gP4kGsW08qs-gzGzoHsz',
      appKey: 'TjKeHNK7GJrGTYuKYzGzh8yg',
      avatar: 'mp',
      serverURLs: '',
      emojiMaps: {"tv_doge":"6ea59c827c414b4a2955fe79e0f6fd3dcd515e24.png","tv_亲亲":"a8111ad55953ef5e3be3327ef94eb4a39d535d06.png","tv_偷笑":"bb690d4107620f1c15cff29509db529a73aee261.png","tv_再见":"180129b8ea851044ce71caf55cc8ce44bd4a4fc8.png","tv_冷漠":"b9cbc755c2b3ee43be07ca13de84e5b699a3f101.png","tv_发怒":"34ba3cd204d5b05fec70ce08fa9fa0dd612409ff.png","tv_发财":"34db290afd2963723c6eb3c4560667db7253a21a.png","tv_可爱":"9e55fd9b500ac4b96613539f1ce2f9499e314ed9.png","tv_吐血":"09dd16a7aa59b77baa1155d47484409624470c77.png","tv_呆":"fe1179ebaa191569b0d31cecafe7a2cd1c951c9d.png","tv_呕吐":"9f996894a39e282ccf5e66856af49483f81870f3.png","tv_困":"241ee304e44c0af029adceb294399391e4737ef2.png","tv_坏笑":"1f0b87f731a671079842116e0991c91c2c88645a.png","tv_大佬":"093c1e2c490161aca397afc45573c877cdead616.png","tv_大哭":"23269aeb35f99daee28dda129676f6e9ea87934f.png","tv_委屈":"d04dba7b5465779e9755d2ab6f0a897b9b33bb77.png","tv_害羞":"a37683fb5642fa3ddfc7f4e5525fd13e42a2bdb1.png","tv_尴尬":"7cfa62dafc59798a3d3fb262d421eeeff166cfa4.png","tv_微笑":"70dc5c7b56f93eb61bddba11e28fb1d18fddcd4c.png","tv_思考":"90cf159733e558137ed20aa04d09964436f618a1.png","tv_惊吓":"0d15c7e2ee58e935adc6a7193ee042388adc22af.png"},
      path: window.location.pathname,
      visitor: false
    }, null))
  }

  const loadValine = async () => {
    if (typeof Valine === 'function') initValine()
    else {
      await getScript('https://cdn.cbd.int/valine@1.5.1/dist/Valine.min.js')
      initValine()
    }
  }

  if ('Valine' === 'Valine' || !false) {
    if (false) anzhiyu.loadComment(document.getElementById('vcomment'),loadValine)
    else setTimeout(loadValine, 0)
  } else {
    window.loadOtherComment = loadValine
  }
})()</script><input type="hidden" name="page-type" id="page-type" value="post"></div><script src="https://cdn.cbd.int/blueimp-md5@2.19.0/js/md5.min.js"></script><script>window.addEventListener('load', () => {
  const changeContent = (content) => {
    if (content === '') return content

    content = content.replace(/<img.*?src="(.*?)"?[^\>]+>/ig, '[图片]') // replace image link
    content = content.replace(/<a[^>]+?href=["']?([^"']+)["']?[^>]*>([^<]+)<\/a>/gi, '[链接]') // replace url
    content = content.replace(/<pre><code>.*?<\/pre>/gi, '[代码]') // replace code
    content = content.replace(/<[^>]+>/g,"") // remove html tag

    if (content.length > 150) {
      content = content.substring(0,150) + '...'
    }
    return content
  }

  const getIcon = (icon, mail) => {
    if (icon) return icon
    let defaultIcon = '?d=mp'
    let iconUrl = `https://gravatar.loli.net/avatar/${md5(mail.toLowerCase()) + defaultIcon}`
    return iconUrl
  }

  const generateHtml = array => {
    let result = ''

    if (array.length) {
      for (let i = 0; i < array.length; i++) {
        result += '<div class=\'aside-list-item\'>'

        if (true) {
          const name = 'data-lazy-src'
          result += `<a href='${array[i].url}' class='thumbnail'><img ${name}='${array[i].avatar}' alt='${array[i].nick}'></a>`
        }

        result += `<div class='content'>
        <a class='comment' href='${array[i].url}' title='${array[i].content}'>${array[i].content}</a>
        <div class='name'><span>${array[i].nick} / </span><time datetime="${array[i].date}">${anzhiyu.diffDate(array[i].date, true)}</time></div>
        </div></div>`
      }
    } else {
      result += '没有评论'
    }

    let $dom = document.querySelector('#card-newest-comments .aside-list')
    $dom.innerHTML= result
    window.lazyLoadInstance && window.lazyLoadInstance.update()
    window.pjax && window.pjax.refresh($dom)
  }

  const getComment = () => {
    const serverURL = 'https://4GK2IcRZ.api.lncldglobal.com'

    var settings = {
      "method": "GET",
      "headers": {
        "X-LC-Id": '4GK2IcRZ0PX28gP4kGsW08qs-gzGzoHsz',
        "X-LC-Key": 'TjKeHNK7GJrGTYuKYzGzh8yg',
        "Content-Type": "application/json"
      },
    }

    fetch(`${serverURL}/1.1/classes/Comment?limit=6&order=-createdAt`,settings)
      .then(response => response.json())
      .then(data => {
        const valineArray = data.results.map(function (e) {
          return {
            'avatar': getIcon(e.QQAvatar, e.mail),
            'content': changeContent(e.comment),
            'nick': e.nick,
            'url': e.url + '#' + e.objectId,
            'date': e.updatedAt,
          }
        })
        saveToLocal.set('valine-newest-comments', JSON.stringify(valineArray), 10/(60*24))
        generateHtml(valineArray)
      }).catch(e => {
        const $dom = document.querySelector('#card-newest-comments .aside-list')
        $dom.textContent= "无法获取评论，请确认相关配置是否正确"
      }) 
  }

  const newestCommentInit = () => {
    if (document.querySelector('#card-newest-comments .aside-list')) {
      const data = saveToLocal.get('valine-newest-comments')
      if (data) {
        generateHtml(JSON.parse(data))
      } else {
        getComment()
      }
    }
  }

  newestCommentInit()
  document.addEventListener('pjax:complete', newestCommentInit)
})</script><script>var visitorMail = "visitor@anheyu.com";
</script><script async data-pjax src="https://cdn.cbd.int/anzhiyu-theme-static@1.0.0/waterfall/waterfall.js"></script><script src="https://lf3-cdn-tos.bytecdntp.com/cdn/expire-1-M/qrcodejs/1.0.0/qrcode.min.js"></script><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.1.9/icon/ali_iconfont_css.css"><script src="//code.tidio.co/4nifo6zdbrmyjsngh2yzxwbnlhrvshrf.js" async="async"></script><script>(() => {
  const isChatBtn = true
  const isChatHideShow = true

  if (isChatBtn) {
    let isShow = false
    const close = () => {
      window.tidioChatApi.hide()
      isShow = false
    }
    
    const open = () => {
      window.tidioChatApi.open()
      window.tidioChatApi.show()
      isShow = true
    }

    const onTidioChatApiReady = () => {
      window.tidioChatApi.hide()
      window.tidioChatApi.on("close", close)
    }
    if (window.tidioChatApi) {
      window.tidioChatApi.on("ready", onTidioChatApiReady)
    } else {
      document.addEventListener("tidioChat-ready", onTidioChatApiReady)
    }

    window.chatBtnFn = () => {
      if (!window.tidioChatApi) return
      isShow ? close() : open()
    }
  } else if (isChatHideShow) {
    window.chatBtn = {
      hide: () => {
        window.tidioChatApi && window.tidioChatApi.hide()
      },
      show: () => {
        window.tidioChatApi && window.tidioChatApi.show()
      }
    }
  }
})()</script><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.0.0/aplayer/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.cbd.int/anzhiyu-blog-static@1.0.1/js/APlayer.min.js"></script><script src="https://cdn.cbd.int/hexo-anzhiyu-music@1.0.1/assets/js/Meting2.min.js"></script><script src="https://cdn.cbd.int/pjax@0.2.8/pjax.min.js"></script><script>let pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]
var pjax = new Pjax({
  elements: 'a:not([target="_blank"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {
  // removeEventListener scroll 
  anzhiyu.removeGlobalFnEvent('pjax')
  anzhiyu.removeGlobalFnEvent('themeChange')

  document.getElementById('rightside').classList.remove('rightside-show')
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')
})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()
})

document.addEventListener('pjax:error', e => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script charset="UTF-8" src="https://cdn.cbd.int/anzhiyu-theme-static@1.1.5/accesskey/accesskey.js"></script></div><div id="popup-window"><div class="popup-window-title">通知</div><div class="popup-window-divider"></div><div class="popup-window-content"><div class="popup-tip">你好呀</div><div class="popup-link"><i class="anzhiyufont anzhiyu-icon-arrow-circle-right"></i></div></div></div></body></html>